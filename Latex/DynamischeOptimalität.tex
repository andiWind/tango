\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[ngerman,german]{babel}
\usepackage[T1]{fontenc}
\usepackage{courier}
\usepackage{float}
\usepackage{amsmath,amsthm}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{csquotes}
\usepackage[font=small,labelfont=bf]{caption}

%\usepackage[pages=some]{background} % Draft Wasserzeichen mit Option pages=all sonst pages=some



\title{Bachelorarbeit}
\author{
Andreas Windorfer\\
}
\date{\today}


\begin {document}


\maketitle
\newpage

\tableofcontents
\newpage

\section{Dynamische Optimalität}
Dieses Kapitel beschäftigt sich vor allem mit der Laufzeit von Folgen von \textit{access} Operationen, eine speziellere Form der \textit{search} Operation.  
\subsection{BST Zugriffsalgorithmus }
Sei $T$ ein BST mit der Schlüsselmenge $K$. Beschränkt man den Parameter von \textit{search} auf $k \in K $ bezeichnet man die Operation als \textit{access}. In diesem Kapitel werden Folgen solcher \textit{access} Operationen betrachtet. Notiert wird eine solche Zugriffsfolge durch Angabe der Parameter. Bei der Zugriffsfolge $x_1,x_2,...x_m$ wird also zunächst \textit{access($x_1$)} ausgeführt, dann \textit{access($x_2$)} usw.  Bei BST wird bezüglich Zugriffssequenzen zwischen online und offline Varianten unterschieden. Bei \textit{offline BST} ist die Zugriffsfolge zu Beginn bereits bekannt, somit kann ein Startzustand gewählt werden, der die Kosten minimiert. Beim \textit{online BST} ist die Zugriffsfolge zu Beginn nicht bekannt. Bei einer worst case Laufzeit-Analyse muss somit von dem Startzustand ausgegangen werden bei dem die Kosten am höchsten sind.
Ein BST der lediglich die \textit{access} Operation auf einer festen Schlüsselmenge anbietet, wird als \textbf{BST access algorithm} bezeichnet, wenn seine Operation folgende Eigenschaften einhält. 

\begin{enumerate} 
	\item Der Algorithmus verfügt über genau einen Zeiger $p$ in den BST. Dieser wird zu Beginn so initialisiert, dass er auf die Wurzel zeigt. Terminiert der Algorithmus muss $p$ auf den Knoten mit Schlüssel $k$ zeigen.
	\item Der Algorithmus führt eine Folge dieser Einzelschritte durch:
	\begin{itemize}
		\item Setze $p$ auf das linke Kind von $p$.
		\item Setze $p$ auf das rechte Kind von $p$.
		\item Setze $p$ auf den Vater von $p$.
		\item Führe eine Rotation auf $p$ aus.
	\end{itemize}  
	\item  Zur Auswahl des nächsten Einzelschrittes können in den Knoten gespeicherte Hilfsdaten verwendet werden. Es kann nur auf die Hilfsdaten des Knotens zugegriffen werden (lesend oder schreibend), auf den $p$ zeigt.    
\end{enumerate}

 
 \noindent  Es wird $n = \vert K \vert$ gesetzt. Außerdem werden hier pro Knoten nur Hilfsdaten in konstanter Größenordnung zugelassen. 
 
 \noindent Die Initialisierung sowie die Auswahl und Durchführung jedes Einzelschrittes aus Punkt 2 kann in konstanter Zeit durchgeführt werden. Es werden jeweils Einheitskosten von $1$ verwendet. Höhere angenommene Kosten würden die Gesamtkosten lediglich um einen konstanten Faktor erhöhen. Es sei $a$ die Anzahl der insgesamt durchgeführten Einzelschritte während einer Zugriffsfolge $X$ mit Länge $m$. Dann berechnen sich die Gesamtkosten $\mathit{cost(X)}$ der Zugriffsfolge mit $\mathit{cost(X)} = a + m$. Es muss zu jeder Schlüsselmenge und jeder Zugriffsfolge zumindest einen offline BST access algorithm geben, so dass die Kosten keines anderen niedriger sind. Diese Kosten werden als $\mathit{OPT}\left(X\right)$ bezeichnet.\\  In \cite{nRotations} wurde gezeigt, dass der Zustand eines BST mit maximal $2n -2$ Rotationen in jeden anderen gültigen BST Zustand mit der gleichen Schlüsselmenge überführt werden kann. Da bei der Berechnung der Kosten für  $\mathit{OPT(X)}$, $m$ ebenfalls als Summand vorkommt, können die zusätzlichen Kosten der online Varianten, für $m > n$ asymptotisch betrachtet vernachlässigt werden. \\
 \noindent Als \textbf{dynamisch optimal } wird ein BST bezeichnet wenn er eine beliebige Zugriffssequenz $X$ in $O\left(\mathit{OPT}\left(X\right)\right)$ Zeit ausführen kann. Ein BST der jede Zugriffssequenz in $O\left(c \cdot \mathit{OPT}\left(X\right)\right)$ Zeit ausführt, wird als \textbf{c-competitive} bezeichnet. Es konnte bis heute für keinen BST bewiesen werden, dass er dynamisch optimal ist. Es wurden aber mehrere untere Schranken für $\mathit{OPT}\left(X\right)$ gefunden. Eine davon wird  nun vorgestellt.


\subsection{Erste untere Schranke von Wilber}
Robert Wilber hat in \cite{wilberLowerBounds} zwei Methoden zur Berechnung unterer Schranken für die Laufzeit von BST access algorithm vorgestellt. Hier wird auf die Erste davon eingegangen. Im folgenden werden offline BST access algorithm betrachtet, bei denen nach einer \textit{access($k$)} Operation, der Knoten mit Schlüssel $k$ die Wurzel des BST ist. Dies bezeichnet man als \textbf{standard offline BST access algorithm } asymptotisch betrachtet entsteht hierdurch kein Verlust der Allgemeinheit. Sei $d$ die Tiefe von $p$ zum Zeitpunkt $t$ direkt vor der Terminierung von \textit{access}. Dann sind mindestens Kosten $d + 1$ entstanden. Mit $d$ Rotationen kann $p$ zur Wurzel gemacht werden und mit $d$ weiteren Rotationen kann der Zustand zum Zeitpunkt $t$ wieder hergestellt werden.
Für einen BST $T$ mit Schlüsselmenge $K_T$ und einer Zugriffsfolge $X$ notieren wir die minimalen Kosten eines wie eben vorgestellt arbeitenden BST access algorithm mit $W(X, T)$. Im folgenden wird angenommen, dass \\
$K = \{  i \in \mathbb{N} \vert i \in \left[j,k\right] \textit{ mit } j,k \in  \mathbb{N} \} $ gilt. Dadurch entsteht kein Verlust der Allgemeinheit, denn anderenfalls könnte man die Schlüsselmenge einfach aufsteigend sortiert mit $j$ startend durchnummerieren. Eine Rotation wird innerhalb dieses Kapitels mit $\left(i, j\right)$ notiert. $i$ ist dabei der Schlüssel des Knotens $v$ auf dem die Rotation ausgeführt wird, vergleiche Kapitel \ref{noch einsetzrn}. $j$ ist der Schlüssel des Vaters von $v$, vor Ausführung der Rotation. Für eine Folge von Rotationen $r = \left(i_1,j_1 \right),\left(i_2,j_2 \right),..,\left(i_n,j_n \right)$ erhält man die Folge  $r^y_x = \left(i_{1'},j_{1'}\right),\left(i_{2'},j_{2'} \right),..,\left(i_{m'},j_{m'} \right)$  in dem man aus $r$ jede Rotation entfernt bei der $i\notin \left[l,r\right] \lor j\notin \left[l,r\right]$ gilt. Ähnlich erhält man aus $X$ die Zugriffsfolge $X^y_x$ in dem aus $X$ alle Schlüssel $k$ entfernt werden, für die $k < x  \lor k > y$ gilt.

\paragraph{lower bound tree} \label{wilberLowerBoundTree}
Ein lower bound tree $Y$ zu $T$ ist ein BST, der genau $2 \left(k - j \right) + 1$ Knoten enthält. Seine $\vert K \vert$ Blätter enthalten die Schlüssel aus $K$. Die $\left(k - j \right)$ internen Knoten enthalten die Schlüssel aus der Menge $\{r \in R \vert \exists i,j \in K \left( i + 1 = j \land r = i + 0,5\right)\}$. $Y$ kann immer erstellt werden indem zunächst ein BST $Y_i$ mit den internen Knoten von $Y$ erzeugt wird. Ein Blatt wird dann an der Position angefügt, an der die Standardvariante von \textit{einfügen} angewendet auf $Y_i$ ihren Schlüssel einfügen würde. Dass hierbei für zwei Blätter mit Schlüssel $k_1, k_2$ die gleiche Position gewählt wird ist ausgeschlossen, da es einen internen Knoten mit Schlüssel $k_i$ so geben muss dass $k_1 < k_i < k_2 \lor k_1 > k_i > k_2 $ gilt. An der Konstruktionsanleitung ist zu erkennen, dass zu den meisten BST mehrere mögliche lower bound trees existieren. Abbildung \ref{fig:lowerBoundTree} zeigt eine beispielhafte Konstellation. \\


        
\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{"Medien/DynOpt/lowerBoundTree"}
	\caption{Rechts ist ein möglicher lower bound tree zum linken BST dargestellt.  }
	\label{fig:lowerBoundTree}
\end{figure}

\noindent Nun wird die Funkion $_X(T, Y, X) $ vorgestellt. Ihre Parameter sind ein BST $T$, ein lower bound tree $Y$ und eine Zugriffsfolge $X$. $Y$ und $X$ müssen passend für $T$ erstellt sein, ansonsten ist $_X(T, Y, X) $ undefiniert . Die Auswertung erfolgt zu einer natürlichen Zahl. Sei $U$ die Menge internen Knoten von $Y$ und $m$ die Länge von $X$. Sei $u \in U$ und $l$ der kleinste Schlüssel eines Blattes im Teilbaum mit Wurzel $u$, sowie $r$ der größte Schlüssel eines solchen Blattes. Sei $v$ der tiefste gemeinsame Vorfahre der Knoten mit Schlüssel aus $\left[l, r\right]$  in $T$. Sei $o$ die Folge $o_0, o_1,..,o_m'$ mit $o_0 = \mathit{key}(v)$ und $o = \mathit{key}(v) \circ X^r_l$. $i \in \left[1,m\right]$ ist eine \textit{u-Transition} wenn gilt $\left( o_{i-1} < u \land o_i > u \right) \lor \left( o_{i-1} > u \land o_i < u \right)$.Die Funktion $\mathit{score}\left(u\right) \colon U \rightarrow \mathbb{N}$ ist definiert durch $\mathit{score}\left(u\right) = \vert\{i \in \mathbb{N}\ \textit{i ist eine u-Transition}\} \vert$. Mit Hilfe von $\mathit{score}$ kann nun  $_X(T, Y, X) $ definiert werden.

\begin{align*}
_X(T, Y, X)  = m + \sum_{u \in U} {\mathit{score}} \left(u\right)
\end{align*} %K^r_l = \{i \in K\vert l \leq i \leq r\}

\noindent Im eigentlichen Satz wird $\mathit{OPT}\left(X\right) \geq {_X(T, Y, X)} $ gezeigt werden. Dafür werden aber noch ein Lemma und einige Begriffe benötigt. Der \textbf{linke innere Pfad} $\left(v_0,v_1,..,v_n \right)$ eines Knotens $u$ ist der längst mögliche Pfad für den gilt, $v_0$ ist das linke Kind von $u$ und für $i \in \{1,..,n\}$,$v_i$ ist rechtes Kind von $v_{i-1}$. Der \textbf{rechte innere Pfad} $\left(v_0,v_1,..,v_n \right)$ eines Knotens $u$ ist der längst mögliche Pfad für den gilt, $v_0$ ist das rechte Kind von $u$ und $v_i$ ist linkes Kind von $v_{i-1}$. $T^r_l$ ist ein mit $\left[l,r\right]$ von $T$ abgeleiteter BST. Sei $v_r$ der tiefste gemeinsame Vorfahre der Knoten mit Schlüssel aus  $\left[l,r\right]$ in $T$. (Existiert ein solcher nicht ist $T^r_l$ der leere Baum). Es muss $\mathit{key}(v_r) \in \left[l,r\right]$ gelten. Denn hat $v_r$ keine Kinder ist sein Schlüssel der Einzige aus $\left[l,r\right]$. Hat $v_r$ ein Kind $v_{rc}$ und $\mathit{key}(v_r) \notin \left[l,r\right]$, dann wäre $v_{rc}$ ein tieferer gemeinsamer Vorgänger der entsprechenden Knoten. Hat $v_r$ zwei Kinder gibt es drei Fälle:
\begin{itemize}
	\item Die Schlüssel beider Kinder sind aus $\left[l,r\right]$. Dann muss aufgrund der Links-Rechts-Beziehung  $\mathit{key}(v_r)$ auch in $\left[l,r\right]$ enthalten sein.
	\item Der Schlüssel genau eines Kindes ist aus $\left[l,r\right]$. Sei $v_{rc}$ nun das linke bzw. rechte Kind zweier  Kinder von $v_r$, mit $\mathit{key}(v_{rc}) \notin \left[l,r\right]$.  Gilt zusätzlich $\mathit{key}(v_r) \notin K^r_l$, dann wäre des rechte bzw. linke Kind von $v_r$ ein tieferer gemeinsamer Vorgänger der entsprechenden Knoten.
	\item Die Schlüssel beider Kinder liegen außerhalb von $\left[l,r\right]$.  Dann muss $\mathit{key}(v_r)$ der Einzige in $T^r_l$ enthaltene Schlüssel sein.
\end{itemize}

\noindent Ein Knoten $u_r$ mit Schlüssel $\mathit{key}(v_r)$ bildet die Wurzel von $T^r_l$. Nun wird beschrieben wie Knoten zu $T^r_l$ hinzugefügt werden.
Dazu werden zwei Mengen verwendet. $U$ ist eine zu Beginn leere Menge, $W$ enthält zu Beginn $u_r$.
\begin{enumerate}
	\item Gilt $U = W$, beende das Verfahren.
	\item Sei $u \in W$ ein Knoten mit $u \notin U$.  Sei $v$ der Knoten in $T$ mit $\mathit{key}(u ) = \mathit{key}(v)$. Sei $P_l$ der linke innere Pfad von $v$ und $P_r$ der rechte innere Pfad von $v$.
	\item Ist $P_l$ der leere Pfad weiter mit $5$.
	\item Sei $k_l$ der Schlüssel des Knoten mit der kleinsten Tiefe in $P_l$, für den gilt $k \geq l$. Erzeuge einen Knoten $u_l$ mit Schlüssel $k_l$ und füge ihn als linkes Kind an $u$ an. Füge $u_l$ zu $W$ hinzu.
	\item Ist $P_r$ der leere Pfad weiter mit $7$.
	\item Sei $k_r$ der Schlüssel des Knoten mit der kleinsten Tiefe in $P_r$, für den gilt  $k \leq r$. Erzeuge einen Knoten $u_r$ mit Schlüssel $k_r$ und füge ihn als rechtes Kind an $u$ an. Füge $u_r$ zu $W$ hinzu.	
	\item Füge $u$ zu $U$ hinzu, weiter mit $1$
\end{enumerate}
Das Verfahren muss terminieren da die Anzahl der Knoten von $T$ endlich ist. So konstruiert muss $T^r_l$ ein BST sein. Ein Beispiel stellt Abbildung \ref{fig:T_r_l} dar. 
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/DynOpt/T_r_l"}
	\caption{Links ein BST $T$. Rechts ein davon abgeleiteter BST $T^8_4$ .  }
	\label{fig:T_r_l}
\end{figure}

 \noindent Sei $K_1$ die Schlüsselmenge von $T$ und $K_2$ die von $T^r_l$. Sei ${K^r_l = K \cap \{i \in \mathbb{N}\vert i \in \left[l,r\right] \}}$. Jetzt wird noch darauf eingegangen warum $K_2 = K^r_l$ gilt \\

 \noindent $K_2 \subseteqq  K^r_l$ ergibt sich direkt aus dem Verfahren zur Konstruktion von $T^r_l$.\\
 
 \noindent $ K^r_l \subseteqq K_2$:\\
 Sei $k \in K^r_l$ und $v_k$ der Knoten in $T$ mit $\mathit{key}(v_k) = k$. Es muss einen Pfad $P = v_0,..,v_n$ in $T$ geben, mit $v_0 = v_r$, $v_n = v_k$ und für $i \in \{1,..,n\}$ $v_i$ ist Kind von $v_{i-1}$. Sei $m$ die Anzahl der Knoten in $P$, mit einem Schlüssel in  $\left[l,r\right]$. Nun folgt Induktion über $m$.\\
  Für $m = 1$ gilt $k = k_r$  und $k \in K_2$. \\
  Induktionsschritt:\\
  Sei $w$ der Knoten mit der größten Tiefe in $ v_0,..,v_{n-1}$, mit $\mathit{key}(w) \in  K_2$. $w$ muss existieren da $m > 1$. Nach Induktionsvoraussetzung gibt es einen Knoten $u_k$ mit $\mathit{key}(u_k) = \mathit{key}(w)$ in $T^r_l$. Es sei $\mathit{key}(w) > \mathit{key}(v_k)$, der andere Fall ist symmetrisch. Ist $v_k$ das linke Kind von $w$, dann enthält das linke Kind von $u_k$ den Schlüssel $\mathit{key}(v_k)$. Anderenfalls gilt für alle $v_j$ mit $m < j < k$, $\mathit{key}(v_j) < l < \mathit{key}(v_k)$. Somit muss $v_{m+1}$ ein linkes Kind sein und die Knoten in $P$ mit größerer Tiefe als der von $v_{m+1}$ müssen rechte Kinder sein. Damit ist auch in diesem Fall ein Knoten $u_k$ mit $\mathit{key}(u_k) = \mathit{key}(w)$ linkes Kind von $u_m$.  \\
  
 \noindent Nun kommen wir zum Lemma:\\
 
 


	    
	 
 \noindent Sei $v$ ein Knoten in $T$, dann wird ein Knoten in $T^r_l$ mit Schlüssel $\mathit{key}(v)$  mit $v^*$ bezeichnet.  
\newtheorem{Lemma3}{Lemma}[section] \label{lemmaWilber1}
\begin{Lemma3} Es sei $T$ ein BST mit Knoten $u, v$ so, dass $u$ ein Kind von $v$ ist. $T'$ ist der BST, der durch ausführen der Rotation $\left(\mathit{key}\left(u\right),\mathit{key}\left(v\right)\right)$ aus $T$ entsteht. Gilt $\mathit{key}\left(u\right),\mathit{key}\left(v\right) \in \left[l,r\right]$, dann ist ${T'}^r_l$ der BST der aus $T^r_l$ durch Ausführen von  $\left(\mathit{key}\left(u\right),\mathit{key}\left(v\right)\right)$ entsteht. Anderenfalls gilt ${T'}^r_l = T^r_l$.
\end{Lemma3}
\begin{proof}
\noindent Für $u,v \notin \left[l,r\right]$ wird bei keinem inneren Pfad ein Knoten mit Schlüssel aus $\left[l,r\right]$ entfernt oder hinzugefügt.
Nun werden die vier Fälle betrachtet bei denen entweder $\mathit{key}\left(u\right)$ oder $\mathit{key}\left(c\right)$ in $\left[l,r\right]$ liegt.
\begin{enumerate}
	\item $u$ ist das linke Kind von $v$ und $\mathit{key}\left(u\right) < l$:\\
	 Sei $w$ ein Knoten aus $T^r_l$ und $w'$ einer aus $T'{^r_l}$, mit $\mathit{key}(w) = \mathit{key}(w')$ und $\mathit{key}(w) \in \left[l,r\right]$. Es muss gezeigt werden, dass wenn $w$ ein linkes bzw. rechtes Kind mit Schlüssel $k$ hat, dann gilt dies auch für $w'$. Da $\mathit{key}(u) < l \leq \mathit{key}(w) $ gilt, kann weder $u$ noch $v$ im rechten Teilbaum von $w$ liegen. Somit ist bezüglich der rechten Kinder nichts zu zeigen. 
	Sei $P_l$ der linke innere Pfad von $w$. Ist $v$ nicht in $P_l$ enthalten und gilt $v \neq w$ dann gilt $P_l = P'_l$. Sei $w = v$. Dann gilt $P_l = u  \circ  P'_l$ ,vergleiche Abbildung \ref{Kapitel 1 Rotationen}, und da $\mathit{key}(u) < l$ gilt, bleibt das linke Kind von $w$ unverändert. Nun sei $v$ in $P_l$ enthalten. Dann unterscheiden sich  $P_l$ und  $P'_l$ dadurch, dass ein Knoten mit $\mathit{key}(u)$ in $P'_l$ enthalten ist. Mit $u < l$ gilt aber, dass $w'$ und $w'$ bezüglich des Schlüssels ihres linken Kindes nicht unterscheiden.
	\item $u$ ist das rechte Kind von $v$ und $\mathit{key}\left(u\right) > r$:\\
	Links-Rechts-Symmetrisch zu Fall 1. 
	\item $v$ ist das linke Kind von $u$ und $\mathit{key}\left(u\right) < l$:\\
	    Von $T'$ aus Fall 1 erreicht man nach Ausführung der Rotation mit dieser Konstellation wieder $T$ aus Fall 1. Somit muss nichts weiter gezeigt werden.
	\item $v$ ist das linke Kind von $u$ und $\mathit{key}\left(u\right) > r$:\\
	Von $T'$ aus Fall 2 erreicht man nach Ausführung der Rotation mit dieser Konstellation wieder $T$ aus Fall 2. Somit muss nichts weiter gezeigt werden.\\
       	    
\end{enumerate}	
\noindent Übrig bleibt noch die Konstellation $\mathit{key}\left(u\right),\mathit{key}(v) \in \left[l,r\right]$. 
Betrachtet wird eine Rechtsrotation $\left(\mathit{key}\left(u\right),\mathit{key}\left(v\right)\right)$, die Linksrotation ist wieder symmetrisch. 
Es werden die Rotationen $\left(u,v \right)$ und $\left(u^*,v^* \right)$ ausgeführt.
Zu zeigen ist ${T'}^r_l = T{^r_l}' $.\\
In $T$ verändern sich maximal drei innere Pfade.
\begin{enumerate}
	\item Sei $u_r$ das rechte Kind von $u$. Sei $u,u_r,v_1,..,v_n$ der linke innere Pfad von $v$, dann ist $u'_r,v'_1,..,v_n$ der linke innere Pfad von $v'$. Es gilt ${\mathit{key}(u), \mathit{key}(u_r) \in \left[l,r\right] }$. Damit ist $u^*$ das linke Kind von $v^*$ und ${u_r}'^*$ das linke Kind von $v'^*$.
	\item Sei $v_1,..,v_n$ der rechte innere Pfad von $u$, dann ist $v',v_1',..,v_n'$ der rechte innere Pfad von $u'$, damit ist $v'$ rechtes Kind von $u'$. Damit ist $v'^*$ das rechte Kind von $u'*$.
	\item Ist $v$ das linke bzw. rechte Kind eines Knoten $z$ mit $\mathit{key}(z) \in \left[r,l\right]$, dann sei  $v,v_1,..,v_n$ der linke bzw. rechte innere Pfad von $z$. Dann ist  $u',v',v'_1,..,v'_n$ der linke bzw. rechte innere Pfad von $z'$. Dann ist  $v^*$ das linke bzw. rechte Kind von $z^*$ und $u'^*$ das linke bzw. rechte Kind von $z'^*$.
\end{enumerate}
 \noindent Nun wird auf ${T'}^r_l$ die Rotation $(u^*,v^*)$ ausgeführt. $u{^*}'$ ist linkes Kind von $v{^*}'$. $v{^*}'$ das rechte Kind von $u{^*}'$. Ist $v^*$ das linke bzw. rechte Kind eines Knoten $z^*$ mit  $\mathit{key}(z^*) \in \left[r,l\right]$, dann ist $v{^*}'$ das linke bzw. rechte Kind von $z{^*}'$ und $u{^*}'$ das linke bzw. rechte Kind von $z{^*}'$. Damit gilt ${T'}^r_l = T{^r_l}'$.\\
 	
\end{proof}
    
\newtheorem{Satz1}{Satz}[section] \label{satzWilber1}
\begin{Satz1} Es sei $T$ ein standard offline BST access algorithm mit Schlüsselmenge ${K = \{  i \in \mathbb{N} \vert i \in \left[j,k\right] \textit{ mit } j,k \in  \mathbb{N} \}} $. Sei $Y$ ein für $T$ erstellter lower bound tree und $X$ eine zu $T$ erstellte Zugriffsfolge mit Länge $m$. Dann gilt  $W\left(X, T\right) \geq {_X(T_0, Y, X)} $.  
\end{Satz1}
\begin{proof}
Sei $U$ die Menge der internen Knoten von $Y$. Die Kosten zum Ausführen sind die \textit{Anzahl der Einzelschritte} $ + {m}$. Es reicht also aus zu zeigen, dass mehr als $\sum_{u \in U} {_x} (u)$ Rotationen benötigt werden. Es wird Induktion über  $n = \vert K \vert$ angewendet. Sei $n = 1$, dann gibt es keinen internen Knoten in $Y$ und $\sum_{u \in U} {_x} (u) = 0$. Der Induktionsanfang ist somit gemacht. Im folgenden sei $n \geq 2$.\\
Sei $R = r_1,r_2,..,r_r$ die Folge der insgesamt durchgeführten Rotationen. Für $i \in \{1,..,r\}$ sei $T_i$ der BST, der entsteht nachdem $r_i$ auf $T_{i-1}$ ausgeführt wurde. Sei $w$ die Wurzel, mit Schlüssel $k_w$, von $Y$. Sei $Y^1$ bzw. $Y^2$ der linke bzw. rechte Teilbaum von $w$. Es ist zu beachten, dass $Y^1$ ein lower bound tree zu $T_{1}^{k_w}$ ist und  $Y^2$ einer zu $T^\infty_{k_w}$. $T_{i1}^{k_w}$ wird im folgenden als $T^1_i$ bezeichnet und $T_{ik_w}^{\infty}$ als $T^2_i$. Da $n \geq 2$ muss $w$ ein interner Knoten sein. Sei  $R^1 = r^1_1,r^1_2,..,r^1_{r^1} = R^{k_w}_1$ und $R^2 = r^2_1,r^2_2,..,r^2_{r^2} = R^\infty_{k_w}$. Mit $M$ wird die Folge bezeichnet, die entsteht, wenn aus $R$ alle Rotationen entfernt werden, die in $R^1$ oder $R^2$ enthalten sind. Sei $r_M$ die Länge von $M$. Es muss $r = r^1 + r^2 + r_M$ gelten, da keine Rotation sowohl in $R^1$ als auch in $R^2$ enthalten sein kann. $X_1$ ist die Folge die entsteht wenn aus $X$ alle Schlüssel $k > w$ entfernt werden. $X_2$ entsteht durch entfernen aller Schlüssel $k < w$ aus $X$. Für $j \in \{1,2\}$, sei $U^j$ die Menge der internen Knoten von $Y^j$. Sei $T^{j*}_0,T^{j*}_1,..,T^{j*}_{r_j}$ die entstehende Folge, wenn aus $T^{j}_0,T^{j}_1,..,T^{j}_{r}$ die $T^j_t$ entfernt werden für die $T^j_{t-1} = T^j_t$ gilt. Mit Lemma \ref{lemmaWilber1} kann  $T^{j*}_{t-1}$ durch Ausführung der Rotation $r^j_t$ auf $T^{j*}_{t-1}$ abgeleitet werden. Außerdem gilt durch dieses Lemma, dass wenn ein Knoten mit Schlüssel $k < w$ bzw. $k > w$ die Wurzel von $T_t$ ist dann muss die Wurzel von $T^1_t$ bzw. $T^2_t$ auch Schlüssel $k$ haben. $R^j$ bringt also der Reihe nach, die Knoten mit den Schlüsseln aus $X^j$ an die Wurzel von $T^j$ und  $X^j$ kann als Zugriffsfolge für $T^j$ aufgefasst werden. Da die Knotenzahl in $T^j$ kleiner $n$ sein muss gilt mit der Induktionsvoraussetzung  $r_j \geq \sum_{u \in U^j} {_x} (u)$.\\
Sei $\sigma = \mathit{key}(w) \circ X$. Sei $a$ eine $w$-Transition. Nun wird angenommen dass $\sigma_{a-1} < \mathit{key}(w)  \land \sigma_{a} > \mathit{key}(w)$. Der andere Fall kann davon problemlos abgeleitet werden. Sei $y$ der Knoten in $T$ mit $\mathit{key}(y) = \sigma_{w-1}$ und $z$ der Knoten in $T$ mit $\mathit{key}(z) = \sigma_{w}$. Nach \textit{access($\sigma_{a-1}$)} ist $y$ die Wurzel von $T$. $z$ muss sich im rechten Teilbaum von $y$ befinden. Nach  \textit{access($\sigma_{a}$)} ist $z$ die Wurzel von $T$. $y$ muss sich im linken Teilbaum von $z$ befinden. Somit muss während \textit{access($\sigma_{a}$)} die Rotation $(\mathit{key}(z),\mathit{key}(y))$ ausgeführt worden sein. $(\mathit{key}(z),\mathit{key}(y))$ muss in $M$ enthalten sein. Für jede $w$-Transition ist also mindestens eine Rotation in $M$ enthalten, also $r_M \geq  \mathit{score} \left(w\right)$.\\
Zusammengefasst ergibt sich:

\begin{align*}
r = r^1 + r^2 + r_M \geq \sum_{u \in U^1} {_x} (u) + \sum_{u \in U^2} {_x} (u) +  {_x} (w)
\end{align*}



	
\end{proof}

\noindent Da $T$ beliebig gewählt ist folgt direkt $\mathit{OPT}\left(X\right) \geq {_X(T_0, Y, X)} $.  
In diesem Abschnitt wurden BST access algorithm verwendet. Das Ergebnis lässt sich aber natürlich direkt auf BST mit einer entsprechenden \textit{access} Operation übertragen. Während einer Operationsfolge die ausschließlich aus \textit{access} Operationen besteht, ist auch bei diesen die Schlüsselmenge konstant. Deshalb wird ab nun wieder nur von BST gesprochen.  

\subsection{bit reversal permutation } \label{abschnittBitReversal}
In diesem Abschnitt wird gezeigt, dass es Zugriffsfolgen mit Länge $m$ für BST $T$ gibt, so dass für die Laufzeit eines BST $\Theta\left(m \log n\right)$ gilt, mit $n$ ist die Anzahl der Knoten von $T$. Hier werden speziell die Zugriffsfolgen betrachtet, die als \textbf{bit reversal permutation} bezeichnet werden. Auf $O\left(m \log n\right)$ wird hier nicht weiter eingegangen. Die balancierten BST garantieren jedoch diese Schranke und mit dem Rot-Schwarz-Baum wird später ein solcher noch vorgestellt.
 $\Omega\left(m \log n\right)$  wird mit Hilfe der ersten unteren Schranke von Wilber gezeigt und ein Beweis ist ebenfalls in \cite{wilberLowerBounds} enthalten. \\
  Nun wird zunächst der Aufbau einer solchen Zugriffsfolge eingegangen. Sei $l \in \mathbb{N}$ und $i \in \{0,1,..,l-1\}$. Eine Folge  $b_{l-1},b_{l-2},..,b_0$ mit $b_i \in \{0,1\}$, kann als Zahl zur Basis $2$ interpretiert werden. $T$ enthält alle Schlüssel die als solche Folge dargestellt werden können. Die Schlüsselmenge von $T$ ist deshalb $K_l = \{0,1,..,2^l -1\}$. 
  Die Funktion $\mathit{br}_l(k)\colon K \rightarrow K$ ist wie folgt definiert. Sei {$b_{l-1},b_{l-2},..,b_{0}$} die Binärdarstellung von $k$, dann gilt 
\begin{align*}
\mathit{br}_l(k) = \sum_{i = 0}^{l-1} b_{\left(l-1-i\right)} \cdot 2^i
\end{align*}
 $\mathit{br}_l(k)$ gibt also gerade den Wert der \enquote{umgekehrten} Binärdarstellung von $k$ zurück. Die bit reversal permutation zu $l$ ist die Zugriffsfolge\\ ${\mathit{br}_l(0),\mathit{br}_l(1),..,\mathit{br}_l(2^l-1)}$. Diese wird ab jetzt mit $X$ bezeichnet. Tabelle \ref{tab:bitReversal} zeigt die bit reveral Permutation mit $l  = 4$. Sei $y$ die Hälfte von $\max\left(K_l\right)$, also $y = 2^{l-1} - 0,5$. Da $b_0$ in den Binärdarstellungen zu $0, 1, 2^l-1$ alterniert, alterniert $b_{l-1}$ in $X$. Mit $2^{l-1} > y$ ergeben sich die Implikationen $\mathit{br}_l(k) < y \Rightarrow \mathit{br}_l(k +1) > y$ und $\mathit{br}_l(k) > y \Rightarrow \mathit{br}_l(k +1) < y$. Da $\vert K_l \vert = 2^l$ kann zu $T$ ein vollständig balancierter lower bound tree $Y$ erstellt werden. Sei $w$ die Wurzel von $Y$. Da im linken Teilbaum von $w$ genau so viele Blätter wie im rechten vorhanden sein müssen, kann nur $y$ der Schlüssel von $w$ sein. Zu einer Zugriffsfolge $X = x_0,x_1,..,x_m$ bezeichnet $X^r_l$ die Zugriffsfolge, die entsteht wenn aus $X$ alle Schlüssel $k$, mit $k < l \lor k > r$ entfernt werden. $X + i$ mit $i \in \mathbb{N}$ bezeichnet im Folgenden die Folge $x_0 + i, x_1 + i,.., x_m + i$.\\
 
  \begin{table}
 \begin{center}
 \begin{tabular}[c]{|l|l|l|l|}
 	\hline
 	$i$ & $\mathit{bin}\left(i\right)$ &$\mathit{bin}\left(\mathit{br}\left(i\right)\right)$  &$x_i$\\
 	\hline
 	$0$ & $0000$ &$0000$  &$0$\\
 	\hline
 	$1$ & $0001$ &$1000$  &$8$\\
 	\hline
 	$2$ & $0010$ &$0100$  &$4$\\
 	\hline
 	$3$ & $0011$ &$1100$  &$12$\\
 	\hline
 	$4$ & $0100$ &$0010$  &$2$\\
    \hline
 	$5$ & $0101$ &$1010$  &$10$\\
 	\hline
 	$6$ & $0110$ &$0110$  &$6$\\
 	\hline
 	$7$ & $0111$ &$1110$  &$14$\\
    \hline
 	$8$ & $1000$ &$0001$  &$1$\\
 	\hline
 	$9$ & $1001$ &$1001$  &$9$\\
 	\hline
 	$10$& $1010$ &$0101$  &$5$\\
 	\hline
 	$11$& $1011$ &$1101$  &$13$\\
 	\hline
 	$12$ &$1100$ &$0011$  &$3$\\
 	\hline
 	$13$ &$1101$ &$1011$  &$11$\\
 	\hline
 	$14$ &$1110$ &$0111$  &$7$\\
 	\hline
 	$15$ &$1111$ &$1111$  &$15$\\
 	\hline
 \end{tabular}
  	\caption{bit reveral permutation für $l=4$} 
  	\label{tab:bitReversal}
\end{center}
   \end{table}



\newtheorem{Korollar1}{Korollar}[section]
\begin{Korollar1} Sei $l \in \mathbb{N}$. Sei $T$ ein BST mit Schlüsselmenge\\ ${K_l = \{0,1,..,2^l -1\}}$ und $n = 2^l$. Sei $X = x_0, x_1,..,x_{n-1}$ die bit reversal permutation zu $l$ und $Y$ der vollständig balancierte lower bound tree zu $T$. Dann gilt  $W\left(X,T\right) \geq n \log_2 n + 1 $. 
\end{Korollar1}
\begin{proof}
Sei $U$ die Menge der internen Knoten von $Y$. Mit Satz \ref{satzWilber1} reicht es aus 

\begin{align*}
\sum_{u \in U} {\mathit{score}\left(u\right)} \geq n \log_2 n + 1 - n 
\end{align*} 
zu zeigen. Dies geschieht mit Induktion über $l$. Für $l = 0$ besteht $Y$ aus einem einzigen Blatt. Damit gilt $ W\left(X,T\right) = 0 = n \log_2 n + 1 $. \\
Nun sei $l > 0$. Sei $w$ die Wurzel von $Y$, mit $k_w = \mathit{key}(w)$. Sei $T_0^{k_w}$ ein BST mit Schlüsselmenge $K_0^{k_w} =\{k \in \mathbb{N}\vert k \leq k_w\} = \{k \in \mathbb{N}\vert k \leq 2^{l-1} - 1\}$ und $T_{k_w}^\infty$ ein BST mit Schlüsselmenge  $ K^\infty_{k_w} = \{k \in \mathbb{N}\vert \exists n \in K_0^{k_w}\colon  k = n + 2^{l-1}\}$. Sei $Y^1$ bzw. $Y^2$ der linke bzw. rechte Teilbaum von $w$ und $U^1$ bzw. $U^2$ die Menge der internen Knoten von $Y^1$ bzw. $Y^2$. $Y^1$ und $Y^2$ sind vollständig balancierte lower bound trees zu $T_0^{k_w}$ und $T_{k_w}^\infty$. $X^{k_w}_0$ ist die bit reversal permutation für $T_0^{k_w}$. Außerdem gilt $X_{k_w}^\infty = X^{k_w}_0 + 2^{l-1}$. Mit der Induktionsvoraussetzung gilt deshalb, für $i \in \{1,2\}$,
\begin{align*}
\sum_{u \in U^i} {\mathit{score}\left(u\right)} \geq  \frac{n}{2} \log_2 \left(\frac{n}{2} \right) + 1 - \frac{n}{2}  
\end{align*}
Aus $\left(x_j < k_w \Rightarrow x_{j-1} > k_w \right) \land \left(x_j > k_w \Rightarrow x_{j-1} < k_w \right)$ folgt $\mathit{score}\left(w\right) \geq n-1$. Zusammenfassen ergibt
\begin{align*}
\sum_{u \in U} {\mathit{score}\left(u\right)} &\geq 2 \left( \frac{n}{2}  \log_2 \left(\frac{n}{2} \right) + 1 - \frac{n}{2} \right) + n - 1\\	
&= n (l-1) + n + 1 \\
&= n l + 1 \\	
&> n l + 1 -n \\
&= n \log_2 n + 1 - n\\	
\end{align*}
		
\end{proof}

\noindent Die Schlüsselmenge  wurde beim Korollar auf ${K_l = \{0,1,..,2^l -1\}}$ festgelegt. Vielleicht wäre es aber mit einer anderen Schlüsselmenge $K$ möglich $X$ schneller auszuführen ? In jedem Fall müsste $K_l \subseteqq K$ gelten. Sei $R$ die Folge von Rotationen, die beim Ausführen von $X$ bei einem BST $T$ mit Schlüsselmenge $K$ entsteht. Sei $y = 2^l -1$ Mit Lemma \ref{lemmaWilber1} ist dann $R_0^y$ eine Folge von Rotationen zum ausführen von $X$ auf $T_0^y$ und die Länge von $R$ kann nicht kleiner als die von $R_0^y$ sein. Damit ist $\mathit{OPT}\left(X\right) = \Omega\left(m \log n \right)$. 



\subsection{Amortisierte Laufzeitanalyse}
Im nächsten Anschnitt werden die Kosten von amortisierten Laufzeitanalysen verwendet. Deshalb wird diese hier nun vorgestellt.
Sei $i \in \{0,..,m\}$. Bei der \textbf{amortisierten Laufzeitanalyse} wird eine Folge von $m$ Operationen betrachtet. Hierbei kann es sich $m$ mal um die gleiche Operation handeln, oder auch um verschiedene. Die \textbf{tatsächlichen Kosten}  $t_i$ stehen für die (gewöhnlich bestimmten) Kosten zum ausführen der $i$-ten Operation. Durch aufaddieren der tatsächlichen Kosten jeder einzelnen Operation erhält man \textbf{tatsächlichen Gesamtkosten}.  Stehen für die Laufzeit der Operationen jeweils nur obere Schraken zur Verfügung, kann man mit diesen genau so vorgehen, um eine obere Schranke für die Gesamtlaufzeit zu erhalten. So erzeugte obere Schranken können jedoch unnötig hoch sein. Die Idee bei einer amortisierten Analyse ist es, eingesparte Zeit durch schnell ausgeführte Operationen, den langsameren Operationen zur Verfügung zu stellen. Dabei wird insbesondere der aktuelle Zustand der zugrunde liegenden Datenstruktur vor und nach einer Operation betrachtet. Es gibt drei Methoden zur amortisierten Analyse, bei BST wird in der Regel die \textbf{Potentialfunktionmethode} verwendet.
\paragraph{Potentialfunktionmethode} Eine Potentialfunktion $\Phi(D)$ ordnet einem Zustand einer Datenstruktur $D$ eine natürliche Zahl, \textbf{Potential} genannt, zu. Es bezeichnet $\Phi(D_i)$ das Potential von $D$ nach Ausführung der $i$-ten Operation. Die \textbf{amortisierten Kosten} $a_i$ einer Operation berücksichtigen die von der Operation verursachte Veränderung am Potential, $a_i = t_i + \Phi(D_{i}) - \Phi(D_{i-1})$. Um die \textbf{amortisierten Gesamtkosten} $A$ zu berechnen bildet man die Summe der amortisierten Kosten aller Operationen. 
\begin{align*}
A = \sum_{i = 1}^{m} a_i =  \sum_{i = 1}^{m} \left(t_i + \Phi\left(D_{i}\right) - \Phi\left(D_{i-1}\right)\right) = \Phi\left(D_{m}\right) - \Phi\left(D_{0}\right) + \sum_{i = 1}^{m} t_i 
\end{align*}
Folgendes gilt für die Summe der $t_i$:
\begin{align*}
&\sum_{i = 1}^{m} t_i =  \sum_{i = 1}^{m} \left(a_i - \Phi\left(D_{i}\right) + \Phi\left(D_{i-1}\right)\right) = \Phi\left(D_{0}\right) - \Phi\left(D_{m}\right) + \sum_{i = 1}^{m} a_i \\
\Rightarrow &\left( \Phi\left(D_{m}\right) \geq \Phi\left(D_{0}\right) \Rightarrow \sum_{i = 1}^{m} a_i \geq \sum_{i = 1}^{m} t_i \right)
\end{align*}
Ist das Potenzial nach Ausführung der Operationsfolge also nicht kleiner als zu Beginn, dann sind die amortisierten Gesamtkosten eine obere Schranke für die tatsächlichen Gesamtkosten. Die wesentliche Aufgabe ist es nun eine Potentialfunktion zu finden, bei der die amortisierten Gesamtkosten möglichst niedrig sind und für die gilt $\Phi\left(D_{m}\right) \geq \Phi\left(D_{0}\right)$. Dies wird jetzt noch an einem einfachen Beispiel demonstriert.

\paragraph{Potentialfunktionmethode am Beispiel eines Stack} 
Der Stack verfügt wie gewöhnlich über eine Operation \textit{push} zum Ablegen eines Elementes auf dem Stack und über \textit{pop} zum Entfernen des oben liegenden Elementes. Zusätzlich gibt es eine Operation \textit{popAll}, die so oft \textit{pop} aufruft, bis der Stack leer ist. Sei $n$ die Anzahl der Elemente die maximal im Stack enthalten sein kann. \textit{push} und \textit{pop} können in konstanter Zeit durchgeführt werden und wir berechnen jeweils eine Kosteneinheit. Für die Laufzeit von \textit{popAll} gilt $O(n)$, da \textit{pop} bis zu $n$ mal aufgerufen wird. Für die Gesamtlaufzeit einer Folge von $m$ Operationen kann sicher $O(mn)$ angegeben werden. Mit einer amortisierten Analyse wird nun aber $O(m)$ für \textit{popAll} gezeigt. Als $\Phi$ verwenden wir eine Funktion, welche die aktuelle Anzahl der im Stack enthaltenen Elemente zurück gibt. $\Phi_0$ setzen wir auf $0$, dass heißt wir starten mit einem leeren Stack. \textit{push} erhöht also das Potential um eins, während \textit{pop} es um eins vermindert. Nun werden die amortisierten Kosten bestimmt. 

\begin{align*}   
&a_{\mathit{push}} = t_{\mathit{push}} + \Phi{i} - \Phi{i-1}  &= 2\\
&a_{\mathit{pop}} = t_{\mathit{pop}} + \Phi{i} - \Phi{i-1}  &= 0\\
&a_{\mathit{popAll}} = n \cdot a_{\mathit{pop}} &= 0
\end{align*}\\
Alle drei Operationen haben konstante amortisierte Kosten. Auf jedem Fall gilt $ \Phi_m \geq  \Phi_0 = 0 $ Damit gilt für die Ausführungszeit der Folge $O(m)$. \\
Bei diesem einfachen Beispiel ist sofort klar warum es funktioniert. Aus einem zu Beginn leerem Stack kann nur entfernt werden, was zuvor eingefügt wurde. \textit{push} zahlt für die Operation, welche das eingefügte Element eventuell wieder entfernt gleich mit, bleibt bei den Kosten aber konstant. Deshalb kann \textit{pop} amortisiert kostenlos durchgeführt werden, wodurch einer der beiden Faktoren zur Berechnung der Kosten von \textit{popAll} zu $0$ wird. 


 
\subsection{Obere Schranken für Zugriffssequenzen }
In Abschnitt \ref{abschnittBitReversal} wurde gezeigt, dass für die Ausführung einer beliebigen Zugriffsfolge $X$, mit Länge $m$, für einen BST $T$ mit $n$ Knoten im worst case Kosten von  $\Omega\left(m \log n\right)$ angenommen werden müssen. Im folgendem werden einige obere Laufzeitschranken für Zugriffssequenzen vorgestellt. Es ist bekannt, dass es obere Schranken sind, da mit dem Splaybaum ein BST bekannt ist der jede Schranke einhält. Der Splaybaum wird später noch vorgestellt. Es wird wieder ohne Verlust der Allgemeinheit eine Schlüsselmenge $K = \{1,2,..,n\}$ angenommen. Wenn nicht anders angegeben wird  $X = x_1,x_2,..,x_m$ als Zugriffssequenz verwendet. Es wird $m \geq n$ und  $m \geq n \log_2 n$ angenommen.


\paragraph{Balanced Property}
Ein BST erfüllt das balanced property, wenn er $X$ in amortisiert $O(m \log n)$ Zeit ausführt. 
\paragraph{Static Finger Property}
Die Idee hinter dieser Eigenschaft ist, dass es einfacher ist, Zugriffssequenzen schnell auszuführen, wenn ihre Schlüssel betragsmäßig nahe beieinander liegen. 
Sei $k_f \in K$. Ein BST erfüllt static finger wenn für die amortisierte Laufzeit von $X$ 
\begin{align*}
O\left( \sum_{i = 1}^{m} \log \vert k_f - x_i  \vert	+ 1	\right)
\end{align*}
gilt.  


\paragraph{Statisch optimal}
Sei $k \in K$ und $q(k)$ die Anzahl des Vorkommens von $k$ in  $X$. Ein BST ist statisch optimal wenn er Zugriffssequenzen, in denen jeder seiner Schlüssel zumindest einmal enthalten ist, in amortisiert 
\begin{align*}
O\left(\sum_{k = 1}^{n}q(k)\log \left( \frac{m}{q(k)} \right)\right) 
\end{align*}
Zeit ausführt. Der Name kommt daher, dass es sich hierbei um eine untere Schranke für die Ausführungszeit von X bei statischen BST handelt, siehe \cite{staticOptimal}.

\paragraph{Working Set Property}
Für $x_i$ sei $J_i = \{j \in \mathbb{N} \vert j < i \land x_j = x_i \}$ 
Sei $t_{xi} = \max \left(J\right)$, falls $J$ nicht leer ist, ansonsten $t_{xi} = 0$. $t_{xi}$ liefert also den Index des vorherigen Zugriffes auf $x_i$, falls ein solcher existiert. Sei ${w_i = \vert\{x_j \vert t_{xi} < j \leq i   \} \vert }$.
Ein BST erfüllt das working set propery wenn seine amortisierte Laufzeit für $X$
\begin{align*}
O\left(\sum_{i = 1}^{m} \log w_i \right)
\end{align*} 



\paragraph{Unified Property}
Das Unified Property kombiniert die oberen Eigenschaften zu einer. Die Bezeichner werden deshalb übernommen.
Ein BST erfüllt das Unified Property, wenn für die  wenn für die amortisierte Laufzeit von $X$: 
\begin{align*}
O\left(     \sum_{i = 1}^{m} \log \min\{ \frac{m}{q\left(x_i\right)}, \vert k_f - x_i  \vert + 1 ,w_i  \}	 		\right)
\end{align*} 
gilt. Dass das Balanced Property enthalten ist, sieht man dem Ausdruck nicht direkt an, es gilt jedoch $\vert k_f - x_i  \vert + 1 \leq n$.




\paragraph{Dynamic Finger Property}
Diese Eigenschaft ist static finger sehr ähnlich, man kann jedoch durch das Unified Property nicht direkt auf dynamic finger schließen. 
Ein BST erfüllt das Dynamic Finger Property, wenn für die amortisierte Laufzeit von $X$
\begin{align*}
O\left( \sum_{i = 2}^{m} \log \vert x_{i-1} - x_i  \vert	+ 1	\right)
\end{align*} 
gilt.\\


\newpage
\bibliography{literaturverzeichnis}
\bibliographystyle{unsrt}

\end {document}


