\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[ngerman,german]{babel}
\usepackage[T1]{fontenc}
\usepackage{courier}
\usepackage{float}
\usepackage{amsmath,amsthm}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{csquotes}
\usepackage[font=small,labelfont=bf]{caption}

%\usepackage[pages=some]{background} % Draft Wasserzeichen mit Option pages=all sonst pages=some



\title{Bachelorarbeit}
\author{
Andreas Windorfer\\
}
\date{\today}


\begin {document}


\maketitle
\newpage

\tableofcontents
\newpage

\section{Dynamische Optimalität}

\subsection{BST Zugriffsalgorithmus }
Sei $T$ ein BST mit der Schlüsselmenge $K$. Eine Operation, welche die gleiche Rückgabe wie \textit{search} liefert, bei der aber nur $k \in K $ als Parameter erlaubt sind wird \textit{access} genannt. In diesem Kapitel werden Folgen solcher \textit{access} Operationen betrachtet. Notiert wird eine solche Zugriffsfolge durch Angabe der Parameter. Bei der Zugriffsfolge $x_1,x_2,...x_m$ wird also zunächst \textit{access($x_1$)} ausgeführt, dann \textit{access($x_2$)} usw.  Bei BST wird bezüglich Zugriffssequenzen zwischen online und offline Varianten unterschieden. Bei offline BST ist die Zugriffsfolge zu Beginn bereits bekannt, somit kann ein Startzustand gewählt werden, der die Kosten minimiert. Beim online BST ist die Zugriffsfolge zu Beginn nicht bekannt. Bei einer worst case Laufzeit-Analyse muss somit zum Start von dem Startzustand ausgegangen werden bei dem die Kosten am höchsten sind.
Einen BST der lediglich die \textit{access} Operation anbietet nennt man \textbf{BST access algorithm}, wenn seine Operation folgende Eigenschaften einhält. 

\begin{enumerate} 
	\item Der Algorithmus verfügt über genau einen Zeiger $p$ in den BST. Dieser wird zu Beginn so initialisiert, dass er auf die Wurzel zeigt. Terminiert der Algorithmus muss $p$ auf den Knoten mit Schlüssel $k$ zeigen.
	\item Der Algorithmus führt eine Folge dieser Einzelschritte durch:
	\begin{itemize}
		\item Setze $p$ auf das linke Kind von $p$.
		\item Setze $p$ auf das rechte Kind von $p$.
		\item Setze $p$ auf den Vater von $p$.
		\item Führe eine Rotation auf $p$ aus.
	\end{itemize}  
	\item  Zur Auswahl des nächsten Einzelschrittes können in den Knoten gespeicherte Hilfsdaten verwendet werden. Es kann nur auf die Hilfsdaten des Knotens zugegriffen werden (lesend oder schreibend), auf den $p$ zeigt.    
\end{enumerate}

 
 \noindent  Da \textit{access} die Schlüsselmenge nicht verändert ist diese bei BST access algorithm statisch und es wird $n = \vert K \vert$ gesetzt. Außerdem werden hier pro Knoten nur Hilfsdaten in konstanter Größenordnung zugelassen. Zu beachten ist, dass dies eine Abhängigkeit zu $n$ nicht ausschließt.
 
 \noindent Die Initialisierung sowie die Auswahl und Durchführung jedes Einzelschrittes aus Punkt 2 kann in konstanter Zeit durchgeführt werden. Es werden jeweils Einheitskosten von $1$ verwendet. Höhere angenommene Kosten würden die Gesamtkosten lediglich um einen konstanten Faktor erhöhen. Es sei $a$ die Anzahl der insgesamt durchgeführten Einzelschritte während einer Zugriffsfolge $X$ mit Länge $m$. Dann berechnen sich die Gesamtkosten $\mathit{cost(X)}$ der Zugriffsfolge mit $\mathit{cost(X)} = a + m$. Es muss zu jeder Schlüsselmenge und jeder Zugriffsfolge zumindest einen offline BST access algorithm geben, so dass die Kosten keines anderen niedriger sind. Diese Kosten werden als $\mathit{OPT}\left(X\right)$ bezeichnet.\\  In \cite{nRotations} wurde gezeigt, dass der Zustand eines BST mit maximal $2n -2$ Rotationen in jeden anderen gültigen BST Zustand mit der gleichen Schlüsselmenge überführt werden kann. Da bei der Berechnung der Kosten für  $\mathit{OPT(X)}$, $m$ ebenfalls als Summand vorkommt, können die zusätzlichen Kosten der online Varianten asymptotisch betrachtet vernachlässigt werden. \\
 \noindent Als \textbf{dynamisch optimal } wird ein BST bezeichnet wenn er eine beliebige Zugriffssequenz $X$ in $O\left(\mathit{OPT}\left(X\right)\right)$ Zeit ausführen kann. Ein BST der jede Zugriffssequenz in $O\left(c \cdot \mathit{OPT}\left(X\right)\right)$ Zeit ausführt, nennt man \textbf{c-competitive}. Es konnte bis heute für keinen BST bewiesen werden, dass er dynamisch optimal ist. Es wurden aber mehrere untere Schranken für $\mathit{OPT}\left(X\right)$ gefunden. Eine davon wird  nun vorgestellt.


\subsection{Erste untere Schranke von Wilber}
Robert Wilber hat in \cite{wilberLowerBounds} zwei Methoden zur Berechnung unterer Schranken für die Laufzeit von BST access algorithm vorgestellt. Hier wird auf die Erste davon eingegangen. Im folgenden werden offline BST access algorithm betrachtet, bei denen nach einer \textit{access($k$)} Operation, der Knoten $v$ mit Schlüssel $k$ die Wurzel des BST ist. Dies bezeichnet man als \textbf{standard offline BST access algorithm } Asymptotisch betrachtet entsteht hierdurch kein Verlust der Allgemeinheit. Sei $d$ die Tiefe von $p$ zum Zeitpunkt $t$ direkt vor der Terminierung von \textit{access}. Dann sind mindestens Kosten $d + 1$ entstanden. Mit $d$ Rotationen kann $p$ zur Wurzel gemacht werden und mit $d$ weiteren Rotationen kann der Zustand zum Zeitpunkt $t$ wieder hergestellt werden. In diesem Kapitel wird eine Funktion $\mathit{key}(v)$ verwendet, die zu einem Knoten $v$ den Schlüssel von $v$ liefert.\\
Für einen BST $T$ mit Schlüsselmenge $K_T$ und einer Zugriffsfolge $X$ notieren wir die minimalen Kosten eines wie eben vorgestellt arbeitenden BST access algorithm mit $W(X, T)$. Im folgenden wird angenommen, dass \\
$K = \{  i \in \mathbb{N} \vert i \in \left[j,k\right] \textit{ mit } j,k \in  \mathbb{N} \} $ gilt. Dadurch entsteht kein Verlust der Allgemeinheit, denn anderenfalls könnte man die Schlüsselmenge einfach aufsteigend sortiert mit $j$ startend durchnummerieren. Eine Rotation wird innerhalb dieses Kapitels mit $\left(i, j\right)$ notiert. $i$ ist dabei der Schlüssel des Knotens auf dem die Rotation ausgeführt wird, vergleiche Kapitel \ref{noch einsetzrn}. $j$ ist der Schlüssel des Vaters von $i$, vor Ausführung der Rotation. Für eine Folge von Rotationen $r = \left(i_1,j_1 \right),\left(i_2,j_2 \right),..,\left(i_n,j_n \right)$ erhält man die Folge  $r^y_x = \left(i_{1'},j_{1'}\right),\left(i_{2'},j_{2'} \right),..,\left(i_{m'},j_{m'} \right)$  in dem man aus $r$ jede Rotation entfernt bei der $i\notin \left[l,r\right] \lor j\notin \left[l,r\right]$ gilt. Ähnlich erhält man aus $X$ die Zugriffsfolge $X^y_x$ in dem man aus $X$ alle Schlüssel $k$ entfernt für die $k < x  \lor k > y$ gilt.

\paragraph{lower bound tree}
Ein lower bound tree $Y$ zu $T$ ist ein BST, der genau $2 \left(k - j \right) + 1$ Knoten enthält. Seine $\vert K \vert$ Blätter enthalten die Schlüssel aus $K$. Die $\left(k - j \right)$ internen Knoten enthalten die Schlüssel aus der Menge $\{r \in R \vert \exists i,j \in K \left( i + 1 = j \land r = i + 0,5\right)\}$. $Y$ kann immer erstellt werden indem zunächst ein BST $Y_i$ mit den internen Knoten von $Y$ erzeugt wird. Die Blätter werden dann an der Position angefügt an der die Standardvariante von \textit{einfügen} angewendet auf $Y_i$ ihren Schlüssel einfügen würde. Dass hierbei für zwei Blätter mit Schlüssel $k_1, k_2$ die gleiche Position gewählt wird ist ausgeschlossen, da es einen internen Knoten mit Schlüssel $k_i$ so geben muss dass $k_1 < k_i < k_2 \lor k_1 > k_i > k_2 $ gilt. An der Konstruktionsanleitung erkennt man, dass zu den meisten BST mehrere mögliche lower bound trees existieren. Abbildung \ref{fig:lowerBoundTree} zeigt eine beispielhafte Konstellation. \\


        
\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{"Medien/DynOpt/lowerBoundTree"}
	\caption{Rechts ist ein möglicher lower bound tree zum linken BST dargestellt.  }
	\label{fig:lowerBoundTree}
\end{figure}

\noindent Nun wird die Funkion $_X(T, Y, X) $ definiert. Ihre Parameter sind ein BST $T$, ein lower bound tree $Y$ und eine Zugriffsfolge $X$. $Y$ und $X$ müssen passend für $T$ erstellt sein, ansonsten ist $_X(T, Y, X) $ undefiniert . Die Auswertung erfolgt zu einer natürlichen Zahl. Sei $U$ die Menge der Schlüssel der internen Knoten von $Y$ und $m$ die Länge von $X$. Sei $u \in U$ und $l$ der kleinste Schlüssel eines Blattes im Teilbaum mit Wurzel $u$, sowie $r$ der größte Schlüssel eines solchen Blattes. Sei $v$ der tiefste gemeinsame Vorfahre der Knoten mit Schlüssel aus $\left[l, r\right]$  in $T$. Sei $o$ die Folge $o_0, o_1,..,o_m'$ mit $o_0 = v$ und $o = v \circ X^r_l$. $i \in \left[1,m\right]$ ist eine \textit{u-Transition} wenn gilt $\left( o_{i-1} < u \land o_i > u \right) \lor \left( o_{i-1} > u \land o_i < u \right)$.Die Funktion $_x (u) \colon U \rightarrow \mathbb{N}$ ist definiert durch $_x(u) = \vert\{i \in \mathbb{N}\ \textit{i ist eine u-Transition}\} \vert$.

\begin{align*}
_X(T, Y, X)  = m + \sum_{u \in U} {_x} (u)
\end{align*} %K^r_l = \{i \in K\vert l \leq i \leq r\}

\noindent Im eigentlichen Satz wird $\mathit{OPT}\left(X\right) \geq {_X(T, Y, X)} $ gezeigt werden. Dafür werden aber noch ein Lemma und einige Begriffe benötigt. Der \textbf{linke innere Pfad} $\left(v_0,v_1,..,v_n \right)$ eines Knotens $u$ ist der längst mögliche Pfad für den gilt, $v_0$ ist das linke Kind von $u$ und für $i \in \{1,..,n\}$,$v_i$ ist rechtes Kind von $v_{i-1}$. Der \textbf{rechte innere Pfad} $\left(v_0,v_1,..,v_n \right)$ eines Knotens $u$ ist der längst mögliche Pfad für den gilt, $v_0$ ist das rechte Kind von $u$ und $v_i$ ist linkes Kind von $v_{i-1}$. $T^r_l$ ist ein mit $\left[l,r\right]$ aus $T$ abgeleiteter BST. Sei $v_r$ der tiefste gemeinsame Vorfahre der Knoten mit Schlüssel aus  $\left[l,r\right]$ in $T$. Es muss $\mathit{key}(v_r) \in \left[l,r\right]$ gelten. Denn hat $v_r$ keine Kinder ist sein Schlüssel der Einzige aus $\left[l,r\right]$. Hat $v_r$ ein Kind $v_{rc}$ und $\mathit{key}(v_r) \notin \left[l,r\right]$, dann wäre $v_{rc}$ ein tieferer gemeinsamer Vorgänger der entsprechenden Knoten. Hat $v_r$ zwei Kinder mit Schlüsseln aus $\left[l,r\right]$ dann muss aufgrund der Links-Rechts-Beziehung  $\mathit{key}(v_r)$ auch in $\left[l,r\right]$ enthalten sein. Sei $v_{rc}$ nun das linke bzw. rechte Kind zweier  Kinder von $v_r$, mit $\mathit{key}(v_{rc}) \notin \left[l,r\right]$. Gilt zusätzlich $\mathit{key}(v_r) \notin K^r_l$, dann wäre des rechte bzw. linke Kind von $v_r$ ein tieferer gemeinsamer Vorgänger der entsprechenden Knoten. Ein Knoten $u_r$ mit Schlüssel $\mathit{key}(v_r)$ ist die Wurzel von $T^r_l$. Nun wird beschrieben wie Knoten zu $T^r_l$ hinzugefügt werden.
Dazu werden zwei Mengen verwendet $U$ ist eine zu Beginn leere Menge, $W$ enthält zu Beginn $u_r$.
\begin{enumerate}
	\item Gilt $U = W$, beende das Verfahren.
	\item Sei $u \in W$ ein Knoten mit $u \notin U$.  Sei $v$ der Knoten in $T$ mit $\mathit{key}(u ) = \mathit{key}(v)$. Sei $P_l$ der linke innere Pfad von $v$ und $P_r$ der rechte innere Pfad von $v$.
	\item Ist $P_l$ der leere Pfad weiter mit $5$.
	\item Sei $k_l$ der Schlüssel des Knoten mit der kleinsten Tiefe in $P_l$, für den gilt $k \geq l$. Erzeuge einen Knoten $u_l$ mit Schlüssel $k_l$ und füge ihn als linkes Kind an $u$ an. Füge $u_l$ zu $W$ hinzu.
	\item Ist $P_r$ der leere Pfad weiter mit $7$.
	\item Sei $k_r$ der Schlüssel des Knoten mit der kleinsten Tiefe in $P_r$, für den gilt  $k \leq r$. Erzeuge einen Knoten $u_r$ mit Schlüssel $k_r$ und füge ihn als rechtes Kind an $u$ an. Füge $u_r$ zu $W$ hinzu.	
	\item Füge $u$ zu $U$ hinzu, weiter mit $1$
\end{enumerate}
Das Verfahren muss terminieren da die Anzahl der Knoten von $T$ endlich ist. So konstruiert muss $T^r_l$ ein BST sein. Ein Beispiel stellt Abbildung \ref{fig:T_r_l} dar. 
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/DynOpt/T_r_l"}
	\caption{Links ein BST $T$. Rechts ein davon abgeleiteter BST $T^8_4$ .  }
	\label{fig:T_r_l}
\end{figure}

 \noindent Sei $K_1$ die Schlüsselmenge von $T$ und $K_2$ die von $T^r_l$. Sei ${K^r_l = K \cap \{i \in \mathbb{N}\vert i \in \left[l,r\right] \}}$. Jetzt wird noch darauf eingegangen warum $K_2 = K^r_l$ gilt \\

 \noindent $K_2 \subseteqq  K^r_l$ erkennt man direkt an dem Verfahren zur Konstruktion von $T^r_l$.\\
 
 \noindent $ K^r_l \subseteqq K_2$:\\
 Sei $k \in K^r_l$ und $v_k$ der Knoten in $T$ mit $\mathit{key}(v) = k$. Es muss einen Pfad $P = v_0,..,v_n$ in $T$ geben, mit $v_0 = v_r$, $v_n = v_k$ und für $i \in \{1,..,n\}$ $v_i$ ist Kind von $v_{i-1}$. Sei $m$ die Anzahl der Knoten $w$ in $P$, mit $\mathit{key}(w) \in \left[l,r\right]$. Nun folgt Induktion über $m$.\\
  Für $m = 1$ gilt $k = k_r$  und $k \in K_2$. \\
  $m +1$:\\
  Sei $w$ der tiefste Knoten in $P$ mit $ v_0,..,v_{n-1}$, mit $\mathit{key}(w) \in  K_2$. $w$ muss existieren da $m > 1$. Nach Induktionsvoraussetzung gibt es einen Knoten $u_k$ mit $\mathit{key}(u_k) = \mathit{key}(w)$ in $T^r_l$. Es sei $\mathit{key}(w) > \mathit{key}(v_k)$, der andere Fall ist symmetrisch. Ist $v_k$ linkes Kind von $w$, dann enthält das linke Kind von $u_k$ den Schlüssel $\mathit{key}(v_k)$. Anderenfalls gilt für alle $v_j$ mit $m < j < k$, $\mathit{key}(v_j) < l < \mathit{key}(v_k)$. Somit muss $v{m+1}$ ein linkes Kind sein und die Knoten in $P$ mit größerer Tiefe als $v{m+1}$ müssen rechte Kinder sein. Damit ist auch in diesem Fall ein Knoten $u_k$ mit $\mathit{key}(u_k) = \mathit{key}(w)$ linkes Kind von $u_m$.  \\
  
 \noindent Nun kommen wir zum Lemma:\\
 
 


	    
	 
 \noindent Sei $v$ ein Knoten in $T$, dann wird ein Knoten in $T^r_l$ mit Schlüssel $\mathit{key}(v)$  mit $v^*$ bezeichnet.  
\newtheorem{Lemma3}{Lemma}[section] \label{lemmaWilber1}
\begin{Lemma3} Es sei $T$ ein BST mit Knoten $u, v$ so, dass $u$ ein Kind von $v$ ist. $T'$ ist der BST, der durch Ausführen der Rotation $\left(u,v\right)$ entsteht. Gilt $u,v \in \left[l,r\right]$, dann ist ${T'}^r_l$ der BST der aus $T^r_l$ durch Ausführen von  $\left(u,v\right)$ entsteht. Anderenfalls gilt ${T'}^r_l = T^r_l$.
\end{Lemma3}
\begin{proof}
\noindent Für $u,v \notin \left[l,r\right]$ erkennt man $T'^r_l = T^r_l$ direkt.
Nun werden die vier Fälle betrachtet bei denen entweder $u$ oder $v$ in $\left[l,r\right]$ liegen.
\begin{enumerate}
	\item $u$ ist das linke Kind von $v$ und $u < l$:\\
	Die Schlüsselmenge wird durch Rotationen nicht verändert. Sei $w$ ein Knoten aus $T^r_l$ und $w'$ einer aus $T'^r_l$, mit $\mathit{key}(w) = \mathit{key}(w')$ und $\mathit{key}(w) \in \left[l,r\right]$. Es muss gezeigt werden dass, wenn $w$ ein linkes bzw. rechtes Kind mit Schlüssel $k$ hat, dann gilt dies auch für $w'$. Da $\mathit{key}(u) < l < \mathit{key}(w) $ gilt kann weder $u$ noch $v$ im rechten Teilbaum von $w$ liegen. Somit ist bezüglich der rechten Kinder nichts zu zeigen. 
	Sei $P_l$ der linke innere Pfad von $w$. Ist $v$ nicht in $P_l$ enthalten und gilt $v \neq w$ dann gilt $P_l = P'_l$. Sei $w = v$. Dann gilt $P_l = u  \circ  P'_l$ \ref{vergleiche Abbildung Kapitel 1 Rotationen} und da $\mathit{key}(u) < l$ gilt, bleibt das linke Kind von $w$ unverändert. Nun sei $v$ in $P_l$ enthalten. Dann unterscheiden sich  $P_l$ und  $P'_l$ dadurch, dass ein Knoten mit $\mathit{key}(u)$ in $P'_l$ enthalten ist. Mit $u < l$ gilt aber, dass $w'$ und $w'$ bezüglich des Schlüssels ihres linken Kindes nicht unterscheiden.
	\item $u$ ist das rechte Kind von $v$ und $u > r$:\\
	Links-Rechts-Symmetrisch zu Fall 1. 
	\item $v$ ist das linke Kind von $u$ und $u < l$:\\
	    Von $T'$ nach Fall 1 erreicht man nach Ausführung der Rotation mit dieser Konstellation wieder $T$. Somit muss nichts weiter gezeigt werden.
	\item $v$ ist das linke Kind von $u$ und $u > r$:\\
	Von $T'$ nach Fall 2 erreicht man nach Ausführung der Rotation mit dieser Konstellation wieder $T$. Somit muss nichts weiter gezeigt werden.\\
       	    
\end{enumerate}	
\noindent Übrig bleibt noch die Konstellation $u,v \in \left[l,r\right]$. 
Betrachtet wird eine Rechtsrotation $(u,v)$, die Linksrotation ist wieder symmetrisch. 
In $T^r_l$ muss es zwei Knoten $w, x$ geben, mit {$\mathit{key}(u) = \mathit{key}(w)$,  $\mathit{key}(v) = \mathit{key}(x)$} und $w$ muss linkes Kind von $x$ sein.
Es werden die Rotationen $\left(u,v \right)$ und $\left(w,x \right)$ ausgeführt.
Zu zeigen ist ${T'}^r_l = T{^r_l}' $.\\
In $T$ verändern sich maximal drei innere Pfade.
\begin{enumerate}
	\item Sei $u_r$ das rechte Kind von $u$. Sei $u,u_r,v_1,..,v_n$ der linke innere Pfad von $v$, dann ist $u'_r,v'_1,..,v_n$ der linke innere Pfad von $v'$. Es gilt ${\mathit{key}(u), \mathit{key}(u_r) \in \left[l,r\right] }$. Damit ist $u*$ das linke Kind von $v^*$ und ${u_r}'^*$ das linke Kind von $v'^*$.
	\item Sei $v_1,..,v_n$ der rechte innere Pfad von $u$, dann ist $v',v_1',..,v_n'$ der rechte innere Pfad von $u'$, damit ist $v'$ rechtes Kind von $u'$. Damit ist $v'^*$ das rechte Kind von $u'*$.
	\item Ist $v$ das linke bzw. rechte Kind eines Knoten $z$ mit $\mathit{key}(z) \in \left[r,l\right]$, dann sei  $v,..,v_n$ der linke bzw. rechte innere Pfad von $z$. Dann ist  $u',v',..,v'_n$ der linke bzw. rechte innere Pfad von $z'$. Dann ist  $v'^*$ das linke bzw. rechte Kind von $z^*$ und $u'^*$ das linke bzw. rechte Kind von $z'^*$.
\end{enumerate}
 \noindent Nun wird auf ${T'}^r_l$ die Rotation $(u^*,v^*)$ ausgeführt. $u{^*}'$ ist linkes Kind von $v{^*}'$. $v{^*}'$ das rechte Kind von $u{^*}'$. Ist $v^*$ das linke bzw. rechte Kind eines Knoten $z^*$ mit  $\mathit{key}(z^*) \in \left[r,l\right]$, dann ist $v{^*}'$ das linke bzw. rechte Kind von $z{^*}'$ und $u{^*}'$ das linke bzw. rechte Kind von $z{^*}'$. Damit gilt ${T'}^r_l = T{^r_l}'$.\\
 	
\end{proof}
    
\newtheorem{Satz1}{Satz}[section] \label{satzWilber1}
\begin{Satz1} Es sei $T$ ein standard offline BST access algorithm mit Schlüsselmenge ${K = \{  i \in \mathbb{N} \vert i \in \left[j,k\right] \textit{ mit } j,k \in  \mathbb{N} \}} $. Sei $Y$ ein für $T$ erstellter lower bound tree und $X$ eine zu $T$ erstellte Zugriffsfolge mit Länge $m$. Dann gilt  $W\left(X, T\right) \geq {_X(T_0, Y, X)} $.  
\end{Satz1}
\begin{proof}
Sei $U$ die Menge der internen Knoten von $Y$. Die Kosten zum Ausführen sind die \textit{Anzahl der Einzelschritte} $ + {m}$. Es reicht also aus zu zeigen, dass mehr als $\sum_{u \in U} {_x} (u)$ Rotationen benötigt werden. Es wird Induktion über  $n = \vert K \vert$ angewendet. Sei $n = 1$, dann gibt es keinen internen Knoten in $Y$ und $\sum_{u \in U} {_x} (u) = 0$. Der Induktionsanfang ist somit gemacht. Im folgenden sei $n \geq 2$.\\
Sei $R = r_1,r_2,..,r_r$ die Folge der insgesamt durchgeführten Rotationen. Für $i \in \{1,..,r\}$ sei $T_i$ der BST, der entsteht nachdem $r_i$ auf $T_{i-1}$ ausgeführt wurde. Sei $w$ die Wurzel, mit Schlüssel $k_w$, von $Y$ und $Y^1$ bzw. $Y^2$ der linke bzw. rechte Teilbaum von $w$. Es ist zu beachten, dass $Y^1$ ein lower bound tree zu $T_1^{k_w}$ ist und  $Y^2$ einer zu $T^\infty_{k_w}$ . Da $n \geq 2$ muss $w$ ein interner Knoten sein. Sei  $R^1 = r^1_1,r^1_2,..,r^1_{r^1} = R^{k_w}_1$ und $R^2 = r^2_1,r^2_2,..,r^2_{r^2} = R^\infty_{k_w}$. Mit $M$ wird die Folge bezeichnet, die entsteht, wenn aus $R$ alle Rotationen entfernt werden, die in $R^1$ oder $R^2$ enthalten sind. Sei $r_M$ die Länge von $M$. Es muss $r = r^1 + r^2 + r_M$ gelten, da keine Rotation sowohl in $R^1$ als auch in $R^2$ enthalten sein kann. $X_1$ ist die Folge die entsteht wenn aus $X$ alle Schlüssel $k > w$ entfernt werden. $X_2$ entsteht durch entfernen aller Schlüssel $k < w$ aus $X$. Für $j \in \{1,2\}$, sei $U^j$ die Menge der internen Knoten von $Y^j$. Sei $T^{j'}_0,T^{j'}_1,..,T^{j'}_{r_j}$ die entstehende Folge, wenn aus $T^{j}_0,T^{j}_1,..,T^{j}_{r}$ die $T^j_t$ entfernt werden für die $T^j_{t-1} = T^j_t$ gilt. Mit Lemma ?? kann  $T^{j'}_{t-1}$ durch Ausführung der Rotation $r^j_t$ auf $T^{j'}_{t-1}$ abgeleitet werden, außerdem muss $r^j= r_j$ gelten. Außerdem gilt durch dieses Lemma, dass wenn ein Knoten mit Schlüssel $k < w$ bzw. $k > w$ die Wurzel von $T_t$ ist dann muss die Wurzel von $T^1_t$ bzw. $T^2_t$ auch Schlüssel $k$ haben. $R^j$ bringt also der Reihe nach, die Knoten mit den Schlüsseln aus $R^j$ an die Wurzel von $T^j$ und  $X^j$ kann als Zugriffsfolge für $T^j$ aufgefasst werden. Da die Knotenzahl in $T^j$ kleiner $n$ sein muss gilt mit der Induktionsvoraussetzung  $r_j \geq \sum_{u \in U^j} {_x} (u)$.\\
Sei $\sigma = \mathit{key}(w) \circ X$. Sei $a$ eine $w$-Transition. Nun wird angenommen dass $\sigma_{w-1} < \mathit{key}(w)  \land \sigma_{w} > \mathit{key}(w)$. Der andere Fall kann davon problemlos abgeleitet werden. Sei $y$ der Knoten in $T$ mit $\mathit{key}(y) = \sigma_{w-1}$ und $z$ der Knoten in $T$ mit $\mathit{key}(z) = \sigma_{w}$. Nach \textit{access($\sigma_{w-1}$)} ist $y$ die Wurzel von $T$. $z$ muss sich im rechten Teilbaum von $y$ befinden. Nach  \textit{access($\sigma_{w}$)} ist $z$ die Wurzel von $T$. $y$ muss sich im linken Teilbaum von $z$ befinden. Somit muss während \textit{access($\sigma_{w}$)} die Rotation $(\mathit{key}(z),\mathit{key}(y))$ ausgeführt worden sein. $(\mathit{key}(z),\mathit{key}(y))$ muss in $M$ enthalten sein. Für jede $w$-Transition ist also mindestens eine Rotation in $M$ enthalten, also $r_M \geq  {_x} (w)$.\\
Zusammengefasst ergibt sich:

\begin{align*}
r = r^1 + r^2 + r_M \geq \sum_{u \in U^1} {_x} (u) + \sum_{u \in U^2} {_x} (u) +  {_x} (w)
\end{align*}



	
\end{proof}

\noindent Da $T$ beliebig gewählt ist folgt direkt $\mathit{OPT}\left(X\right) \geq {_X(T_0, Y, X)} $.  


\subsection{bit reversal permutation }
In diesem Abschnitt wird gezeigt, dass es Zugriffsfolgen mit Länge $m$ für BST $T$ gibt, so dass für die Laufzeit eines BST access algorithm $\Theta\left(m \log n\right)$ gilt, mit $n$ ist die Anzahl der Knoten von $T$. Hier werden speziell die Zugriffsfolgen betrachtet, die als \textbf{bit reversal permutation} bezeichnet werden. Auf $O\left(m \log n\right)$ wird hier nicht weiter eingegangen. Jeder balancierte BST mit \textit{access} Operation garantiert jedoch diese Schranke und mit dem Rot-Schwarz-Baum wird später ein solcher noch vorgestellt.
 $\Omega\left(m \log n\right)$  wird mit Hilfe der ersten unteren Schranke von Wilber gezeigt und ein Beweis ist ebenfalls in \cite{wilberLowerBounds} enthalten. \\
  Nun wird zunächst der Aufbau einer solchen Zugriffsfolge eingegangen. Sei $l \in \mathbb{N}$ und $i \in \{0,1,..,l-1\}$. Eine Folge  $b_{l-1},b_{l-2},..,b_0$ mit $b_i \in \{0,1\}$, kann als Zahl zur Basis $2$ interpretiert werden. $T$ enthält alle Schlüssel die als solche Folge dargestellt werden können. Die Schlüsselmenge von $T$ ist deshalb $K_l = \{0,1,..,2^l -1\}$. 
  Die Funktion $\mathit{br}_l(k)\colon K \rightarrow K$ ist wie folgt definiert. Sei {$b_{l-1},b_{l-2},..,b_{0}$} die Binärdarstellung von $k$, dann gilt 
\begin{align*}
\mathit{br}_l(k) = \sum_{i = 0}^{l-1} b_{\left(l-1-i\right)} \cdot 2^i
\end{align*}
 $\mathit{br}_l(k)$ gibt also gerade den Wert der \enquote{umgekehrten} Binärdarstellung von $k$ zurück. Die bit reversal permutation zu $l$ ist die Zugriffsfolge\\ ${\mathit{br}_l(0),\mathit{br}_l(1),..,\mathit{br}_l(2^l-1)}$. Diese wird ab jetzt mit $X$ bezeichnet. Sei $y$ die Hälfte von $\max\left(K\right)$, also $y = 2^{l-1} - 0,5$. Da $b_0$ in den Binärdarstellungen zu $0, 1, 2^l-1$ alterniert, alterniert $b_{l-1}$ in $X$. Mit $2^{l-1} > y$ ergeben sich die Implikationen $\mathit{br}_l(k) < y \Rightarrow \mathit{br}_l(k +1) > y$ und $\mathit{br}_l(k) > y \Rightarrow \mathit{br}_l(k +1) < y$. Da $\vert K_l \vert = 2^l$ kann zu $T$ ein vollständig balancierter lower bound tree $Y$ erstellt werden. Sei $w$ die Wurzel von $Y$. Da im linken Teilbaum von $w$ genau so viele Blätter wie im rechten vorhanden sein müssen, kann nur $y$ der Schlüssel von $w$ sein. Zu einer Zugriffsfolge $X = x_0,x_1,..,x_m$ bezeichnet $X^r_l$ die Zugriffsfolge, die entsteht wenn aus $X$ alle Schlüssel $k$, mit $k < l \lor k > r$ entfernt werden. $X + i$ mit $i \in \mathbb{N}$ bezeichnet im Folgenden die Folge $x_0 + i, x_1 + i,.., x_m + i$.
  


\newtheorem{Korollar1}{Korollar}[section]
\begin{Korollar1} Sei $l \in \mathbb{N}$. Sei $T$ ein BST mit Schlüsselmenge\\ ${K_l = \{0,1,..,2^l -1\}}$ und $n = 2^l$. Sei $X = x_0, x_1,..,x_{n-1}$ die bit reversal permutation zu $l$ und $Y$ der vollständig balancierte lower bound tree zu $T$. Dann gilt  $W\left(X,T\right) \geq n \log_2 n + 1 $. 
\end{Korollar1}
\begin{proof}
Sei $U$ die Menge der internen Knoten von $Y$. Mit Satz \ref{satzWilber1} reicht es aus 

\begin{align*}
\sum_{u \in U} {_x\left(u\right)} \geq n \log_2 n + 1 - n 
\end{align*} 
zu zeigen. Dies geschieht mit Induktion über $l$. Für $l = 0$ besteht $Y$ aus einem einzigen Blatt. Damit gilt $ W\left(X,T\right) = 0 = n \log_2 n + 1 $. \\
Nun sei $l > 0$. Sei $w$ die Wurzel von $Y$, mit $k_w = \mathit{key}(w)$. $T_0^{k_w}$ enthält die Schlüsselmenge $K_0^{k_w} = \{k \in \mathbb{N}\vert k \leq 2^{l-1} - 1\}$ und $T_{k_w}^\infty$ enthält die Schlüsselmenge  $ K^\infty_{k_w} = \{k \in \mathbb{N}\vert \exists n \in K_0^{k_w}\colon  k = n + 2^{l-1}\}$. Sei $Y^1$ bzw. $Y^2$ der linke bzw. rechte Teilbaum von $w$ und $U^1$ bzw. $U^2$ die Menge der internen Knoten von $Y^1$ bzw. $Y^2$. $Y^1$ und $Y^2$ sind vollständig balancierte lower bound trees zu $T_0^{k_w}$ und $T_{k_w}^\infty$. $X^{k_w}_0$ ist die bit reversal permutation für $T_0^{k_w}$. Außerdem gilt $X_{k_w}^\infty = X^{k_w}_0 + 2^{l-1}$. Mit der Induktionsvoraussetzung gilt deshalb, für $i \in \{1,2\}$,
\begin{align*}
\sum_{u \in U^i} {_x\left(u\right)} \geq  \frac{n}{2} \log_2 \left(\frac{n}{2} \right) + 1 - \frac{n}{2}  
\end{align*}
Aus $x_j < k_w \Rightarrow x_{j-1} > k_w  \land x_j > k_w \Rightarrow x_{j-1} < k_w $ folgt $_x{w} \geq n-1$. Zusammenfassen ergibt
\begin{align*}
\sum_{u \in U} {_x\left(u\right)} &\geq 2 \left( \frac{n}{2}  \log_2 \left(\frac{n}{2} \right) + 1 - \frac{n}{2} \right) + n - 1\\	
&= n (l-1) + n + 1 \\
&= n l + 1 \\	
&> n l + 1 -n \\
&= n \log_2 n + 1 - n\\	
\end{align*}
		
\end{proof}

\noindent Die Schlüsselmenge  wurde beim Korollar auf ${K_l = \{0,1,..,2^l -1\}}$ festgelegt. Vielleicht wäre es aber mit einer anderen Schlüsselmenge $K$ möglich $X$ schneller auszuführen ? In jedem Fall müsste $K_l \subseteqq K$ gelten. Sei $R$ die Folge von Rotationen, die beim Ausführen von $X$ bei einem BST $T$ mit Schlüsselmenge $K$ entsteht. Sei $y = 2^l -1$ Mit Lemma \ref{lemmaWilber1} ist dann $R_0^y$ eine Folge von Rotationen zum ausführen von $X$ auf $T_0^y$ und die Länge von $R$ kann nicht kleiner als die von $R_0^y$ sein. Damit ist $\mathit{OPT}\left(X\right) = \Omega\left(m \log n \right)$. 



\subsection{Amortisierte Laufzeitanalyse}
Im nächsten Anschnitt werden die Kosten von amortisierten Laufzeitanalysen verwendet. Deshalb wird diese hier nun vorgestellt.
Sei $i \in \{0,..,m\}$. Bei der \textbf{amortisierten Laufzeitanalyse} wird eine Folge von $m$ Operationen betrachtet. Hierbei kann es sich $m$ mal um die gleiche Operation handeln, oder auch um verschiedene. Die \textbf{tatsächlichen Kosten}  $t_i$ stehen für die exakten Kosten zum ausführen der $i$-ten Operation. Durch aufaddieren der tatsächlichen Kosten jeder einzelnen Operation erhält man \textbf{tatsächlichen Gesamtkosten}.  Stehen für die Laufzeit der Operationen jeweils nur obere Schraken zur Verfügung, kann man mit diesen genau so vorgehen, um eine obere Schranke für die Gesamtlaufzeit zu erhalten. So erzeugte obere Schranken können jedoch unnötig hoch sein. Die Idee bei einer amortisierten Analyse ist es, bereits eingesparte Zeit durch schnell ausgeführte Operationen, den noch folgenden Operationen zum Verbrauchen zur Verfügung zu stellen.  Dabei wird insbesondere der aktuelle Zustand der zugrunde liegenden Datenstruktur vor und nach einer Operation betrachtet. Es gibt drei Methoden zur amortisierten Analyse, hier wird die \textbf{Potentialfunktionmethode} verwendet.
\paragraph{Potentialfunktionmethode} Eine Potentialfunktion $\Phi(D)$ ordnet einem Zustand einer Datenstruktur $D$ eine natürliche Zahl, \textbf{Potential} genannt, zu. Es bezeichnet $\Phi(D)_{i}$ das Potential von $D$ nach Ausführung der $i$-ten Operation. $t_i$ steht für die \textbf{tatsächlichen Kosten} zum durchführen der $i$-ten Operation. Dabei handelt es sich um die exakten Kosten die beim Die \textbf{amortisierten Kosten} $a_i$ einer Operation berücksichtigen die von der Operation verursachte Veränderung am Potential, $a_i = t_i + \Phi(D)_{i} - \Phi(D)_{i-1}$. Um die \textbf{amortisierten Gesamtkosten} $A$ zu berechnen bildet man die Summe der amortisierten Kosten aller Operationen. 
\begin{align*}
A = \sum_{i = 1}^{m} a_i =  \sum_{i = 1}^{m} \left(t_i + \Phi\left(D\right)_{i} - \Phi\left(D\right)_{i-1}\right) = \Phi\left(D\right)_{m} - \Phi\left(D\right)_{0} + \sum_{i = 1}^{m} t_i 
\end{align*}
Folgendes gilt für die Summe der $t_i$:
\begin{align*}
&\sum_{i = 1}^{m} t_i =  \sum_{i = 1}^{m} \left(a_i - \Phi\left(D\right)_{i} + \Phi\left(D\right)_{i-1}\right) = \Phi\left(D\right)_{0} - \Phi\left(D\right)_{m} + \sum_{i = 1}^{m} a_i \\
\Rightarrow &\left( \Phi\left(D\right)_{m} \geq \Phi\left(D\right)_{0} \Rightarrow \sum_{i = 1}^{m} a_i \geq \sum_{i = 1}^{m} t_i \right)
\end{align*}
Ist das Potenzial nach Ausführung der Operationsfolge also nicht kleiner als zu Beginn, dann sind die amortisierten Gesamtkosten eine obere Schranke für die tatsächlichen Gesamtkosten. Die wesentliche Aufgabe ist es nun eine Potentialfunktion zu finden, bei der die amortisierten Gesamtkosten möglichst niedrig sind und für die gilt $\Phi\left(D\right)_{m} \geq \Phi\left(D\right)_{0}$. Dies wird jetzt noch an einem einfachen Beispiel demonstriert.

\paragraph{Potentialfunktionmethode am Beispiel eines Stack} 
Der Stack verfügt wie gewöhnlich über eine Operation \textit{push} zum Ablegen eines Elementes auf dem Stack und über \textit{pop} zum Entfernen des oben liegenden Elementes. Zusätzlich gibt es eine Operation \textit{popAll}, die so oft \textit{pop} aufruft, bis der Stack leer ist. Sei $n$ die Anzahl der Elemente die maximal im Stack enthalten sein kann. \textit{push} und \textit{pop} können in konstanter Zeit durchgeführt werden und wir berechnen jeweils eine Kosteneinheit. Für die Laufzeit von \textit{popAll} gilt $O(n)$, da \textit{pop} bis zu $n$ mal aufgerufen wird. Für die Gesamtlaufzeit einer Folge von $m$ Operationen kann sicher $O(mn)$ angegeben werden. Mit einer amortisierten Analyse wird nun aber $O(m)$ für \textit{popAll} gezeigt. Als $\Phi$ verwenden wir eine Funktion, welche die aktuelle Anzahl der im Stack enthaltenen Elemente zurück gibt. $\Phi_0$ setzen wir auf $0$, dass heißt wir starten mit einem leeren Stack. \textit{push} erhöht also das Potential um eins, während \textit{pop} es um eins vermindert. Nun werden die amortisierten Kosten bestimmt. 

\begin{align*}   
&a_{\mathit{push}} = t_{\mathit{push}} + \Phi{i} - \Phi{i-1}  &= 2\\
&a_{\mathit{pop}} = t_{\mathit{pop}} + \Phi{i} - \Phi{i-1}  &= 0\\
&a_{\mathit{popAll}} = n \cdot a_{\mathit{pop}} &= 0
\end{align*}\\
Alle drei Operationen haben konstante amortisierte Kosten. Auf jedem Fall gilt $ \Phi_m \geq  \Phi_0 = 0 $ Damit gilt für die Ausführungszeit der Folge $O(m)$. \\
Bei diesem einfachen Beispiel ist sofort klar warum es funktioniert. Aus einem zu Beginn leerem Stack kann nur entfernt werden, was zuvor eingefügt wurde. \textit{push} zahlt für die Operation, welche das eingefügte Element eventuell wieder entfernt gleich mit, bleibt bei den Kosten aber konstant. Deshalb kann \textit{pop} amortisiert kostenlos durchgeführt werden, wodurch einer der beiden Faktoren zur Berechnung der Kosten von \textit{popAll} zu $0$ wird.  
\subsection{Besondere Eigenschaften in Bezug zu Zugriffssequenzen }
Im letzten Abschnitt wurde gezeigt, dass für die Ausführung einer beliebigen Zugriffsfolge $X$, mit Länge $m$, für einen BST $T$ mit $n$ Knoten im worst case Kosten von  $O\left(m \log n\right)$ angenommen werden müssen.  Im folgendem werden fünf Eigenschaften von BST vorgestellt, die sich auf besondere Eigenschaften bei Zugriffssequenzen und obere Laufzeitschranken beziehen. Es wird wieder ohne Verlust der Allgemeinheit eine Schlüsselmenge $K = \{1,2,..,n\}$ angenommen, andere müssten aufsteigend sortiert entsprechend nummeriert werden. Wenn nicht anders angegeben wird  $X = x_1,x_2,..,x_m$ als Zugriffssequenz verwendet.

\paragraph{Sequential Access Property}
Ein BST erfüllt das Sequential Access Propery, wenn es die Zugriffssequenz $1,2,..,n$ in amortisiert $O(1)$ Zeit pro \textit{access} Operation durchführt. Insgesamt kann diese Sequenz dann in amortisiert  $O(n)$ Zeit ausgeführt werden.

\paragraph{Dynamic Finger Property}
Ein BST erfüllt das Dynamic Finger Property, wenn für die amortisierte Zugriffszeit $t_i$ von $x_i$ gilt: 
\begin{align*}
t_i = O\left(\vert x_i - x_{i-1} \vert \right)
\end{align*} 


\paragraph{Entropy Bound}
Sei $k \in K$. $X$ enthalte $k_X$ mal $k$. Sei $p(k) = \frac {k_X}{m}$. Für Entropy Bound muss für die amortisierte Gesamtlaufzeit 
\begin{align*}
O\left(\sum_{k = 1}^{n} \log  \frac{1}{p(k)} \right) 
\end{align*}
gelten. Da es sich hierbei um eine untere Schranke für statische BST handelt, siehe \cite{staticOptimal}, werden BST mit der Entropy Bound auch als statisch optimal bezeichnet.  


\paragraph{Working Set Property}
Sei $x_i = x_j$ mit $i < j$ und \\ 
$\forall x_k \colon i < k < j \Rightarrow x_k \neq x_i$. Sei  $X_{ij} = \{x_k \vert i < k < j\}$.  Für das Working Set Property muss für die amortisierte Laufzeit von \textit{ access($x_j$) }
\begin{align*}
O\left(\log x_j\right)
\end{align*} 
gelten. Sind Schlüssel vielfach in $X$ enthalten, so garantiert das Working Set Property, dass diese Zugriffe schnell ausgeführt werden können. 

\paragraph{Unified Property}
Seien $x_i, x_j$ und $X_{ij}$ wie beim Working Set Property definiert und sei $t_{ij} =\vert X_{ij}\vert$. Für das Unified Property muss für die amortisierte Laufzeit von \textit{ access($x_j$) }  
\begin{align*}
O \left(\log \left( \min_{i < j} \left(\vert x_i - x_j \vert + t_{ij} + 2   \right)\right)\right)
\end{align*} 
gelten.
\newpage
\bibliography{literaturverzeichnis}
\bibliographystyle{unsrt}

\end {document}


