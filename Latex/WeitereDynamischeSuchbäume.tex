\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[ngerman,german]{babel}
\usepackage[T1]{fontenc}
\usepackage{courier}
\usepackage{float}
\usepackage{amsmath,amsthm}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{csquotes}
\usepackage[font=small,labelfont=bf]{caption}

%\usepackage[pages=some]{background} % Draft Wasserzeichen mit Option pages=all sonst pages=some



\title{Bachelorarbeit}
\author{
Andreas Windorfer\\
}
\date{\today}


\begin {document}


\maketitle
\newpage
Zusammenfassung
\newpage
\tableofcontents


\newpage


\section {Weitere binäre Suchbäume}
Hier werden kurz zwei Variationen zum Tango Baum vorgestellt. Zum einen der Zipper Baum. Er wurde in \cite{zipper} vorgestellt und ist ebenfalls $\log\left(\log\left(n\right)\right)$-competitive,  garantiert aber auch  $O\left(\log \left(n\right)\right)$ im worst case, bei einer einzelnen \textit{access} Operation. $n$ steht wieder für de Anzahl der Knoten von $T$. Zum anderem den Multisplay Baum \cite{multisplay}. Bei diesem wird ein preferred path durch einen Splay Baum repräsentiert. Amortisiert betrachtet erreicht er $O\left(\log \left(n\right)\right)$ bei \textit{access} und ist  $\log\left(\log\left(n\right)\right)$-competitive. 

\subsection{Zipper Baum}
Der Zipper Baum basiert auf dem Tango Baum und nutzt auch preferred paths aus einem Referenzbaum $P$. Aufbau und Pflege der preferred paths in $P$ unterscheiden sich nicht vom Tango Baum.  Ihre Repräsentation im eigentlichen BST $T$, macht den wesentlichen Unterschied zu einem Tango Baum aus. Abbildung \ref{fig:zipperPathRep} stellt eine solche beispielhaft dar.  Sei $v$ ein Knoten in $T$, dann ist in diesem Kapitel $v^*$ der Knoten in $P$, mit $\mathit{key}\left(v\right) =\mathit{key}\left(v^*\right)$. Die Repräsentation eines preferred path  $P_p = {p_1}^*,{p_2}^*,..,{p_m}^*$ in $T$ stellt einen Hilfsbaum $H$ dar, der in zwei Teile unterteilt wird, dem \textbf{zipper} und dem \textbf{bottom tree}.  Der bottom tree ist ein balancierter BST der genau die Schlüssel enthält, die in $P_p$ enthalten sind jedoch nicht im zipper. Der zipper besteht aus zwei Teilen, dem \textbf{top zipper} $z_t$ und dem \textbf{bottom zipper} $z_b$. $z_t$ und $z_b$ dürfen jeweils maximal $\log_2\left(\log_2\left(n\right)\right)$ Knoten enthalten. Gemeinsam müssen enthalten sie zumindest $\log_2\left(\log_2\left(n\right)\right) / 2$ Knoten, wenn ein bottom tree existiert. Bei weniger als $\log_2\left(\log_2\left(n\right)\right) / 2$ Knoten im Hilfsbaum existiert kein bottom tree. Es wird im folgenden angenommen, dass ein bottom tree existiert. \\
$P_p$ wird in \textbf{zig Segmente} und \textbf{zag Segmente} unterteilt. zig Segmente entsprechen den längst möglichen Pfaden von Knoten mit rechten Kindern in $P_p$. zag Segmente entsprechen den längst möglichen Pfaden von Knoten mit linken Kindern in $P_p$. Das Blatt in $P_p$ wird dem Segment seines Elternknoten zugeordnet. In Abbildung  \ref{fig:preferredPathZigZag} sind zig und zag Segmente dargestellt.\\
Sei $t_l$ bzw. $t_r$ der Knoten in $S_{zig}$ bzw. $S_{zag}$ mit der kleinsten Tiefe. $t_l$ ist die Wurzel von $H$. $t_r$ ist das rechte Kind von $t_l$. Der linke Teilbaum von $t_l$  hat Listenform und  wird von den restlichen Knoten in $S_{zig}$ gebildet, so dass kein Knoten in diesem Teilbaum ein linkes Kind hat. Der rechte Teilbaum von $t_r$  hat Listenform und  wird von den restlichen Knoten in $S_{zag}$ gebildet, so dass kein Knoten in diesem Teilbaum ein rechtes Kind hat. \\
$z_b$ wird analog aus $P_b$ erzeugt und seien $b_l$ und $b_r$ die Knoten in $z_b$ entsprechend zu $t_l$ und $t_r$ in $z_t$. $b_l$ ist das linke Kind von $t_r$. Die Wurzel des bottom Tree ist das linke Kind von $t_r$. Dass die Links-Rechts-Beziehung eingehalten wird ergibt aus den Aufbau der zig und zag Segmente. Es ist leicht zu erkennen, dass die Wurzel des bottom tree in konstanter Zeit erreicht werden kann.
\begin{figure}[h]
	\centering
	\includegraphics[width= 0.8\textwidth]{"Medien/Zipper/zipperPathRep"}
	\caption{Pfadrepräsentation beim Zipper Baum, basiert auf einer Abbildung aus \cite{zipper}. }
	\label{fig:zipperPathRep}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[height= 0.7\textwidth]{"Medien/Zipper/preferredPathZigZag"}
	\caption{zig Segmente sind grün dargestellt. zag Segmente blau }
	\label{fig:preferredPathZigZag}
\end{figure}

\paragraph{Besonderheiten bei \textit{access}}
Sei $l$ die Anzahl der Knoten des top zipper.
Beim Suchen nach einem Schlüssel in einem Hilfsbaum $H$, wird dessen top zipper, mit $l$ Knoten, soweit wie notwendig, in einen Pfad gewandelt, der $p_1, p_2, .., p_l$ entspricht. Ist der top zipper vollständig in einen Pfad umgewandelt, wird der Vorgang beim bottom zipper fortgesetzt. Dieser hat dann die Stellung des top zipper. Außerdem wird dann ein \textbf{Extraktionsprozess} angestoßen, der $\log\left(\log\left(n\right)\right)$ Knoten aus dem bottom tree auslagert, um einen neuen bottom zipper zu erzeugen. Ein Extraktionsprozess ist in Abbildung \ref{fig:extractHybrid} dargestellt.\\
Ein Knoten aus dem top zipper kann dem Pfad in konstanter Zeit hinzugefügt werden. Ist bei \textit{access}$\left(k\right)$ der top zipper aufgebracht, sind bereits Kosten von $O\left(\log\left(\log\left(n\right)\right)\right)$ entstanden. Sei $P_p$ der preferred path den $H$ repräsentiert. Ist der gesuchte Knoten im top zipper enthalten, entstehen in $P$ aufgrund der Knoten von $P_p$ asymptotisch betrachtet die gleichen Kosten, wie in $H$. Befindet sich der gesuchte Knoten im bottom zipper oder dem bottom tree entstehen in $H$ ebenfalls Kosten von  $O\left(\log\left(\log\left(n\right)\right)\right)$. Deshalb entstehen asymptotisch betrachtet in $H$ innerhalb $P_p$ die gleichen Kosten. Hieraus wird abgeleitet, dass eine \textit{access} Operation in $O\left(\log\left(n\right)\right)$ Zeit ausgeführt werden kann.


\begin{figure}[h]
	\centering
	\includegraphics[height= 0.5\textwidth]{"Medien/Zipper/hybrid/extractHybrid"}
	\caption{Extraktionsprozess beim Zipper Baum}
	\label{fig:extractHybrid}
\end{figure}
\subsection{Multisplay Baum}
Ein preferred path wird hier durch einen Splay Baum dargestellt, um dessen Laufzeiteigenschaften nutzen zu können. Da der Splay Baum kein balancierter Baum ist, gibt es zusätzliche mögliche Zustände im Vergleich zu einem Tango Baum mit der gleichen Knotenzahl. Zu den genannten Eigenschaften bezüglich der Laufzeit sind Beweise in \cite{multisplay} enthalten. Der Multisplay Baum erfüllt die working set Eigenschaft \cite{porpMultiSplay}. 
\begin{figure}[h]
	\centering
	\includegraphics[width= 0.8\textwidth]{"Medien/Multisplay/referenzTree"}
	\caption {Referenzbaum mit grün gezeichneten preferred paths }
	\label{fig:referenzTree}
\end{figure} 
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Multisplay/pfadRepresentation"}
	\caption {Beispielhafter Multisplay Baum zu Abbildung \ref{fig:referenzTree}.}
	\label{fig:pfadRepresentation}
\end{figure} 
\paragraph{Die \textit{access} Operation beim Multisplay Baum}
Zu beachten ist, dass jede BST Darstellung auch eine Splay Baum Darstellung ist. Anders als beim Tango oder Zipper Baum, muss ein neu erzeugter Hilfsbaum also nicht so angepasst werden, dass er weitere Invarianten einhält.  Nach einer \textit{access}$\left(k\right)$ Operation ist der Knoten $v_k$ mit dem Schlüssel $k$ die Wurzel von $T$. Zunächst wird eine gewöhnliche Suche in $T$ durchgeführt, bis der Zeiger $p$ der Operation auf $v_k$ zeigt. Ist $v_k$ gefunden, werden die Pfadrepräsentationen aktualisiert. Hierzu muss der Hilfsbaum, der die Wurzel von $T$ enthält neu erzeugt werden. \\



\begin{figure}[h]
	\centering
	\includegraphics[width= 0.8\textwidth]{"Medien/Multisplay/keySpace"}
	\caption {Beispielhafte Zusammenhänge der Schlüsselgrößen. $U$ ist blau dargestellt, $L$ lila, $R$ rot und $q_i$ gelb. }
	\label{fig:keySpace}
\end{figure} 

\newpage
\bibliography{literaturverzeichnis}
\bibliographystyle{unsrt}

\end {document}