\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[ngerman,german]{babel}
\usepackage[T1]{fontenc}
\usepackage{courier}
\usepackage{float}
\usepackage{amsmath,amsthm}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{csquotes}
\usepackage[font=small,labelfont=bf]{caption}

%\usepackage[pages=some]{background} % Draft Wasserzeichen mit Option pages=all sonst pages=some



\title{Bachelorarbeit}
\author{
	Andreas Windorfer\\
}
\date{\today}


\begin {document}


\maketitle
\newpage

\newpage
\tableofcontents


\newpage


\section{Multisplay Baum}
Der Multisplay Baum ist eine Variation zum Tango Baum. Ein preferred path wird hier durch einen Splaybaum dargestellt. Amortisiert betrachtet, ist er $\log\left(\log\left(n\right)\right)$-competitive und garantiert $O\left(\log \left(n\right)\right)$ im worst case, bei einer einzelnen {\textit{access}} Operation. $n$ steht wieder für der Anzahl der Knoten von $T$. Da der Splaybaum kein balancierter Baum ist, gibt es zusätzliche mögliche Zustände im Vergleich zu einem Tango Baum mit der gleichen Knotenzahl.
\begin{figure}[h]
	\centering
	\includegraphics[width= 0.8\textwidth]{"Medien/Multisplay/referenzTree"}
	\caption {Refernzebaum mit grün gezeichneten preferred paths }
	\label{fig:referenzTree}
\end{figure} 
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Multisplay/pfadRepresentation"}
	\caption {Refernzebaum mit grün gezeichneten preferred paths }
	\label{fig:referenzTree}
\end{figure} 
Auch der Multisplay Baum verwendet einige Hilfsdaten je Knoten. Zum einen bereits bekannte Variablen bzw. Konsanten \textit{isRoot}, \textit{depth} und \textit{minDepth}. Aber auch welche die beim Tango Baum nicht verwendet sind. Sei $v$ ein Knoten in $T$ und $u$ der Knoten mit $\mathit{key}\left(v\right) = \mathit{key}\left(u\right)$ im Referenzbaum $P$. Sei $H$ der Hilfsbaum der $v$ enthält. Die Konstante \textit{height} hat den Wert der Höhe von $u$. Die Variable \textit{treeSize} enthält die Anzahl der Knoten von $H$.   
 \subsection{Die \textit{access} Operation beim Multisplay Baum}
 Zu beachten ist, dass jede BST Darstellung auch eine Splaybaum Darstellung ist. Anders als beim Tango oder Zipper Baum, muss ein neu erzeugter Hilfsbaum also nicht so angepasst werden, dass er weitere Invarianten einhält.  Sei $v$ ein Knoten in $T$, dann wird mit $v^*$  wieder der Knoten in $P$ bezeichnet, mit $\mathit{key}\left(v\right) = \mathit{key}\left(v^*\right)$.  Nach einer \textit{access}$\left(k\right)$ Operation ist der Knoten $v_k$ mit dem Schlüssel $k$ die Wurzel von $T$. Zunächst wird eine gewöhnliche Suche in $T$ durchgeführt, bis der Zeiger $p$ der Operation auf $v_k$ zeigt. Eine Abweichung zu den preferred path des Tango Baum ist, dass das preferred child des Knoten mit Schlüssel $k$ zunächst unverändert bleibt. Ist $v_k$ gefunden, werden die Pfadrepräsentationen aktualisiert. Dabei wird bottom up vorgegangen. Damit $v_k$ zur Wurzel von $T$ wird, wechselt das preferred child von ${v_k}^*$ immer. Das ist ein Unterschied zum Tango Baum, bei dem dieses nur wechselt, wenn zu Beginn das rechte Kind das preferred child war. Die aufgrund von ${v_k}^*$ notwendige Aktualisierung der Pfadrepräsentation wird als letztes durchgeführt. In den Beschreibungen von \textit{cut} und \textit{join} wird von einem zugrunde liegenden preferred child Wechsel vom linken Kind zum Rechten ausgegangen. Der andere Fall ist symmetrisch.\\ 
 \noindent Sei $P_p = {q_1}^*, {q_2}^*,.., {q_m}^*$ ein preferred path und ${q_i}^*$, mit $i m\in \{1, 2,..,m\}$, der Knoten  an dem das preferred child wechselt. Sei $k$ der Schlüssel von $q_i$. Sei $A$ der Hilfsbaum der $P_p$ repräsentiert. Sei $U~=~\{q_1, q_2,.., q_i\}$  und $L= \{q_{i+1}, q_{i+2},..,q_m\}$.  Sei $q_r$ das rechte Kind von $q_i$ und $B$ der Hilfsbaum in dem $q_r$ enthalten ist.
 


 
\paragraph{\textit{cutJoin} Operation beim Multisplay Baum}
Beim Multisplay Baum werden \textit{cut} und \textit{join} zu einer Operation zusammengefasst. Abbildung \ref{fig:keySpace} stellt die Zusammenhänge der Schlüssel dar. Das Vorgehen ist sehr ähnlich zu dem aus \ref{TangoCut} sehr ähnlich, weshalb hier weniger detailliert darauf eingegangen wird.
Zunächst wird die \textit{isRoot} Variable von der Wurzel von $A$ auf \textit{false} gesetzt und \textit{splay}$\left(k\right)$ auf $A$ ausgeführt. Dadurch entsteht ein Hilfsbaum $C$ mit Wurzel $q_i$ Sei $C_L$ der linke Teilbaum von $q_i$ und $C_R$ der Rechte.\\
 Es wird der Knoten $q_{l'}$, mit dem kleinsten Schlüssel $l' > \textit{key}\left(q_i\right)$, aus $U$ benötigt.  $q_{l'}^*$ muss eine kleinere Tiefe als  $q_i^*$ haben. Deshalb kann $q_{l'}^*$ gefunden werden indem  wie folgt vorgegangen wird. $p$ muss auf die Wurzel von $C_L$ gesetzt werden. In einer Schleife wird $p$ so oft auf das linke Kind $p_l$ von $p$ gesetzt, bis der Wert der \textit{minDepth} Variable von $p_l$ größer als die Tiefe von $q_i^*$  ist.\\
 Nun wird \textit{splay}$\left(l'\right)$ auf $C_l$ ausgeführt. Nach dieser Operation muss bei der Wurzel des rechten Teilbaumes von $q_{l'}$ \textit{isRoot} noch auf \textit{true} gesetzt werden. Abbildung \ref{fig:split} stellt es nochmals dar. Existiert  $q_{l'}$ nicht, entfällt die zweite \textit{splay} Operation und es wird \textit{isRoot} der Wurzel von $C_L$ auf \textit{true} gesetzt. Der \textit{cut}-Teil ist nun abgeschlossen und wir kommen zum \textit{join}-Teil. \\
 Es wird der Knoten $q_{r'}$, mit dem kleinsten Schlüssel $r' > \textit{key}\left(q_i\right)$, aus $U$ benötigt.  $q_{r'}^*$ muss eine kleinere Tiefe als  $q_i^*$ haben. Deshalb kann $q_{r'}^*$ gefunden werden indem  wie folgt vorgegangen wird. $p$ muss auf die Wurzel von $C_R$ gesetzt werden. In einer Schleife wird $p$ so oft auf das rechte Kind $p_r$ von $p$ gesetzt, bis der Wert der \textit{minDepth} Variable von $p_r$ größer als die Tiefe von $q_i^*$  ist.\\
 Es wird \textit{splay}$\left(r'\right)$ auf $C_R$ ausgeführt. Nun wird der linke Teilbaum $D_L$ von $q_r$ betrachtet. Jeder Knoten aus $R$ muss in $D_L$ enthalten sein, denn für $v_R \in R$ gilt $k < \mathit{key}\left(v_R\right) < r'$. Kein Knoten aus $L \cup U$ kann in $D_L$ enthalten sein, da für $v_L \in  L$,  $ \mathit{key}\left(v_L\right) < k$ und für  für $v_U \in  U$,  $ \mathit{key}\left(v_U\right) > r'$ gilt. Somit muss das linke Kind von $q_{r'}$ die Wurzel von $B$ sein. Die \textit{isRoot} Variable dieses Knotens wird auf \textit{false} gesetzt.
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Multisplay/split"}
	\caption {Ablauf zum erzeugen einer neuen Pfadrepräsentation, nach einem preferred child Wechsel vom linken Kind zum Rechten.}
	\label{fig:split}
\end{figure} 



\newpage
\bibliography{literaturverzeichnis}
\bibliographystyle{unsrt}

\end {document}

