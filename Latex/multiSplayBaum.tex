\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[ngerman,german]{babel}
\usepackage[T1]{fontenc}
\usepackage{courier}
\usepackage{float}
\usepackage{amsmath,amsthm}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{csquotes}
\usepackage[font=small,labelfont=bf]{caption}

%\usepackage[pages=some]{background} % Draft Wasserzeichen mit Option pages=all sonst pages=some



\title{Bachelorarbeit}
\author{
	Andreas Windorfer\\
}
\date{\today}


\begin {document}


\maketitle
\newpage

\newpage
\tableofcontents


\newpage


\section{Multisplay Baum}
Der Multisplay Baum \cite{multisplay} $T$ ist eine Variation zum Tango Baum. Ein preferred path wird hier durch einen Splaybaum dargestellt. Amortisiert betrachtet, ist er $\log\left(\log\left(n\right)\right)$-competitive und garantiert $O\left(\log \left(n\right)\right)$ im worst case, bei einer einzelnen {\textit{access}} Operation. $n$ steht wieder für der Anzahl der Knoten von $T$. Da der Splaybaum kein balancierter Baum ist, gibt es zusätzliche mögliche Zustände im Vergleich zu einem Tango Baum mit der gleichen Knotenzahl.
\begin{figure}[h]
	\centering
	\includegraphics[width= 0.8\textwidth]{"Medien/Multisplay/referenzTree"}
	\caption {Refernzebaum mit grün gezeichneten preferred paths }
	\label{fig:referenzTree}
\end{figure} 
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Multisplay/pfadRepresentation"}
	\caption {Beispielhafter Multisplay Baum zu Abbildung \ref{fig:referenzTree}.}
	\label{fig:pfadRepresentation}
\end{figure} 
Auch der Multisplay Baum verwendet einige Hilfsdaten je Knoten. Zum einen bereits bekannte Variablen bzw. Konsanten \textit{isRoot}, \textit{depth} und \textit{minDepth}. Aber auch eine die beim Tango Baum nicht verwendet sind. Sei $v$ ein Knoten in $T$, dann wird mit $v^*$  wieder der Knoten im Referenzbaum $P$ bezeichnet, mit $\mathit{key}\left(v\right) = \mathit{key}\left(v^*\right)$. Jeder Knoten $v$ in $T$ enthält eine \textit{prefChild} Variable, mit der gespeichert welches Kind von $v^*$, das preferred child ist. 
 \subsection{Die \textit{access} Operation beim Multisplay Baum}
 Zu beachten ist, dass jede BST Darstellung auch eine Splaybaum Darstellung ist. Anders als beim Tango oder Zipper Baum, muss ein neu erzeugter Hilfsbaum also nicht so angepasst werden, dass er weitere Invarianten einhält.  Nach einer \textit{access}$\left(k\right)$ Operation ist der Knoten $v_k$ mit dem Schlüssel $k$ die Wurzel von $T$. Zunächst wird eine gewöhnliche Suche in $T$ durchgeführt, bis der Zeiger $p$ der Operation auf $v_k$ zeigt. Eine Abweichung zu den preferred path des Tango Baum ist, dass das preferred child des Knoten mit Schlüssel $k$ zunächst unverändert bleibt. Ist $v_k$ gefunden, werden die Pfadrepräsentationen aktualisiert. Dabei wird bottom up vorgegangen. Nach dem aktualisieren der Pfadrepräsentationen muss noch \textit{splay}$\left(k\right)$ ausgeführt werden, um $v_k$ zur Wurzel von $T$ zu machen. In den Beschreibungen von \textit{cut} und \textit{join} wird von einem zugrunde liegenden preferred child Wechsel vom linken Kind zum Rechten ausgegangen. Der andere Fall ist symmetrisch.\\ 
 \noindent Sei $P_p = {q_1}^*, {q_2}^*,.., {q_m}^*$ ein preferred path und ${q_i}^*$, mit $i \in \{1, 2,..,m\}$, der Knoten  an dem das preferred child wechselt. Sei $k$ der Schlüssel von $q_i$. Sei $A$ der Hilfsbaum der $P_p$ repräsentiert. Sei $U~=~\{q_1, q_2,.., q_i\}$  und $L= \{q_{i+1}, q_{i+2},..,q_m\}$.  Sei $q_r$ das rechte Kind von $q_i$ und $B$ der Hilfsbaum in dem $q_r$ enthalten ist.
 


 
\paragraph{\textit{cutJoin} Operation beim Multisplay Baum}
Beim Multisplay Baum werden \textit{cut} und \textit{join} zu einer Operation zusammengefasst. Abbildung \ref{fig:keySpace} stellt die Zusammenhänge der Schlüssel dar. Das Vorgehen ist sehr ähnlich zu dem aus \ref{TangoCut} sehr ähnlich, weshalb hier weniger detailliert darauf eingegangen wird. Es wird in der Beschreibung von einem Wechsel des preferred child von links nach rechts ausgegangen.
Zunächst wird die \textit{isRoot} Variable von der Wurzel von $A$ auf \textit{false} gesetzt und \textit{splay}$\left(k\right)$ auf $A$ ausgeführt. Dadurch entsteht ein Hilfsbaum $C$ mit Wurzel $q_i$ Sei $C_L$ der linke Teilbaum von $q_i$ und $C_R$ der Rechte.\\
 Es wird der Knoten $q_{l'}$, mit dem kleinsten Schlüssel $l' > \textit{key}\left(q_i\right)$, aus $U$ benötigt. Es wird angenommen, dass dieser existiert. Auf den anderen Fall wird noch eingegangen. $q_{l'}^*$ muss eine kleinere Tiefe als  $q_i^*$ haben. Deshalb kann $q_{l'}^*$ gefunden werden indem  wie folgt vorgegangen wird. $p$ muss auf die Wurzel von $C_L$ gesetzt werden. In einer Schleife wird $p$ so oft auf das linke Kind $p_l$ von $p$ gesetzt, bis der Wert der \textit{minDepth} Variable von $p_l$ größer als die Tiefe von $q_i^*$  ist.\\
 Nun wird \textit{splay}$\left(l'\right)$ auf $C_l$ ausgeführt. Ist der rechte Teilbaum $D_R$ von $q_{l'}$ nicht leer,  muss bei seiner Wurzel \textit{isRoot} noch auf \textit{true} gesetzt werden. Abbildung \ref{fig:split} stellt es nochmals dar. Existiert  $q_{l'}$ nicht, entfällt die zweite \textit{splay} Operation und es wird \textit{isRoot} der Wurzel von $C_L$ auf \textit{true} gesetzt. Der \textit{cut}-Teil ist nun abgeschlossen und wir kommen zum \textit{join}-Teil. \\
 Es wird der Knoten $q_{r'}$, mit dem kleinsten Schlüssel $r' > \textit{key}\left(q_i\right)$, aus $U$ benötigt. Wieder wird angenommen, dass dieser existiert.  $q_{r'}^*$ muss eine kleinere Tiefe als  $q_i^*$ haben. Deshalb kann $q_{r'}^*$ gefunden werden indem  wie folgt vorgegangen wird. $p$ muss auf die Wurzel von $C_R$ gesetzt werden. In einer Schleife wird $p$ so oft auf das rechte Kind $p_r$ von $p$ gesetzt, bis der Wert der \textit{minDepth} Variable von $p_r$ größer als die Tiefe von $q_i^*$  ist.\\
 Es wird \textit{splay}$\left(r'\right)$ auf $C_R$ ausgeführt. Nun wird der linke Teilbaum $D_L$ von $q_r$ betrachtet. Jeder Knoten aus $R$ muss in $D_L$ enthalten sein, denn für $v_R \in R$ gilt $k < \mathit{key}\left(v_R\right) < r'$. Kein Knoten aus $L \cup U$ kann in $D_L$ enthalten sein, da für $v_L \in  L$,  $ \mathit{key}\left(v_L\right) < k$ und für  für $v_U \in  U$,  $ \mathit{key}\left(v_U\right) > r'$ gilt. Somit muss das linke Kind von $q_{r'}$ die Wurzel von $B$ sein. Die \textit{isRoot} Variable dieses Knotens wird auf \textit{false} gesetzt.
\begin{figure}[h]
	\centering
	\includegraphics[width= 0.8\textwidth]{"Medien/Multisplay/keySpace"}
	\caption {Beispielhafte Zusammenhänge der Schlüsselgrößen. $U$ ist blau dargestellt, $L$ lila, $R$ rot und $q_i$ gelb. }
	\label{fig:keySpace}
\end{figure} 
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Multisplay/split"}
	\caption {Ablauf zum erzeugen einer neuen Pfadrepräsentation, nach einem preferred child Wechsel vom linken Kind zum Rechten.}
	\label{fig:split}
\end{figure} 
\noindent Ist $q_{l'}$ bzw. $q_{r'}$ nicht vorhanden, sind in $C_L$ bzw. $C_R$ keine Knoten aus $U$ enthalten und die jeweilige \textit{splay} Operation kann entfallen. Aufgrund der Laufzeit, darf aber nach diesen Knoten nur gesucht werden, wenn sie vorhanden sind. Nach Durchführung der ersten \textit{splay} Operation  kann auf die Existenz dieser Knoten geschlossen werden. Es wird die Vorgehensweise zu  $q_{l'}$ beschrieben, die zu  $q_{r'}$ ergibt sich daraus. Es muss $q_{l'}.$\textit{depth} $>$ $q_{l'}.$\textit{depth} gelten. Ist die \textit{minDepth} Variable des linken Kindes von $v_k$ kleiner als $q_{l'}.$\textit{depth} muss $q_{l'}$ existieren, ansonsten kann er nicht existieren. 

\subsection{Amortisierte Laufzeitanalyse}
Sei $v$ ein Knoten im Multisplay Baum $T$ und $H$ der Hilfsbaum der $v$ enthält. Eine Funktion $w\left(v\right)$ liefert zu jedem Knoten eine reelle Zahl $>0$, die Gewicht genannt wird. Eine Funktion $\mathit{tw}\left(v\right)$ bestimmt die Summe aller Gewichte, der Knoten die im Teilbaum mit Wurzel $v$ und in $H$ enthalten sind. Der Rang  $r\left(v\right)$ ist definiert durch $r\left(v\right) = \log_2  \mathit{tw}\left(v\right)$. Sei $V$ die Menge der Knoten von $T$. Als Potentialfunktion wird 
\begin{align*}
\Phi = \sum_{v \in V} r\left(v\right)
\end{align*}
verwendet.

Beim Generalized Access Lemma verallgemeinert das Access Lemma vom Splay Baum. \textit{splay}$\left(k\right)$ stoppt normalerweise erst, wenn der Knoten $v_k$ mit Schlüssel $k$ die Wurzel bildet. Sie kann aber ganz einfach modifiziert werden, so dass sie $v_k$ zu einem Knoten mit Tiefe $d$ macht, mit $v_k.$\textit{depth} $> d $.

\newtheorem{Lemma1}{Generalized Access Lemma}[section] 
\begin{Lemma1}Sei $T$ ein Multisplay Baum. Sei $v$ ein Knoten im Hilfsbaum $H$ von $T$. $H$ enthalte $n$ Knoten Sei $u$ ein Vorfahre von $v$ in $H$. Es wird eine (modifizierte) \textit{splay} Operation verwendet, so dass $v'.$\textit{depth} $=$ $u.$\textit{depth} gilt.  Die amortisierte Kosten dafür von \textit{splay}$\left(k\right)$ ist maximal $3 \left(r\left(u\right) - r\left(v\right)\right) + 1 = O\left(\log\left(\mathit{tw}\left(u\right)\right)  / \mathit{tw}\left(v\right) \right) = O\left(\log\left(n\right)\right)$ \\	
\end{Lemma1}
\begin{proof}
Folgt direkt aus \ref{splayAccess}. Dass $u$ die Wurzel ist wird dort nicht verwendet. 	
	
\end{proof}
\newtheorem{Lemma2}{Multisplay Baum Access Lemma}[section] \label{lemmaMultiSplay}

\noindent Im nächsten Lemma geht es um die Gesamtzugriffszeit einer \textit{access} Operation beim Multisplay Baum $T$ mit Referenzbaum $P$. Sei $p^*$ ein Knoten in $P$. Es werden zwei Funktionen benötigt. $\mathit{des}\left(p^*\right)$ liefert die Menge der Nachfahren von $p^*$.  $\mathit{pa}\left(p^*\right)$ liefert die Menge der Pfade von $p^*$ zu einem Blatt. An die Gewichtsfunktion werden zwei Bedingungen gestellt. Sei $f \geq 2$.
\begin{itemize}
	\item $w\left(p^*\right) \geq \max \{  w\left(v^*\right)\vert  v^*
	\in\mathit{des}\left(p^*\right)  \}$
	\item $f  w\left(p^*\right) \geq    \max \{  \sum_{v^* \in P_p }  w\left(v^*\right)\vert    P_p \in \mathit{pa}\left(p^*\right) \}  $
\end{itemize}
\begin{Lemma2}
	
\end{Lemma2}
\begin{proof}
	
	
\end{proof}

\newpage
\bibliography{literaturverzeichnis}
\bibliographystyle{unsrt}

\end {document}

