\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[ngerman,german]{babel}
\usepackage[T1]{fontenc}
\usepackage{courier}
\usepackage{float}
\usepackage{amsmath,amsthm}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{csquotes}
\usepackage[font=small,labelfont=bf]{caption}

%\usepackage[pages=some]{background} % Draft Wasserzeichen mit Option pages=all sonst pages=some



\title{Bachelorarbeit}
\author{
Andreas Windorfer\\
}
\date{\today}

\begin {document}



\maketitle
\newpage

\tableofcontents
\newpage

\section{Tango Baum}
Der Tango Baum ist ein aus BSTs, den \textbf{Hilfsbäumen}, bestehender BST. Auf die Anforderungen an die Hilfsbäume wird in Abschnitt \ref{aufbauDesTango} eingegangen und mit dem Rot-Schwarz-Baum wird eine mögliche Variante noch detailliert vorgestellt. Der Tango Baum wurde in \cite{demainDinamicOpti},von Demaine, Harmon, Iacono und Patrascu beschrieben, inklusive eines Beweises über seine $\mathit{lg} \, \mathit{lg} \, n $-competitiveness. Ebenfalls in \cite{demainDinamicOpti} enthalten ist eine als \textbf{Interleave Lower Bound} bezeichnete Variation der ersten unteren Schranke von Wilber. Da diese für das Verständnis des Tango Baumes wesentlich ist, wird mit ihr gestartet, bevor es zur Beschreibung der Struktur selbst kommt. 


\subsection{Interleave Lower Bound} \label{interBound}
  Sei $X$ eine Zugriffsfolge und sei $K = \{k \in \mathbb{N} \vert k \textit{ ist in X enthalten}\}$. Auch hier wird ein lower bound tree verwendet, dieser ist jedoch etwas anders definiert als in Abschnitt \ref{wilber bound}. Hier ist der lower bound tree $Y$ zu einer Zugriffsfolge $X$, der komplette BST mit Schlüsselmenge $K$. Anders als in Abschnitt \ref{wilber bound}  gibt es hier somit zu jeder Zugriffssequenz nur genau einen lower bound tree. Abbildung \ref{fig:demlowerBoundTree} zeigt den lower bound tree zur Zugriffsfolge $1, 2,.., 15$. Zu jedem Knoten $v$ in $Y$ werden zwei Mengen definiert. Die \textbf{linke Region} von $v$ enthält den Schlüssel von $v$, sowie die im linken Teilbaum von $v$ enthaltenen Schlüssel.  Die \textbf{rechte Region} von $v$ enthält die im rechten Teilbaum von $v$ enthaltenen Schlüssel. Sei $l$ der kleinste Schlüssel im Teilbaum mit Wurzel $v$ und $r$ der größte. Sei $X = x_1,x_2,.,x_m$ die Zugriffssequenz und $X^r_l = {x_{1'},x_{'2},..,x_{jm'}}$ wie in Abschnitt \ref{wilbr bound} definiert. $i \in \{2,3,..,m'\}$ ist ein \enquote{\textbf{Interleave} durch $v$} wenn $x_{\left(i -1\right)}$ in der linken Region von $v$ liegt und $x_i$ in der rechten Region von $v$, oder umgekehrt. In $Y$ sind Knoten enthalten, bei denen die rechte Region leer ist. Durch diese kann es keinen Interleave geben. Sei $U$ die Menge der Knoten von $Y$, mit einer nicht leeren rechten Region. Sei \textit{inScore($v$)} die Funktion die zu dem Knoten $v \in U$ die Anzahl der Interleaves durch $v$ zurückgibt.  Die Funktion \textit{IB$\left(X\right)$} ist definiert durch:
\begin{align*}
\mathit{IB}\left(X\right) = \sum_{u \in U} \mathit{inScore}\left(u\right)
\end{align*}

Sei $T_0$ der BST mit Schlüsselmenge $K$ auf $X$ ausgeführt wird. Für $i \in \{1,2,..,m\}$ sei $T_i$ der BST, der entsteht nachdem \textit{access}$\left(x_i\right)$ auf $T_{i-1}$ ausgeführt wurde. Zu $u \in U$ und  $j \in \{0,1,..,m\}$ gibt es einen \textbf{transition point} $v$ in $T_j$. $v$ ist ein Knoten mit folgenden Eigenschaften:\\
\begin{enumerate}
	\item Der Pfad von der Wurzel von $T_j$ zu $v$ enthält einen Knoten dessen Schlüssel in der linken Region von $u$ enthalten ist.
	\item Der Pfad von der Wurzel von $T_j$ zu $v$ enthält einen Knoten dessen Schlüssel in der rechten Region von $u$ enthalten ist.
	\item In $T_i$ ist kein Knoten mit Eigenschaft 1 und 2 enthalten, der eine kleinere Tiefe als $v$ hat. 
\end{enumerate}
\begin{figure}[h]
 	\centering
	\includegraphics[width=1\textwidth]{"Medien/Tango/lowerBoundTree"}
 	\caption{Der lower bound tree zur Zugriffsfolge $1 ,2, .., 15$  }
	\label{fig:demlowerBoundTree}
 \end{figure}

\noindent Im Beweis dieses Abschnittes wird gezeigt das $\mathit{OPT}\left(X\right) \geq \frac{\mathit{IB}\left(X\right)}{2} - n$ gilt, wobei $n$ die Anzahl der Knoten im lower bound tree ist. Dafür werden jedoch noch drei Lemmas zu den Eigenschaften von $Y$ benötigt. 
\newtheorem{Lemma1}{Lemma}[section] 
\begin{Lemma1} \label{demaineLemma1}
Sei $X = x_1,x_2,..,x_m$ eine Zugriffssequenz und $Y$ ein zu $X$ erstellter lower bound tree mit Schlüselmenge $K$. Sei $T_0$ der BST mit Schlüsselmenge $K$ auf dem $X$ ausgeführt wird. Für $i \in \{1,2,..,m\}$ sei $T_i$ der BST der durch Ausführen von \textit{access}$\left(x_i\right)$ auf $T_{\left(i-1\right)}$ entsteht. Sei $U$ die Menge der Knoten von $Y$. Dann gibt es zu jedem Knoten $u \in U$ und $j \in \{0,1,..,m\}$ genau einen transition point in $T_j$. 	
\end{Lemma1}


\begin{proof}
Sei $l$ der kleinste Schlüssel in der linken Region von $u$ und $r$ der Größte. Im Teilbaum mit Wurzel $u$ sind genau die Schlüssel $K^r_l = \{k \in K \vert k \in \left[l,r\right]\}$ enthalten. Sei $v_l$ der gemeinsame Vorfahre aller Knoten mit einem Schlüssel aus der linken Region von $u$ in $T_j$, mit der größten Tiefe. Sei $v_r$ der gemeinsame Vorfahre aller Knoten mit einem Schlüssel aus der rechten Region von $u$ in $T_j$, mit der größten Tiefe. $\mathit{key\left(l\right)}$ bzw. $\mathit{key\left(r\right)}$ muss selbst in der linken bzw. rechten Region von $u$ enthalten sein, vergleiche \ref{wilberLowerBoundTree}. Sei $w$ der gemeinsame Vorfahre aller Schlüssel aus der linken und der rechten Region von $u$ in $T^r_l$ mit der größten Tiefe. Es muss $\mathit{key}\left(w\right) \in \left[l,r\right]$ gelten. Somit muss  $\mathit{key}\left(w\right)$ entweder in der linken oder rechten Region von $u$ enthalten sein. Da $w$ der Knoten mit der größten Tiefe sein muss, für den  $\mathit{key\left(w\right)} \in \left[l,r\right]$  gilt, muss entweder $w = v_l$ oder $w = v_r$ gelten, je nachdem wessen Tiefe kleiner ist. Für den Fall $w = v_l$ ist $v_r$ der transition point in $T_j$ zu $u$ und für den Fall $w = v_r$ ist es $v_l$.
Es wird der Fall $w = v_l$ betrachtet, der andere kann direkt daraus abgeleitet werden. Im Pfad $P_u = v_0,v_1,..,v_r$ von der Wurzel $v_0$ zu $v_r$ ist $v_l$ enthalten und da $v_r$ ein gemeinsamer Vorfahre der Schlüssel aus der rechten Region von $u$ ist muss $v_r$ der einzige Knoten mit einem Schlüssel aus der rechten Region von $u$ in $P_u$ sein. Jeder Pfad $P$ in $T_j$ von der Wurzel zu einem Knoten mit einem Schlüssel aus der rechten Region von $u$ muss mit $v_0,v_1,..,v_r$ beginnen, somit kann es keinen weiteren transition point für $u$ in $T_j$ geben. 
	
\end{proof}
\noindent Der Knoten auf den der Zeiger $p$ zum ausführen von \textit{access} gerade zeigt wird als \textbf{berührter} Knoten bezeichnet.
 Im zweiten Lemma geht es darum, dass sich der transition point $v$ eines Knoten nicht verändern kann, solange $v$ nicht wenigstens einmal der berührte Knoten war. In den zwei verbleibenden Lemmas und dem Satz seien  $T_j$, $X$, $Y$, $U$ und $u$ wie in  Lemma \ref{demaineLemma1} definiert. 



\newtheorem{Lemma2}{Lemma}[section] \label{lemmaDemaine2}
\begin{Lemma2} \label{demaineLemma2}
Sei $v$ der transition point zu $u$ in $T_j$.  Sei  $l \in \mathit{N}$, mit $j < l \leq m$. Gilt für alle $x_i$, mit $i \in \left[j,l\right]$, während der Ausführung von \textit{access}$\left(x_i\right)$,  $v$ war nicht wenigstens einmal der berührte Knoten, dann ist $v$ während der gesamten Ausführungszeit von $\textit{access}\left(x_j\right),\textit{access}\left(x_{j+1}\right),..,\textit{access}\left(x_l\right)$ der transition point zu $u$ in $T_l$. 
\end{Lemma2}

\begin{proof}
 Sei $v_l$ der gemeinsame Vorfahre aller Knoten mit einem Schlüssel aus der linken Region von $u$ in $T_j$, mit der größten Tiefe. Sei $v_r$ der gemeinsame Vorfahre aller Knoten mit einem Schlüssel aus der rechten Region von $u$ in $T_j$, mit der größten Tiefe. Hier wird wieder ohne Verlust der Allgemeinheit der Fall $v = v_r$ betrachtet. Da $v_r$ nicht berührt wird, wird auch kein Knoten in der rechten Region von $u$ berührt. $v_r$ ist somit während der gesamten Ausführungszeit von $\textit{access}\left(x_j\right),\textit{access}\left(x_{j+1}\right),..,\textit{access}\left(x_l\right)$  der gemeinsame Vorfahre der Schlüssel aus der rechten Region von $u$ mit der größten Tiefe. Knoten mit Schlüssel in der linken Region von $u$ könnten berührt werden. Zu einem Ausführungszeitpunkt $t$ kann deshalb ein Knoten $v_{li} \ne v_l$ mit einem Schlüssel aus der linken Region von $u$ der gemeinsame Vorfahre der Knoten mit diesen Schlüsseln mit der größten Tiefe sein. Da $v_r$ nicht berührt wird kann zu keinem Zeitpunkt $v_l$ im Teilbaum mit Wurzel $v_r$ enthalten sein. Somit kann auch $v_{lt}$ nicht in diesem Teilbaum enthalten sein. Somit muss die Tiefe von  $v_{lt}$ kleiner sein, als die von $v_r$ und $v_r$ bleibt der transition point von $u$. 
\end{proof}

\noindent Im dritten Lemma wird gezeigt dass ein Knoten $v$ in $T_j$ nur der transition point zu einem Knoten aus $U$ sein kann.

\newtheorem{Lemma3}{Lemma}[section] \label{lemmaDemaine3}
\begin{Lemma3}
	Sei $u_1, u_2 \in U$, mit $u_1 \ne u_2$.  Sei $v$ ein Knoten in $T_j$. $v$ kann nicht sowohl der transition point von $u_1$, als auch der von $u_2$ sein.
\end{Lemma3}

\begin{proof}
 Sei $v_l$ bzw. $v_r$ der gemeinsame Vorfahre aller Knoten mit einem Schlüssel aus der linken bzw. rechten Region von $u_1$ in $T_j$, mit der größten Tiefe.  Sei $w_l$ bzw. $w_r$ der gemeinsame Vorfahre aller Knoten mit einem Schlüssel aus der linken bzw. rechten Region von $u_2$ in $T_j$, mit der größten Tiefe. Ist weder $u_1$ ein Vorfahre von $u_2$ noch $u_2$ einer von $u_1$, dann muss auch $w_l \ne v_l \land w_l \ne v_r$ sowie $w_r \ne v_l \land w_r \ne v_r$ gelten, die Teilbäume mit Wurzel $u_1$ und $u_2$ dann über disjunkte Schlüsselmengen verfügen. Somit müssen die transition points von $u_1$ und $u_2$ unterschiedlich sein. Sei, ohne Verlust der Allgemeinheit, $u_1$ ein Vorfahre von $u_2$. werden drei Fälle unterschieden:
 \begin{enumerate}
 	\item Ist $mathit{key}\left(v_1\right)$ ist nicht im Teilbaum mit Wurzel $u_2$ enthalten, so kann $v_1$ nicht der transition point von $u_2$ sein.
 	\item $\mathit{key}\left(v_1\right)$ ist im Teilbaum mit Wurzel $u_2$ enthalten und $\mathit{key}\left(v_1\right)$ ist  in der linken Region von $u_1$ enthalten:\\
 	 Da $u_1$ Vorfahre von $u_2$ ist, müssen alle Schlüssel im Teilbaum mit Wurzel $u_2$ in der linken Region von $u_1$ enthalten sein. Da der Schlüssel von $v_1$ in der linken Region von $u_1$ liegt, muss $v_r$ ein Vorfahre von $v_l$ in $T_j$ sein.$\mathit{key}\left(v_1\right)$ muss somit der Schlüssel von $w_l$ bzw. $w_r$ sein, je nachdem wessen Tiefe kleiner ist. Denn andererseits könnte man einen Pfad von der Wurzel von $T_j$ zu $v_1$ angeben der zwei Knoten aus der linken Region von $u_1$ enthält, dass ist jedoch ein Widerspruch dazu, dass  $\mathit{key}\left(v_1\right)$ in der linken Region von $u_1$ enthalten ist und $v_1$ zudem der transition point für $u_1$ ist.\\
 	$v_2$ ist entweder der Knoten $w_l$ oder $w_r$ je nachdem wessen Tiefe größer ist, somit gilt $v_1 \ne v_2$.
	\item $\mathit{key}\left(v_1\right)$ ist im Teilbaum mit Wurzel $u_2$ enthalten und $\mathit{key}\left(v_1\right)$ ist in der rechten Region von $u_1$ enthalten:\\
	Symmetrisch zu Fall 2.
 \end{enumerate}
 
 

  


\end{proof}

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{"Medien/Tango/transitionPoints"}
	\caption{Transition point Zuordnung. Links ein lower bound tree, rechts ein möglicher $T_j$.   }
	\label{fig:transitionPoints}
\end{figure}


\newtheorem{Satz2}{Satz}[section] \label{satzDemaine1}
\begin{Satz2} 
Für eine Zugriffssequenz $X = x_1, x_2,.., x_m$ und $n$ die Anzahl der Knoten im zu $X$ erstellten lower bound tree. Dann gilt\\	
$\mathit{OPT}\left(X\right) \geq \mathit{IB}\left(X\right) /2 - n$ .
\end{Satz2}
\begin{proof}
Es wird die Mindestanzahl der Berührungen von transition points gezählt. Durch \ref{lemmaDemaine3} kann die Anzahl der Berührungen für jedes $y \in P$ einzeln bestimmt werden, diese müssen dann lediglich noch aufaddiert werden. Sei $l$, $r$, $v_r$ und $v_l$ wie in Lemma1 zu $y$ definiert, so dass entweder $l$ oder $r$ der transition point zu $y$ sein muss, je nachdem welcher der beiden Knoten die größere Tiefe hat ( \ref{lemmaDemaine1}). Sei $X{^r_l}' = x_{i_1},x_{i_2},..,x_{i_p}$ die Folge die entsteht, wenn aus $X^r_l$ alle $x_k$ entfernt werden, für die gilt $x_k$ ist in der gleichen Region von $y$ wie $x_{k-1}$. Nun wird angenommen, dass die $x_{j_i}$ mit $i$ ist gerade in der rechten Region von $y$ liegen, und die $x_{j_i}$ mit $i$ ist ungerade in der linken Region. Der andere Fall kann wieder direkt abgeleitet werden. Sei $q \in \mathbb{N}$ mit $1 \geq q \geq \lfloor p / 2 \rfloor$. \textit{access}$\left( x_{i_{2q-1}} \right)$ muss $v_l$ berühren und \textit{access}$\left( x_{i_{2q}} \right)$ muss $v_r$ berühren. Sei $k{i_{2q-1}}$ der Schlüssel des transition point von $y$ zu Beginn von \textit{access}$\left( x_{i_{2q-1}} \right)$ und  $k{i_{2q}}$ der Schlüssel des transition point von $y$ zu Beginn von \textit{access}$\left( x_{i_{2q}} \right)$. Gilt $k{i_{2q-1}} = k{i_{2q}}$ so muss der transition point von $y$ in \textit{access}$\left( x_{i_{2q}} \right)$ berührt worden sein.  Gilt $k{i_{2q-1}} \ne k{i_{2q}}$ so muss der transition point von $y$, nach \ref{demaineLemma2}, in \textit{access}$\left( x_{i_{2q-1}} \right)$ berührt worden sein. Aus der Konstruktion von $X{^r_l}'$ folgen daraus mindestens $\lfloor p/2 \rfloor \geq p/2 - 1$ Berührungen des transition point von $y$. Aufaddieren über alle Knoten ergibt  eine Anzahl von Berührungen von transition points von zumindest $\mathit{IB}\left(X\right) /2 - \vert U \vert \geq \mathit{IB}\left(X\right) /2 - n$.
	
\end{proof}


\subsection{Aufbau des Tango Baum} \label{aufbauDesTango}
Wie bereits erwähnt besteht ein Tango Baum $T$ mit Schlüsselmenge $K$ aus Hilfsbäumen. Eine Anforderung an einen Hilfsbaum mit $n$ Knoten ist, dass für seine Höhe $h = O\left(\log n\right)$ gilt. $T$ bietet lediglich eine \textit{access} Operation an. Ist $T$ also erst einmal für $K$ erzeugt, ist seine Schlüsselmenge unveränderlich. Sei $P$ der lower bound tree aus Abschnitt \ref{interBound} mit Schlüsselmenge $K$. $P$ ist kein Hilfsbaum und muss in Implementierungen auch nicht erstellt werden. Er dient aber dazu den Aufbau von $T$ vor und nach einer \textit{access} Operation zu veranschaulichen. Jeder innere Knoten $p$ in $P$ kann ein \textbf{preferred child} haben.  Wurde während der Ausführungszeit von $X$ noch keine \textit{access} Operation mit einem im Teilbaum mit Wurzel $p$ enthalten Schlüssel als Parameter ausgeführt, so hat $p$ kein preferred child. Ansonsten sei \textit{access}$\left(k\right)$ die zuletzt ausgeführte Operation mit einem Schlüssel der im Teilbaum mit Wurzel $p$ enthalten ist. Liegt $k$ in der linken Region von $p$, dann ist das linke Kind von $p$, das preferred child von $p$. Ist $k$ in der rechten Region von $p$ enthalten, dann ist das rechte Kind von $p$, das preferred child von $p$. Wir erweitern die Knoten von $P$ mit einer weiteren Variable \textit{prefChild} welche drei Werte annehmen kann. Sie enthält \textit{none} wenn ihr Knoten kein preferred Child besitzt, \textit{left} wenn das linke Kind das preferred child ist, ansonsten entsprechend \textit{right}. Hier kann man bereits die Kopplung zur interleave lower bound erkennen. Ein Wechsel von \textit{prefChild}  von \textit{left} zu \textit{right}, oder umgekehrt, findet genau dann statt, wenn es zu einem interleave durch den Knoten der Variable kommt. Abbildung \ref{fig:prefChilds} stellt einen möglichen Zustand von $P$ zwischen zwei \textit{access} Operationen dar. Dieser Zustand wird in diesem Abschnitt nun als durchgängiges Beispiel dienen. Man erkennt sofort, dass der Parameter der letzten \textit{access} Operation $8$, $4$, $2$ oder $1$ gewesen sein muss, da man von der Wurzel aus über preferred childs zu den Knoten mit diesen Schlüsseln gelangen kann. Die Schlüssel $10$ und $9$ können noch nie Parameter einer \textit{access} Operation gewesen sein, ansonsten müsste der Knoten mit dem Schlüssel $10$ ein preferred child haben. Mit Hilfe der preferred childs lassen sich die \textbf{preferred path} erstellen. Sei $v$ ein Knoten in $P$, der nicht preferred child eines anderen Knoten aus $P$ ist. Dann ist der preferred path zu $v$, der längst mögliche Pfad $v_0, v_1,..,v_l$, mit $v_0 = v$ und $\forall i \in \{1,2,..,l\} \colon v_i \textit{ ist preferred child von }v_{i-1   }$.  

 \begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{"Medien/Tango/prefChilds"}
	\caption{Die preferred childs werden durch die grünen Pfeile markiert. }
	\label{fig:prefChilds}
\end{figure}

 \noindent Nun werden die preferred path des BST aus Abbildung \ref{fig:prefChilds} angegeben, wobei der Schlüssel jeweils als Bezeichner für den ihn enthaltenden Knoten verwendet wird.
 \begin{align*}
&P_1 = 8, 4, 2,1 \\
&P_2 = 3 \\
&P_3 = 6, 7 \\
&P_4 = 5 \\
&P_5 = 11, 12 \\
&P_6 = 10 \\
&P_7 = 9
 \end{align*}

\noindent Da jeder Knoten nur preferred child eines Knoten sein kann und an Knoten die kein preferred child sind als Startknoten eines Pfades dienen, muss jeder Knoten in genau einem preferred Pfad enthalten sein.\\
Zu jedem preferred path gibt es einen Hilfsbaum der genau die Schlüssel enthält, die in den Knoten des Pfades enthalten sind. Da der Tango Baum den inneren Aufbau der Hilfsbäume nicht vorschreibt zeigt Abbildung \ref{fig:Hilfsbäume} nur eine mögliche Konstellation.
 

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{"Medien/Tango/Hilfsbäume"}
	\caption{Hilfsbäume zu den preferred path aus dem Beispiel. }
	\label{fig:Hilfsbäume}
\end{figure}
Sei $H$ die Menge der erstellten Hilfbäume aus $P$. Mit dem folgenden Verfahren können Hilfsbäume zu einem Tango Baum zusammengefügt werden:
\begin{enumerate}
	\item Gilt $\vert H \vert = 1$, dann ist das in $H$ enthaltene Element der Tango Baum und es wird abgebrochen.
	\item Wähle $h_1 \in H$ so, dass $h_1$ nicht den Schlüssel der Wurzel von $P$ enthält.
	\item Aufgrund der Konstruktion der preferred paths muss es genau einen Knoten $v$ in $h_1$ geben, so dass der Knoten $u$ in $P$ mit $\mathit{key}\left(v\right) = \mathit{key}\left(u\right) $ nicht preferred child seines Vaters ist.
	 Sei $h_2$ der Hilfsbaum, der den Schlüssel $\mathit{key}\left(u\right)$ enthält. Entferne $h_1$ und $h_2$ aus $H$.
	\item Sei $w_1$ die Wurzel von $h_1$. Sei $a$ der Knoten an dem die Standartvariante von \textit{einfügen} einen für Schlüssel  $\mathit{key\left(w_1\right)}$ erzeugten Knoten anfügen würde. Dann wird $h_1$ an $a$ angefügt. Aufgrund der Links-Rechts-Beziehung in BST, kann es nur eine Möglichkeit dafür geben. Sei $h_3$ der so entstandene BST.
	\item Füge $h_3$ zu $H$ hinzu, weiter mit $1$.
\end{enumerate}

\noindent Bei Punkt $4$ ist sofort ersichtlich, dass es durch $\mathit{key}\left(w_1\right)$ zu keiner Verletzung der Links-Rechts-Beziehung kommt. Wie sieht es aber mit bei den anderen Schlüsseln aus $h_1$ aus ? 
In $P$ sind alle in $h_1$ enthaltenen Schlüssel im Teilbaum mit Wurzel $u$ enthalten. Sei $l$ der kleinste Schlüssel in diesem Teilbaum und $r$ der Größte. In $P$ kann es außerhalb des Teilbaumes mit Wurzel $u$ keinen Schlüssel $k$ mit $l \leq k \leq r$ geben. $h_2$ kann nur Schlüssel enthalten die in $P$ aber nicht im Teilbaum mit Wurzel $u$ enthalten sind. Wird $w_1$ als linkes Kind eingefügt, so muss der Vorgänger von $a$ in $h_2$, falls vorhanden, einen Schlüssel haben der kleiner als $l$ ist.  Wird $w_1$ als rechtes Kind eingefügt, so muss der Nachfolger von $a$ in $h_2$, falls vorhanden, einen Schlüssel haben der größer als $r$ ist. Im Tango Baum kann es also keine Verletzung der Links-Rechts-Beziehung geben.



\noindent Abbildung \ref{fig:Tangobaum} zeigt unseren Tango Baum zum Beispiel. Die Wurzeln von Hilfsbäumen sind grün dargestellt.

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{"Medien/Tango/Tangobaum"}
	\caption{Tango Baum zu dem Beispiel. }
	\label{fig:Tangobaum}
\end{figure}
Nehmen wir an auf $T$ wird \textit{access}$\left(9\right)$ ausgeführt wird. Abbildung \ref{fig:prefChilds} zeigt den Zustand von $P'$.

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{"Medien/Tango/prefChilds2"}
	\caption{Preferred childs nach  \textit{access}$\left(9\right)$. }
	\label{fig:prefChilds2}
\end{figure}

Abbildung \ref{fig:TangoTree2} zeigt einen möglichen Zustand von $T'$.
\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{"Medien/Tango/Tangobaum2"}
	\caption{Tango Baum nach  \textit{access}$\left(9\right)$. }
	\label{fig:Tangobaum2}
\end{figure}

Im nächsten Abschnitt wird es vor allem darum gehen, wie eine Transformation, wie die von $T$ zu $T'$, effizient durchgeführt werden kann.

\subsection{Die \textit{access} Operation beim Tango Baum}
Die Knoten in einem Tango Baum sind mit zusätzlichen Daten erweitert. Sei $v$ ein Knoten im Tango Baum. Es gibt eine boolesche Variable \textit{isRoot} die genau dann Wert \textit{true} hat, wenn $v$ die Wurzel eines Hilfsbaumes ist. In einer Konstante \textit{depth} wird die Tiefe des Knoten mit Schlüssel $\mathit{key}\left(v\right)$ in $P$ gespeichert. Dann gibt es nach Variablen \textit{minDepth} und \textit{maxDepth}. Sei $v$ im Hilfsbaum $H$ enthalten und sei $H_v$ der Teilbaum mit Wurzel $v$ in $H$. Da $H$ die Schlüssel von Knoten aus einem preferred path enthält, können die \textit{depth} Konstanten zweier Knoten in $H$ nicht den gleichen Wert haben. Sei $\mathit{min}$ der kleinste Wert aller \textit{depth} Konstanten in $H_v$, dann entspricht $\mathit{min}$ dem  Wert der \textit{minDepth} Variable von $v$. Sei $\mathit{max}$ der größte Wert aller \textit{depth} Konstanten in $H_v$, dann entspricht $\mathit{max}$ dem  Wert der \textit{maxDepth} Variable von $v$.\\
Nun werden die Anforderungen an einen Hilfsbaum $H$ aufgezählt:
\begin{enumerate}
	\item Sei $n$ die Anzahl der Knoten von $H$. Für die Höhe $h$ von $H$ gilt $h = O\left(\log n\right)$.
	\item $H$ aktualisiert seine Zeiger auf andere Hilfsbäume.
	\item $H$ aktualisiert die Variablen  \textit{minDepth} und \textit{maxDepth}.
	\item $H$ bietet eine Operation \textit{vereinigen(HB $H_1$, Schlüssel $k$, HB  $H_2$)} an. HB ist eine Abkürzung für Hilfsbaum. Sei $K_1$ die Schlüsselmenge von $H_1$ und $K_2$ die von $H_2$. Die Operation kann verwenden, dass für $k_1 \in K_1$ und $k_2 \in K_2$, $k_1 < k < k_2$ gilt. Die Operation gibt die Wurzel eines Hilfsbaum  mit Schlüsselmenge $K_1 \cup K_2 \cup \{k\} $ zurück. Für die Laufzeit der Operation muss $O\left(\log \left(\vert K_1 \vert + \vert K_2 \vert\right)\right)$ gelten.
	\item $H$ bietet eine Operation \textit{aufteilen}(Schlüssel $k$) an Die Operation kann verwenden, dass in $H$ einen Knoten mit Schlüssel $k$ existiert. Sei $K$ die Schlüsselmenge von $H$. Die Operation gibt einen Knoten $v$ mit Schlüssel $k$ zurück. Das linke Kind von $v$ muss ein Hilfsbaum mit Schlüsselmenge ${K_l=\{i\in K \mid  i <k\}}$ sein. Das rechte Kind von $v$ muss ein Hilfsbaum mit Schlüsselmenge ${K_r=\{i\in K \mid  i > k\}}$ sein. Für die Laufzeit der Operation muss $O\left(\log \vert K \vert \right)$ gelten.
\end{enumerate} 
Jetzt werden noch zwei Hilfsoperationen vorgestellt, die für \textit{access} benötigt werden.\\

\paragraph{cut Operation}

\noindent \textit{cut(Tiefe $d$)} zerteilt einen Hilfsbaum $A$ in zwei Hilfsbäume $A_1$ und $A_2$. Es dürfen nur Werte für $d$ übergeben werden zu denen es in $A$ einen Knoten mit \textit{depth} $ = d $ gibt. Wobei die Knoten in $A$ bei denen \textit{depth} $\leq d$ gilt in $A_1$ enthalten sind und die mit \textit{depth} $ > d$ in $A_2$. Zunächst werden Knoten $l$,  $l'$, $r$ und $r'$ in $H$ gesucht. $l$ ist der Knoten in $H$ mit dem kleinsten Schlüssel für den \textit{depth} $> d$ gilt. $r$ ist der Knoten in $A$ mit dem größten Schlüssel für den \textit{depth} $> d$ gilt. $l'$ ist der Vorgänger von $l$ und $r'$ der Nachfolger von $r$. $l$ und $r$ müssen in $A$ enthalten sein, $l'$ und $r'$ könnten auch fehlen. $l$ kann wie folgt gefunden werden. Man startet mit dem Zeiger $p$ an der Wurzel von $A$. Zeigt $p$ nicht auf $l$, muss es im linken Teilbaum von $p$ einen Knoten mit \textit{depth} $> d$ geben, und das ist an der \textit{maxDepth} Variable des linken Kindes von $p$ direkt abfragbar. Ist $l$ erreicht , kann $l'$ über eine Suche des Vorgängers von $l'$ zu gefunden werden. Die Suche nach $r$ und $r'$ verläuft simultan. \\
$A$ besteht aus Schlüsseln aus einem preferred path. Somit muss für jeden Schlüssel $k$ eines Knotens mit \textit{depth} $\leq d$ in $A$ entweder $k > r$ oder $k < l$ gelten, denn alle Schlüssel aus $\left[l,r\right]$ liegen in $P$ entweder im linken oder im rechten Teilbaum des Knotens mit Schlüssel $k$. \\
Es wird nun der Ablauf von \textit{cut} gezeigt. Wobei angenommen wird, dass sowohl $l'$ als auch $r'$ existieren. Die anderen Fälle können einfach abgeleitet werden.
\begin{enumerate}
	\item Setze die \textit{isRoot} Variable der Wurzel von $A$ auf \textit{false} 
	\item Führe \textit{split}$\left(\mathit{key}\left(l'\right)\right)$ auf $A$ aus. Sei $l^*$ die Rückgabe von \textit{split}$\left(\mathit{key}\left(l'\right)\right)$. Sei $B$ der linke Teilbaum von $l^*$ und $C$ der Rechte. 
	\item Führe \textit{split}$\left(\mathit{key}\left(r'\right)\right)$ auf $C$ aus. Sei $r^*$ die Rückgabe von \textit{split}$\left(\mathit{key}\left(r'\right)\right)$. Sei $D$ der linke Teilbaum von $l^*$ und $E$ der Rechte. 
	\item Setze $r^*$ als rechtes Kind von $l^*$. 
	\item Setze die \textit{isRoot} Variable der Wurzel von $D$ auf \textit{true}.
	\item Führe $F = \textit{concatenate}\left(D, \mathit{ key}\left(r'\right) \mathit{, }E \right)$ aus.
	\item Führe $G = \textit{concatenate}\left(B, \mathit{ key}\left(l'\right) \mathit{, }E \right)$ aus.
	\item Setze die \textit{isRoot} Variable der Wurzel von $G$ auf \textit{true} 
	\item Füge $G$ an der Position in $T$ ein die zuvor $A$ belegte.
	 
\end{enumerate}
Abbildung \ref{fig:cut} demonstriert den Ablauf nochmals.
%\begin{figure}[h]
%	\centering
%	\includegraphics[width=1\textwidth]{"Medien/Tango/cut"}
%	\caption{Ablauf von \textit{cut(Tiefe $d$)}. Die Abbildung basiert auf einer aus \cite{demainDinamicOpti} }
%	\label{fig:cut}
%\end{figure}



\paragraph{join Operation}




\paragraph{access Operation}





\subsection{Laufzeitanalyse}
\newpage
\bibliography{literaturverzeichnis}
\bibliographystyle{unsrt}

\end {document}


