\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[ngerman,german]{babel}
\usepackage[T1]{fontenc}
\usepackage{courier}
\usepackage{float}
\usepackage{amsmath,amsthm}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{csquotes}
\usepackage[font=small,labelfont=bf]{caption}

%\usepackage[pages=some]{background} % Draft Wasserzeichen mit Option pages=all sonst pages=some



\title{Bachelorarbeit}
\author{
	Andreas Windorfer\\
}
\date{\today}


\begin {document}


\maketitle
\newpage
Zusammenfassung
\newpage
\tableofcontents


\newpage


\section {Binäre Suchbäume}
Es gibt viele Varianten von binären Suchbäumen mit unterschiedlichen Eigenschaften und Leistungsdaten. In diesem Kapitel werden binäre Suchbäume im Allgemeinem beschrieben. Außerdem werden Begriffe definiert, die in den nachfolgenden Kapiteln verwendet werden. \\
\subsection{Definition binärer Suchbaum}
Ein \textbf{Baum} $T$ ist ein minimal zusammenhängender, gerichteter Graph. Ein Baum ohne Knoten ist ein \textbf{leerer Baum}. In einem nicht leerem Baum gibt es genau einen Knoten ohne eingehende Kante, diesen bezeichnet man als \textbf{Wurzel}. Alle anderen Knoten haben genau eine eingehende Kante.  Ein \textbf{Pfad} $P_{jk}$ ist eine Folge von Knoten $(v_0$,$v_1$,...,$v_n)$, mit $v_0 = v_j$, $v_n = v_k$ und $\forall i \in \{ 1, 2,..., n \} \colon v_{i-1}$ \textit{ist der Elternknoten von} $v_i$. $n$ ist die \textbf{Länge des Pfades}. Die Knoten  $v_0$ bis $v_{n-1}$ sind \textbf{Vorfahren} von $v_n$.Jeder Knoten $v$ in $T$ ist Wurzel eines \textbf{Teilbaumes} $T(v)$, der entsteht in dem alle Knoten $u$ aus $T$ entfernt werden, zu denen es keinen Pfad $P_{vu}$ gibt.  Knoten ohne ausgehende Kante nennt man \textbf{Blatt}, alle anderen Knoten werden als \textbf{innere Knoten} bezeichnet. Enthält der Baum eine Kante von Knoten $v_1$ zu Knoten $v_2$ so nennt man $v_2$ ein \textbf{Kind} von $v_1$ und $v_1$ bezeichnet man als den  \textbf{Elternknoten} von $v_2$. Die Wurzel hat also keinen Elternknoten, alle anderen Knoten genau einen.\\
Bei einem \textbf{binärem Baum} kommt folgende Einschränkung hinzu:  \\
\textit{Ein Knoten hat maximal zwei Kinder.}\\ 
Entsprechend ihrer Zeichnung benennt man die Kinder in Binärbäumen als \textbf{linkes Kind} oder \textbf{rechtes Kind}. Sei $w$ das linke bzw. rechte Kind von $v$, dann bezeichnet man den Teilbaum mit Wurzel $w$ als \textbf{linken Teilbaum} bzw. \textbf{rechten Teilbaum}  von $v$.  

\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Einleitung/ioSuchbaum"}
	\caption{Ein binärer Suchbaum }
	\label{fig:ioSuchbaum}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Einleitung/nioSuchbaum"}
	\caption{Kein binärer Suchbaum }
	\label{fig:nioSuchbaum}
\end{figure}

\noindent Bei einem \textbf{binären Suchbaum} ist jedem Knoten $v$ ein innerhalb der Baumstruktur ein eindeutiger \textbf{Schlüssel} $\mathit{key}\left(v\right)$ aus einem \textbf{Universum} zugeordnet werden, auf dem eine totale Ordnung definiert ist. Auf totale Ordnungen wird in diesen Kapitel noch eingegangen. Wenn nicht explizit anders angegeben wird hier und in den folgenden Kapiteln wird als Universum immer $\mathbb{N}$ verwendet, wobei die $0$ enthalten ist. Die in einem binärem Suchbaum enthaltenen Schlüssel bezeichnen wir als seine \textbf{Schlüsselmenge}.  Damit aus dem binären Baum ein binärer Suchbaum wird, benötigt man noch folgende Eigenschaft:\\
\textit{Für jeden Knoten im binären Suchbaum gilt, dass alle in seinem linken Teilbaum enthaltenen Schlüssel kleiner sind als der eigene Schlüssel. Alle im rechten Teilbaum enthaltenen Schlüssel sind größer als der eigene Schlüssel.} \\



	
\noindent Anstatt binärer Suchbaum schreibt man häufig \textbf{BST} für Binary Search Tree. Diese Abkürzung wird hier ab jetzt auch verwendet. In Implementierungen enthält jeder Knoten für das linke und rechte Kind jeweils einen Zeiger. Anstatt von entfernten oder hinzugefügten Kanten wird im folgenden häufig von umgesetzten Zeigern gesprochen. 	
\subsection{Weitere Begriffe und Eigenschaften zum binären Suchbaum}	
\noindent Zwei verschiedene Knoten mit dem selben Elternknoten nennt man \textbf{Geschwister}. Den Knoten in einem BST wird auch eine \textbf{Tiefe} und eine \textbf{Höhe} zugeteilt. Für einen Knoten $v$ gilt, dass die Länge des Pfades von der Wurzel zu ihm seiner Tiefe entspricht. Sei $l$ die maximale Länge eines von $v$ aus startenden Pfades. Die Höhe $\mathit{h(v)}$ von $v$ ist dann $l+1$. Die Höhe der Wurzel entspricht der \textbf{Höhe des Baumes~ $h(T)$}, wobei ein leerer Baum Höhe $0$ hat. Einen BST $T$ mit Höhe $h_T$ unterteilt man von oben nach unten in die \textbf{Ebenen} $\mathit{1,2...,h_T}$. Die Wurzel liegt in der Ebene eins, deren Kinder in der Ebene zwei usw. Enthält eine Ebene ihre maximale Anzahl an Knoten nennt man sie \textbf{vollständig besetzt}.
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Einleitung/suchbaum2_2"}
	\caption{Ein weiterer binärer Suchbaum }
	\label{fig:suchbaum2_2}
\end{figure}

\noindent Da im linken Teilbaum nur kleinere Schlüssel vorhanden sein dürfen und im rechten Teilbaum nur größere, kann man die Schlüsselmenge eines binären Suchbaumes, von links nach rechts, in aufsteigend sortierter Form ablesen. Denn angenommen es gibt zwei Knoten $v_l$, $v_r$ mit den Schlüsseln $k_l$ bzw. $k_r$, so dass $k_l > k_r$ gilt und $v_l$ liegt weiter links im Baum als $v_r$. Ist $v_l$ ein Vorfahre von $v_r$, so enthält der rechte Teilbaum von $v_l$ einen Schlüssel der kleiner ist als $k_l$. Ist $v_r$ Vorfahre von $v_l$, so enthält der linke Teilbaum von $v_r$ einen Schlüssel der größer ist als $k_r$. Ist keiner der Knoten Vorfahre des anderen, muss es zumindest einen gemeinsamen Vorfahren geben, denn dann kann weder $v_r$ noch $v_l$ die Wurzel des BST sein. Sei $v_v$ der gemeinsame Vorfahre mit der größten Tiefe. Der linke Teilbaum von $v_v$ enthält dann einen größeren Schlüssel, als der rechte Teilbaum dieses Knotens. In jedem Fall erhält man einen Widerspruch zu der von BSTs geforderten Eigenschaft. Aus Platzgründen passiert es bei Zeichnungen von BSTs manchmal, dass ein Knoten in einem linken Teilbaum weiter rechts steht als die Wurzel des Teilbaumes, oder umgekehrt, weshalb man bei der Betrachtung solcher Zeichnungen etwas vorsichtig sein muss. Abbildung \ref{fig:linksRechts} enthält keine solche Konstellation.  

\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Einleitung/linksRechts"}
	\caption{Schlüssel sind aufsteigend sortiert ablesbar. }
	\label{fig:linksRechts}
\end{figure}
\noindent Algorithmisch kann man sich die im BST enthaltenen Schlüssel aufsteigend sortiert durch eine \textbf{Inorder-Traversierung} ausgeben lassen. Es ist ein rekursives Verfahren, dass an der Wurzel startet und pro Aufruf drei Schritte ausführt.\\

Algorithmus \textbf{$\mathit{inorder}$ (Knoten $v$)}
\begin{enumerate}
	\item Existiert ein linkes Kind $\mathit{vl}$ von $v$, rufe $\mathit{inorder(vl)}$ auf. 
	\item Gib den Schlüssel von $v$ aus. 
	\item Existiert ein rechtes Kind $\mathit{vr}$ von $v$, rufe $\mathit{inorder(vr)}$ auf. 
\end{enumerate}

\noindent Dass das Verfahren funktioniert sieht man leicht, durch Induktion über die Anzahl der Knoten $n$.
Für $n = 1$ funktioniert es, da der einzige im BST enthaltene Schlüssel ausgegeben wird. Wir nehmen nun an, dass die Ausgabe für BSTs mit Knotenzahl $\leq n$ korrekt ist. Sei $T_1$ ein BST mit Knotenanzahl $n + 1$ und Wurzel $w$. Sowohl für den linken als auch für den rechten Teilbaum von $w$ gilt, dass die Anzahl enthaltener Knoten $\leq n$ ist. Als erstes wird der linke Teilbaum von $w$ korrekt ausgegeben, dann der Schlüssel von $w$ selbst und zuletzt der rechte Teilbaum von $w$. Damit wurde auch für den Gesamtbaum die richtige
Ausgabe erzeugt. 
Als \textbf{Vorgänger} eines Knoten $v$, mit Schlüssel $k_v$ bezeichnet man den Knoten mit dem größten im BST enthaltenem Schlüssel $k$ für den gilt $k < k_v$. Aus der Inorder-Traversierung kann man eine Anleitung zum Finden des Vorgängers ableiten. Wenn ein linker Teilbaum vorhanden ist, wird der größte Schlüssel in diesem, also der am weitesten rechts liegende, direkt vor $k$ ausgegeben. Anderenfalls wird der Schlüssel des tiefsten Knotens, auf dem Pfad von der Wurzel zu $v$ ausgegeben, bei dem $v$ im rechten Teilbaum liegt. Als \textbf{Nachfolger} von $v$, bezeichnet man den Knoten mit dem kleinsten im BST enthaltenem Schlüssel $k$ für den gilt $k > k_v$.
Da dieser Schlüssel bei der Inorder-Traversierung direkt nach $v$ ausgegeben wird, findet man den zugehörigen Knoten ganz links im rechten Teilbaum von $v$, falls ein solcher vorhanden ist. Ansonsten ist es der tiefste Knoten, auf dem Pfad von der Wurzel zu $v$, bei dem $v$ im linkem Teilbaum liegt. Abbildung \ref{fig:VorgängerNachfolger} zeigt Vorgänger und Nachfolger eines Knotens. Als \textbf{Vorfahre} eines Knotens $v$ bezeichnet man alle Knoten auf dem Pfad von der Wurzel zu $v$, inklusive $v$ selbst. 

\begin{figure}[h]
		\centering
	\includegraphics[width= 1\textwidth]{"Medien/Einleitung/VorgängerNachfolger"}
	\caption{Darstellung von Vorgänger und Nachfolger. }
	\label{fig:VorgängerNachfolger}
\end{figure}
\paragraph{Total geordnete Menge} 
Eine Menge $M$ wird als \textbf{total geordnet} bezeichnet wenn auf ihr eine zweistellige Relation $\leq$ definiert ist, die folgende Eigenschaften erfüllt.\\
Für alle $a$,$b$,$c$ $\in M$ gilt:
\begin{align*}
\text{1. } & (a,a) \in R  &\text{  (reflexiv)}\\
\text{2. } & (a,b) \in R  \land  (a,b) \in R \Rightarrow a = b  &\text{  (antisymmetrisch)}\\
\text{3. } & (a,b) \in R  \land  (b,c) \in R \Rightarrow  (a,c) \in R  &\text{  (transitiv)}\\
\text{4. } & (a,b) \notin R \Rightarrow  (b,a) \in R   &\text{  (total)}\\
\end{align*}
Die Eigenschaften 1,2 und 4 werden benötigt um für zwei beliebige Elemente aus der Menge feststellen zu können ob sie gleich sind, oder bei Ungleichheit, welches Element weiter Links bzw. Rechts im BST liegen muss. Dafür wird z.B getestet ob die Elemente $(a,b)$ und $(b, a)$ in der Relation liegen. Eigenschaft 3 ist notwendig, denn liegt $b$ weiter rechts im BST als $a$ und $c$ liegt weiter rechts als $b$, dann liegt $c$ natürlich auch weiter rechts als $a$. \\
Die von uns verwendete \enquote{Kleiner-Gleich-Beziehung} auf den natürlichen Zahlen erfüllt alle Eigenschaften.
\\
\\




\paragraph{Verändern eines BST durch Rotationen.}
Wird ein BST durch eine Veränderung in einen anderen BST überführt, kann es passieren dass sich die Eigenschaften eines Knoten ändern. Um nicht immer erwähnen zu müssen auf welchen BST sich eine Aussage bezieht, wird es ab jetzt durchgängig so sein, dass sich ein Variablenname ohne angefügten Hochstrich auf den BST vor der Änderung bezieht. Der gleiche Variablenname mit angefügtem Apostroph bezieht sich dann auf den selben Knoten nach der Änderung. Z.B. bezieht sich $x$ auf den Knoten mit Schlüssel $k$, in der Ausgangssituation, dann bezieht sich $x'$ auf den Knoten mit Schlüssel $k$ nach dem Ausführen der Änderung. \\

\noindent\textbf{Rotationen} können verwendet werden um lokale Änderungen an der Struktur eines BST durchzuführen, ohne eine der geforderten Eigenschaften zu verletzen. Es wird zwischen der Linksrotation und der Rechtsrotation 
unterschieden. Hier wird zunächst auf die in Abbildung \ref{fig:Linksrotation} dargestellte Linksrotation eingegangen. 
Sei $x$ der Knoten auf dem eine Linksrotation durchgeführt wird. Sei $z$ der Elternknoten von $x$. $z$ muss existieren, ansonsten darf auf $x$ keine Rotation durchgeführt werden. Sei $B$ der linke Teilbaum von $x$. Nach der Rotation ist $x'$ linkes bzw. rechtes Kind von dem Knoten, an dem $z$ linkes bzw. rechtes Kind war. $z'$ ist linkes Kind von $x'$. $B '$ ist rechtes Kind von $z'$. Unabhängig von der Anzahl der im BST enthaltenen Knoten und der Ausführungsstelle im BST ist eine Linksrotation also mit dem Aufwand verbunden drei Zeiger umzusetzen. Zu beachten ist, dass die Höhen von $x'$ und der Knoten in dessen, ansonsten unverändertem, rechtem Teilbaum jeweils um eins größer sind als die von $x$ und den Knoten in dessen rechtem Teilbaum. Die Höhe der Knoten im Teilbaum mit Wurzel $z'$ sind jeweils um eins kleiner als vor der Rotation.
 Abbildung \ref{fig:Rechtsrotation} zeigt die symmetrische Rechtsrotation. Man muss im obigen Beschreibung lediglich links durch rechts ersetzen und umgekehrt. Dass es durch eine Rotation zu keiner Verletzung der BST Eigenschaften kommt, sieht man den Abbildungen direkt an. In Abbildung \ref{fig:LinksRechtsRotation} erkennt man, dass sich die Wirkung einer Rotation auf $x$ durch eine gegenläufige Rotation auf $z'$ aufheben lässt.  
\begin{figure}[h]
	\centering
	\includegraphics[width= 1.2\textwidth]{"Medien/Einleitung/Linksrotation"}
	\caption{Linksrotation auf Knoten x. }
	\label{fig:Linksrotation}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width= 1.2\textwidth]{"Medien/Einleitung/Rechtsrotation"}
	\caption{Rechtsrotation auf Knoten x. }
	\label{fig:Rechtsrotation}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width= 1.2\textwidth]{"Medien/Einleitung/LinksRechtsRotation"}
	\caption{Gegenseitiges aufheben von Rotationen}
	\label{fig:LinksRechtsRotation}
\end{figure}

\paragraph{Grundoperationen \textit{search}, \textit{insert} und \textit{delete}} \label{BST Operationen}
Hier geht es nur um die Standardvarianten eines BST. Später werden Varianten gezeigt die von diesem Verhalten zum Teil deutlich abweichen. Innerhalb Operationen wird häufig von einem Knoten aus direkt
auf dessen Elternknoten zugegriffen, so dass man sich im Baum auch nach oben hin bewegen kann. In Implementierungen wird das so umgesetzt, dass es zusätzlich zu den beiden Zeigern auf die Kinder noch einen zum Elternknoten gibt.Es sei ein BST $T$ gegeben. Innerhalb eines Pfades werden hier jedoch entweder nur Zeiger auf Kinder oder nur auf Elternknoten verwendet.  \\
  Die Operation \textit{search}(Key $k$) gibt eine Referenz auf den Knoten im BST zurück, dessen Schlüssel mit $k$ übereinstimmt. Die Operation startet an der Wurzel und vergleicht den darin enthaltenen Schlüssel mit dem Gesuchten. Ist der gesuchte Schlüssel kleiner, muss er sich im linken Teilbaum des betrachtetem Knoten befinden und die Suche wird bei dessen Wurzel fortgesetzt. Ist der Schlüssel größer, muss er sich im rechten Teilbaum befinden und die Suche wird bei dessen Wurzel fortgesetzt. Dieses Verhalten iteriert solange bis der gesuchte Schlüssel gefunden ist, oder der Teilbaum bei dem die Suche fortgesetzt werden müsste, leer ist. Ist das Letztere der Fall, ist der gesuchte Schlüssel im Baum nicht vorhanden und es wird eine leere Referenz zurückgegeben. In keinem Fall kommt es zu einer Veränderung des BST.\\
  Bei \textit{insert(Key $k$)} wird zunächst wie bei  \textit{search}(Key $k$) verhalten. Wird $k$ gefunden, wird das Einfügen abgebrochen und der BST bleibt unverändert. Wird ein leerer Teilbaum $T_2$ erreicht, wird ein neu erzeugter Knoten mit Schlüssel $k$ an der Position von $T_2$ eingefügt. Durch den neuen Knoten wird keine BST Eigenschaft verletzt. Durch ersetzen eines leeren Teilbaumes, durch einen Knoten bleibt es bei einem binären Baum. Das Verhalten von  \textit{insert} stellt sicher, dass $k$ nur in linken Teilbäumen von Knoten mit Schlüssel $> k$ bzw. in rechten Teilbäumen von Knoten mit Schlüssel~ $< k$ liegt.    \\
\begin{figure}[h]
		\centering
	\includegraphics[width= 1.2\textwidth]{"Medien/Einleitung/SuchenEinfügen"}
	\caption{Links zeigt eine Suche nach dem Schlüssel 15. Rechts das Einfügen des Schlüssels 13}
	\label{fig:SuchenEinfügen}
\end{figure}
\noindent Auch bei \textit{löschen(Schlüssel $k$)} wird sich zunächst wie beim  \textit{search}(Key $k$) verhalten. Ist $k$ im BST nicht vorhanden wird abgebrochen und der BST bleibt unverändert. Ansonsten werden drei Fälle unterschieden.
Sei $v$ der Knoten mit Schlüssel $k$.
\begin{enumerate}
	\item $v$ ist ein Blatt: \\
	$v$ kann ohne weiteres aus dem BST entfernt werden.
	\item $v$ hat genau ein Kind $c$:\\
     Ist $v$ die Wurzel kann er entfernt werden und $c$ wird zur neuen Wurzel. Ansonsten ist $v$ entweder ein linkes oder ein rechtes Kind eines Knoten $w$. $c$ nimmt nun den Platz von $v$ im BST ein. Das bedeutet, dass die Kanten von $w$ nach $v$ und von $v$ nach $c$ entfernt werden. Außerdem wird eine Kante von $w$ nach $c$ so eingefügt, dass $c$ wie zuvor $v$ das linke bzw. rechte Kind von $w$ wird. 
	\item $v$ hat zwei Kinder:\\
	Sei $T_l$ der linke Teilbaum von $v$ und $T_r$ der Rechte.
	Sei $z$ der Knoten mit dem kleinsten Schlüssel im rechten Teilbaum von $v$. Als Knoten mit dem kleinsten Schlüssel im rechten Teilbaum von $v$, kann $z$ kein linkes Kind haben. Ist $z$ ein Blatt wird seine eingehende Kante entfernt. Hat $z$ ein rechtes Kind $z_r$, so nimmt dieses, analog zur Beschreibung im Fall 2, den Platz von $z$ ein. In beiden Fällen ist $z$ nun ein Knoten ohne Kante. Im nächsten Schritt nimmt nun $z$ den Platz von $v$ ein, $T_l$ wird links an $z$ angefügt und $T_r$ rechts. War $v$ zu Beginn die Wurzel, so wird $z'$ zur neuen Wurzel.\\
	In keinen Teilbäumen eines Knotens außer denen von $z$ kommen Schlüssel hinzu. Um eventuelle Verletzungen von Eigenschaften festzustellen, kann sich also auf $z'$ beschränkt werden. Der linke Teilbaum von $z'$ war der linke Teilbaum von $v$ und der Schlüssel von $v$ ist kleiner als der von $z$. Der rechte Teilbaum von $z$ enthält die Schlüssel des rechten Teilbaumes von $v$ mit Ausnahme des Schlüssels von $z$ selbst. $z$ wurde gerade ausgewählt weil sein Schlüssel der Kleinste in diesem Teilbaum ist. 
	
	
	
	 
\end{enumerate} 
\begin{figure}[h]
	\centering
	\includegraphics[width= 1.2\textwidth]{"Medien/Einleitung/löschen"}
	\caption{Löschen des Schlüssels 10}
	\label{fig:löschen}
\end{figure}
\paragraph{Laufzeit}
Die worst-case-Laufzeit der drei Operationen ist jeweils $\mathit{O(h)}$, wobei $h$ die Höhe von $T$ ist. Bei \textit{search} werden maximal $h$ Knoten aus $T$ betrachtet. Beim Einfügen überlagern die Kosten der Suche, die konstanten Kosten für das Anhängen des neuen Knotens. Bei \textit{delete} wird in Fall eins und zwei nach dem Suchen ebenfalls nur noch lokal beim gesuchten Knoten gearbeitet. Bei \textit{delete} mit Fall drei muss zunächst zum Knoten $z$ erreicht werden, dafür sind maximal $h$ Schritte notwendig. Danach muss $v$ erreicht werden, wozu ebenfalls maximal $h$ Schritte notwendig sind. Die Kosten für das Entfernen und Hinzufügen von Kanten sind an beiden Stellen konstant.  



\paragraph{Unterschiedliche Baumhöhen}
Da die Höhe $h$ eines BST $T$ mit $n$ Knoten entscheidend für die Laufzeit der vorgestellten Operationen ist, wird hier auf diese eingegangen. Die maximale Höhe $n$ erreicht ein BST wenn es ein Blatt im BST gibt und jeder andere Knoten ein Halbblatt ist. Die Baumstruktur geht in diesem Fall über zu einer Listenstruktur über, dies wird als \textbf{entarten} bezeichnet. Minimal wird $h$ wenn $T$ \textbf{vollständig balanciert} ist. Das ist der Fall wenn alle Ebenen über der Untersten vollständig besetzt sind. Sind zusätzlich in der untersten Ebene, links von jedem Knoten, alle Knoten enthalten, wird der BST als \textbf{komplett} bezeichnet, siehe Abbildung \ref{fig:kompletterBaum}. 
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Einleitung/kompletterBaum"}
	\caption{Kompletter BST mit 12 Knoten}
	\label{fig:kompletterBaum}
\end{figure}

\newtheorem{Lemma}{Lemma}[section]
\begin{Lemma} Die Höhe eines vollständig balancierten BST $T$ mit $n$ Knoten ist $ \lfloor \log_2{(n)} \rfloor + 1 $. 
\end{Lemma}
\begin{proof}
	
	Es sei $\mathit{N(h)}$ die maximale Anzahl an Knoten in einem vollständig balancierten BST mit Höhe $h$.
	$\mathit{N(h)}$  berechnet sich indem die maximale Anzahl an Knoten jeder Ebene aufaddiert wird.\\
	\begin{align*}
	 \mathit{N(h)} = \sum\limits_{i=0}^{h-1} 2^i = 2^h - 1 
	\end{align*}
								 
\noindent	$h$ ist minimal wenn gilt:\\
	\begin{align*}
	\mathit{N(h-1)} &< n \leq \mathit{N(h)}\\
	\Leftrightarrow \mathit{N(h-1)} + 1 &\leq n < \mathit{N(h)} + 1\\
	\end{align*}
	Einsetzen:\\
	\begin{align*}
	&2^{h - 1} \leq n < 2^h\\
	\Rightarrow & h =  \lfloor \log_2{(n)} \rfloor + 1
	\end{align*}
	
\end{proof}


\newpage
\bibliography{literaturverzeichnis}
\bibliographystyle{unsrt}

\end {document}