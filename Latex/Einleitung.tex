\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[ngerman,german]{babel}
\usepackage[T1]{fontenc}
\usepackage{courier}
\usepackage{float}
\usepackage{amsmath,amsthm}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{csquotes}
\usepackage[font=small,labelfont=bf]{caption}

%\usepackage[pages=some]{background} % Draft Wasserzeichen mit Option pages=all sonst pages=some



\title{Bachelorarbeit}
\author{

	Andreas Windorfer\\
}
\date{\today}


\begin {document}


\maketitle
\newpage
Zusammenfassung
\newpage
\tableofcontents


\newpage

\section{Fazit}
\section {Einleitung}
Hier werden binäre Suchbäume im Allgemeinem beschrieben. Außerdem werden Begriffe definiert, die in den nachfolgenden Kapiteln verwendet werden.\\
\subsection{Definition binärer Suchbaum}
Ein \textbf{Baum} $T$ ist ein zusammenhängender, gerichteter Graph, der keine Zyklen enthält. In einem nicht leerem Baum gibt es genau einen Knoten ohne eingehende Kante, diesen bezeichnet man als \textbf{Wurzel}. Alle anderen Knoten haben genau eine eingehende Kante. Jeder Knoten $v$ in $T$ ist Wurzel eines \textbf{Teilbaumes} $T(v)$, der $v$ und alle von $v$ erreichbaren Knoten enthält. Knoten ohne ausgehende Kante nennt man \textbf{Blatt}, alle anderen Knoten werden als \textbf{innere Knoten} bezeichnet. Enthält der Baum eine Kante von Knoten $v_1$ zu Knoten $v_2$ so nennt man $v_2$ ein \textbf{Kind} von $v_1$ und $v_1$ bezeichnet man als den  \textbf{Vater} von $v_2$. Die Wurzel hat also keinen Vater, alle anderen Knoten genau einen.\\
Bei einem \textbf{binärem Baum} kommt folgende Einschränkung hinzu:  \\
\textit{Ein Knoten hat maximal zwei Kinder.}\\ 
Entsprechend ihrer Zeichnung benennt man die Kinder in Binärbäumen als \textbf{linkes Kind} oder \textbf{rechtes Kind}. Sei $w$ das linke bzw. rechte Kind von $v$, dann bezeichnet man den Teilbaum mit Wurzel $w$ als \textbf{linken Teilbaum} bzw. \textbf{rechten Teilbaum}  von $v$.  

\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Einleitung/ioSuchbaum"}
	\caption{Ein binärer Suchbaum }
	\label{fig:ioSuchbaum}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Einleitung/nioSuchbaum"}
	\caption{Kein binärer Suchbaum }
	\label{fig:nioSuchbaum}
\end{figure}

\noindent Bei einem \textbf{binären Suchbaum} ist jedem Knoten ein innerhalb der Baumstruktur ein eindeutiger \textbf{Schlüssel} aus einem \textbf{Universum} zugeordnet. Als Universum kann jede Menge $M$ verwendet werden, auf der eine totale Ordnung(noch erklären) definiert ist. Hier und den folgenden Kapiteln wird als Universum immer $\mathbb{N}$ und als Relation die kleiner-gleich-Beziehung verwendet. Die in einem binärem Suchbaum enthaltenen Schlüssel bezeichnen wir als seine \textbf{Schlüsselmenge}.  Damit aus dem binären Baum ein binärer Suchbaum wird, benötigt man noch folgende Eigenschaft:\\
\textit{Für jeden Knoten im binären Suchbaum muss gelten, dass alle Schlüssel die in seinem linken Teilbaum enthaltenen sind kleiner sind als der eigene Schlüssel und alle im rechten Teilbaum enthaltenen größer.} \\

\noindent Es gibt eine rekursive Definition für binäre Suchbäume, aus der die gerade geforderten Eigenschaften direkt ersichtlich sind.
Diese soll auch hier verwendet werden.\\ 


\newtheorem{defi}{Definition}[section]
\begin{defi}Binärer Suchbaum\end{defi}
\begin{enumerate}
	\item Der leere Baum ohne Knoten ist ein binärer Suchbaum.
	\item Der Baum mit dem einzigen Knoten $v$ der Schlüssel $k_v$ enthält ist ein binärer Suchbaum.
	\item Es seien $T_1$ und $T_2$ binäre Suchbäume mit Schlüsselmenge $K_1$ bzw. $K_2$. Sei $i \in \mathbb{N} $, mit $\max{(K_1)} < i < \min{(K_2)}$. Erzeuge einen neuen Knoten $w$ mit Schlüssel $i$. Setze $T_1$ als linken Teilbaum von $w$ und $T_2$ als rechten Teilbaum von $w$. Die so entstandenen Struktur ist ein binärer Suchbaum mit Wurzel $w$. 
	\item Eine Struktur die sich nicht durch Anwenden von Punkt 1, 2 und 3 erzeugen lässt, ist kein binärer Suchbaum.  
\end{enumerate}
	
\noindent Anstatt binärer Suchbaum schreibt man häufig \textbf{BST} für binary search tree. Diese Abkürzung wird hier ab jetzt auch verwendet. 	
\subsection{Weitere Begriffe und Eigenschaften zum binären Suchbaum}	
\noindent Zwei verschiedene Knoten mit dem selben Vater nennt man \textbf{Brüder}. Ein \textbf{Pfad} $P_{jk}$ ist eine Folge von Knoten $v_0$, $v_2$,...,$v_n$, mit $v_0 = v_j$, $v_n = v_k$ und $\forall i \in \{ 1, 2,..., n \} \colon v_{i-1}$ \textit{ist Vater von} $v_i$. $n$ ist die \textbf{Länge des Pfades}. Die Knoten  $v_0$ bis $v_{n-1}$ sind \textbf{Vorfahren} von $v_n$. Den Knoten in einem BST wird auch eine \textbf{Tiefe} und eine \textbf{Höhe} zugeteilt. Für einen Knoten $v$ gilt, dass die Länge des Pfades von der Wurzel zu ihm seiner Tiefe entspricht. Die Länge des längsten von $v$ aus startenden Pfades ist die Höhe von $v$. Die Höhe der Wurzel entspricht der \textbf{Höhe des Gesamtbaumes}.
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Einleitung/suchbaum2_2"}
	\caption{Ein weiterer binärer Suchbaum }
	\label{fig:suchbaum2_2}
\end{figure}

\noindent Da im linken Teilbaum nur kleinere Schlüssel vorhanden sein dürfen und im rechten Teilbaum nur größere, kann man die Schlüsselmenge eines binären Suchbaumes, von links nach rechts, in aufsteigend sortierter Form ablesen. Denn angenommen es gibt zwei Knoten $v_l$ mit Schlüssel $k_l$ und $v_r$ mit Schlüssel $k_r$, so dass $k_l > k_r$ gilt und $v_l$ weiter links im Baum liegt als $v_r$. Ist ein $v_l$ Vorfahre von $v_r$, so enthält der rechte Teilbaum von $v_l$ einen Schlüssel der kleiner ist als $k_l$. Ist ein $v_r$ Vorfahre von $v_l$, so enthält der linke Teilbaum von $v_r$ einen Schlüssel der größer ist als $k_r$. Ist keiner der Knoten Vorfahre des anderen, muss es zumindest einen gemeinsamen Vorfahren geben, denn dann kann weder $v_r$ noch $v_l$ die Wurzel des BST sein. Sei $v_v$ der gemeinsame Vorfahrens mit der größten Tiefe. Der linke Teilbaum von $v_v$ enthält dann einen größeren Schlüssel, als der rechte Teilbaum dieses Knotens. In jedem Fall erhält man einen Widerspruch zu der von BSTs geforderten Eigenschaft. Aus Platzgründen passiert es bei Zeichnungen von BSTs manchmal, dass ein Knoten in einem linken Teilbaum weiter rechts steht als die Wurzel des Teilbaumes, oder umgekehrt, weshalb man bei der Betrachtung solcher Zeichnungen etwas vorsichtig sein muss. Abbildung \ref{fig:linksRechts} enthält keine solche Konstellation.  

\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Einleitung/linksRechts"}
	\caption{Schlüssel sind aufsteigend sortiert ablesbar. }
	\label{fig:linksRechts}
\end{figure}
\noindent Algorithmisch kann man sich die im BST enthaltenen Schlüssel aufsteigend sortiert durch eine \textbf{Inorder-Traversierung} ausgeben lassen. Es ist ein rekursives Verfahren, dass an der Wurzel startet und pro Aufruf drei Schritte ausführt.\\

Algorithmus \textbf{$\mathit{inorder}$ (Knoten $v$)}
\begin{enumerate}
	\item Existiert ein linkes Kind $\mathit{vl}$ von $v$, rufe $\mathit{inorder(vl)}$ auf. 
	\item Gib den Schlüssel von $v$ aus. 
	\item Existiert ein rechtes Kind $\mathit{vr}$ von $v$, rufe $\mathit{inorder(vr)}$ auf. 
\end{enumerate}

\noindent Dass das Verfahren funktioniert sieht man leicht, durch Induktion über die Anzahl der Knoten $n$.
Für $n = 0$ funktioniert es, da nichts ausgegeben wird. Wir nehmen nun an, dass die Ausgabe für BSTs mit Knotenzahl $\leq n$ korrekt ist. Sei $T_1$ ein BST mit Knotenanzahl $n + 1$ und Wurzel $w$. Sowohl für den linken als auch für den rechten Teilbaum von $w$ gilt, dass die Anzahl enthaltener Knoten $\leq n$ ist. Als erstes wird der linke Teilbaum von $w$ korrekt ausgegeben, dann der Schlüssel von $w$ selbst und zuletzt der rechte Teilbaum von $w$. Damit wurde auch für den Gesamtbaum die richtige
Ausgabe erzeugt. 
Als \textbf{Vorgänger} eines Knoten $v$, mit Schlüssel $k_v$ bezeichnet man den Knoten mit dem größten im BST enthaltenem Schlüssel $k$ für den gilt $k < k_v$. Aus der Inorder-Traversierung kann man eine Anleitung zum Finden des Vorgängers ableiten. Wenn ein linker Teilbaum vorhanden ist, wird der größte Schlüssel in diesem direkt vor $k$ ausgegeben. Anderenfalls wird der Schlüssel des tiefsten Knotens, auf dem Pfad von der Wurzel zu $v$ ausgegeben, bei dem $v$ im rechten Teilbaum liegt. Als \textbf{Nachfolger} von $v$, bezeichnet man den Knoten mit dem kleinsten im BST enthaltenem Schlüssel $k$ für den gilt $k > k_v$.
Da dieser Schlüssel bei der Inorder-Traversierung direkt nach $v$ ausgegeben wird, findet man den zugehörigen Knoten ganz links im rechten Teilbaum von $v$, falls ein solcher vorhanden ist. Ansonsten ist es der tiefste Knoten, auf dem Pfad von der Wurzel zu $v$, bei dem $v$ im linkem Teilbaum liegt. Abbildung \ref{fig:VorgängerNachfolger} zeigt Vorgänger und Nachfolger eines Knotens.

\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Einleitung/VorgängerNachfolger"}
	\caption{Darstellung von Vorgänger und Nachfolger. }
	\label{fig:VorgängerNachfolger}
\end{figure}

\paragraph{Verändern eines BST durch Rotationen.}
Wird ein BST $T_1$ durch eine Veränderung in einen BST $T_2$ überführt, kann es passieren dass sich Eigenschaften eines Knoten ändern. Um nicht immer erwähnen zu müssen auf welchen BST sich eine Aussage bezieht, wird es ab jetzt durchgängig so sein, dass sich ein Variablenname ohne angefügten Apostroph auf $T_1$ bezieht. Der gleiche Variablenname mit angefügtem Apostroph bezieht sich dann auf den Knoten in $T_2$, mit dem gleichen Schlüssel. $x$ bezieht sich beispielsweise auf einen Knoten in $T_1$ mit Schlüssel $k$. $x'$ bezieht sich dann auf den Knoten mit Schlüssel $k$ in $T_2$. \\

\noindent\textbf{Rotationen} können verwendet werden um Änderungen an der Struktur eines BST durchzuführen, ohne eine der geforderten Eigenschaften zu verletzen. Es wird zwischen der \textbf{Linksrotation} und der \textbf{Rechtsrotation }
unterschieden. Hier wird zunächst auf die in Abbildung \ref{fig:Linksrotation} dargestellte. Linksrotation eingegangen. 
Sei $x$ der Knoten auf dem eine Linksrotation durchgeführt wird. Sei $z$ der Vater von $x$. $z$ muss existieren, ansonsten darf auf $x$ keine Rotation durchgeführt werden. Sei $y$ der linke Teilbaum von $x$. Bei der Rotation nimmt $x'$ den Platz von $z$ ein. $z'$ ist linkes Kind von $x'$. $y'$ hängt rechts an $z'$. Für das Umhängen von $y$ muss Platz sein, denn $y'$ hängt da, wo $x$ abgehängt wurde. Unabhängig von der Anzahl der im BST enthaltenen Knoten und der Ausführungsstelle im BST ist eine Linksrotation also mit dem Aufwand verbunden drei Zeiger umzusetzen. Zu beachten ist, dass die Höhe von $x'$ und der Knoten in dessen, ansonsten unverändertem, rechtem Teilbaum jeweils um eins größer ist als die von $x$ und den Knoten in dessen rechtem Teilbaum. Die Höhe Knoten im linken Teilbaum von $z'$ sind jeweils um eins kleiner als die, im ansonsten unverändertem linken Teilbaum von $z$. 
 Abbildung \ref{fig:Rechtsrotation} zeigt die symmetrische Rechtsrotation. Man muss im obigen Beschreibung lediglich links durch rechts ersetzen und umgekehrt. Dass es durch eine Rotation zu keiner Verletzung der BST Eigenschaften kommt, sieht man den Abbildungen direkt an. In Abbildung \ref{fig:LinksRechtsRotation} erkennt man, dass sich die Wirkung einer Rotation auf $x$ durch eine gegenläufige Rotation auf $z'$ aufheben lässt.  
\begin{figure}[h]
	\centering
	\includegraphics[width= 1.2\textwidth]{"Medien/Einleitung/Linksrotation"}
	\caption{Linksrotation auf Knoten x. }
	\label{fig:Linksrotation}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width= 1.2\textwidth]{"Medien/Einleitung/Rechtsrotation"}
	\caption{Rechtsrotation auf Knoten x. }
	\label{fig:Rechtsrotation}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width= 1.2\textwidth]{"Medien/Einleitung/LinksRechtsRotation"}
	\caption{Gegenseitiges aufheben von Rotationen}
	\label{fig:LinksRechtsRotation}
\end{figure}

\paragraph{Suchen im Baum.} Durch die  
\paragraph{Unterschiedliche Baumhöhen.} 



\bibliography{literaturverzeichnis}
\bibliographystyle{unsrt}

\end {document}