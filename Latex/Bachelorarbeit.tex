\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[ngerman,german]{babel}
\usepackage[T1]{fontenc}
\usepackage{courier}
\usepackage{float}
\usepackage{amsmath,amsthm}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{csquotes}
\usepackage[font=small,labelfont=bf]{caption}

%\usepackage[pages=some]{background} % Draft Wasserzeichen mit Option pages=all sonst pages=some



\title{Bachelorarbeit}
\author{
	Andreas Windorfer\\
}
\date{\today}
\begin {document}
\newtheorem{Lemma}{Lemma}[section]
\newtheorem{Satz}{Satz}[section]

\maketitle
\newpage
Zusammenfassung
\newpage
\tableofcontents
\newpage
\begin{center}
\textbf{Zusammenfassung}
\end{center}
Binäre Suchbäume werden vielfältig eingesetzt. Bei ihnen wird sich besonders für die Ausführungszeit interessiert. Hier wird es speziell um die Ausführungszeit von Folgen von \textit{access} Operationen gehen, im Bezug zur Anzahl $n$ der Knoten des binären Suchbaumes. Beim 1985, in \cite{splay} vorgestellten Splay Baum, wird vermutet, dass dieser jede Folge von  \textit{access} Operationen asymptotisch betrachtet, mindestens genau so schnell ausführt, wie jeder andere BST. Dies wurde als dynamische Optimalitäts Vermutung bekannt. Bis heute ist offen ob der Splay Baum dies Eigenschaft besitzt.  2007 wurde dann in \citeonline{demainDinamicOpti} der Tango Baum vorgestellt. Bei ihm ist bekannt, dass er jede solche Folge, asymptotisch betrachtet, nur um einen Faktor $\log_2\left(\log_2\left(n\right)\right)$ langsamer Ausführt, als der jeweils schnellte BST. Bis dahin war kein BST bekannt der einen solchen Faktor kleiner als $\log_2\left(n\right)$ hat, und dieser wird von den balancierten binären Suchbäumen trivial erreicht. Der Tango Baum wird im Detail vorgestellt und zusätzlich noch einige Variationen zu ihm.\\
Zum Ende werden noch Laufzeittest zwischen dem Tango Baum und dem Splay Baum durchgeführt. 


\newpage
\section{Einleitung}
\newpage
\section {Binäre Suchbäume}
Es gibt viele Varianten von binären Suchbäumen mit unterschiedlichen Eigenschaften und Leistungsdaten. In diesem Kapitel werden binäre Suchbäume im Allgemeinem beschrieben. Außerdem werden Begriffe definiert, die in den nachfolgenden Kapiteln verwendet werden. \\
\subsection{Definition binärer Suchbaum}
Ein \textbf{Baum} $T$ ist ein minimal zusammenhängender, gerichteter Graph. Ein Baum ohne Knoten ist ein \textbf{leerer Baum}. In einem nicht leerem Baum gibt es genau einen Knoten ohne eingehende Kante, diesen bezeichnet man als \textbf{Wurzel}. Alle anderen Knoten haben genau eine eingehende Kante.  Ein \textbf{Pfad} $P$ ist eine Folge von Knoten $(v_0$,$v_1$,...,$v_n)$ mit, $\forall i \in \{ 1, 2,..., n \} \colon v_{i-1}$ \textit{ist der Elternknoten von} $v_i$. $n$ ist die \textbf{Länge des Pfades}. Die Knoten  $v_0$ bis $v_{n-1}$ sind \textbf{Vorfahren} von $v_n$. Jeder Knoten $v$ in $T$ ist Wurzel eines \textbf{Teilbaumes} $T(v)$, der entsteht in dem alle Knoten $u$ aus $T$ entfernt werden, zu denen es keinen Pfad mit  $v_0 = v$, $v_n = u$ gibt. Knoten ohne ausgehende Kante werden \textbf{Blatt} genannt, alle anderen Knoten werden als \textbf{innere Knoten} bezeichnet. Enthält der Baum eine Kante von Knoten $v_1$ zu Knoten $v_2$ so ist $v_2$ ein \textbf{Kind} von $v_1$ und $v_1$ ist der  \textbf{Elternknoten} von $v_2$. Die Wurzel hat also keinen Elternknoten, alle anderen Knoten genau einen.\\
Bei einem \textbf{binärem Baum} kommt folgende Einschränkung hinzu:  \\
\textit{Ein Knoten hat maximal zwei Kinder.}\\ 
Entsprechend ihrer Zeichnung werden die Kinder in Binärbäumen als \textbf{linkes Kind} oder \textbf{rechtes Kind} bezeichnet. Sei $w$ das linke bzw. rechte Kind von $v$, dann bezeichnet man den Teilbaum mit Wurzel $w$ als \textbf{linken Teilbaum} bzw. \textbf{rechten Teilbaum}  von $v$.  

\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Einleitung/ioSuchbaum"}
	\caption{Ein binärer Suchbaum }
	\label{fig:ioSuchbaum}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Einleitung/nioSuchbaum"}
	\caption{Kein binärer Suchbaum }
	\label{fig:nioSuchbaum}
\end{figure}

\noindent Bei einem \textbf{binären Suchbaum} ist jedem Knoten $v$ ein innerhalb der Baumstruktur ein eindeutiger \textbf{Schlüssel} $\mathit{key}\left(v\right)$ aus einem \textbf{Universum} zugeordnet, auf dem eine totale Ordnung definiert ist. Auf totale Ordnungen wird in diesen Kapitel noch eingegangen. Wenn nicht explizit anders angegeben wird hier und in den folgenden Kapiteln als Universum immer $\mathbb{N}$ verwendet, wobei die $0$ enthalten ist. Die in einem binärem Suchbaum enthaltenen Schlüssel bezeichnen wir als seine \textbf{Schlüsselmenge}.  Damit aus dem binären Baum ein binärer Suchbaum wird, benötigt man noch folgende Eigenschaft:\\
\textit{Für jeden Knoten im binären Suchbaum gilt, dass alle in seinem linken Teilbaum enthaltenen Schlüssel kleiner sind als der eigene Schlüssel. Alle im rechten Teilbaum enthaltenen Schlüssel sind größer als der eigene Schlüssel.} \\




\noindent Anstatt binärer Suchbaum schreibt man häufig \textbf{BST} für Binary Search Tree. Diese Abkürzung wird hier ab jetzt auch verwendet. In Implementierungen enthält jeder Knoten für das linke und rechte Kind jeweils einen Zeiger. Anstatt von entfernten oder hinzugefügten Kanten wird im folgenden häufig von umgesetzten Zeigern gesprochen. 	
\subsection{Weitere Begriffe und Eigenschaften zum binären Suchbaum}	
\noindent Zwei verschiedene Knoten mit dem selben Elternknoten nennt man \textbf{Geschwister}. Den Knoten in einem BST wird auch eine \textbf{Tiefe} und eine \textbf{Höhe} zugeteilt. Für einen Knoten $v$ gilt, dass die Länge des Pfades von der Wurzel zu ihm seiner Tiefe entspricht. Sei $l$ die maximale Länge eines von $v$ aus startenden Pfades. Die Höhe $\mathit{h(v)}$ von $v$ ist dann $l+1$. Die Höhe der Wurzel entspricht der \textbf{Höhe des Baumes~ $h(T)$}, wobei ein leerer Baum Höhe $0$ hat. Ein BST $T$ mit Höhe $h_T$ wird von oben nach unten in die \textbf{Ebenen} $\mathit{1,2...,h_T}$ unterteilt. Die Wurzel liegt in der Ebene eins, deren Kinder in der Ebene zwei usw. Enthält eine Ebene ihre maximale Anzahl an Knoten ist sie \textbf{vollständig besetzt}.
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Einleitung/suchbaum2_2"}
	\caption{Ein weiterer binärer Suchbaum }
	\label{fig:suchbaum2_2}
\end{figure}

\noindent Da im linken Teilbaum nur kleinere Schlüssel vorhanden sein dürfen und im rechten Teilbaum nur größere, kann man die Schlüsselmenge eines binären Suchbaumes, von links nach rechts, in aufsteigend sortierter Form ablesen. Denn angenommen es gibt zwei Knoten $v_l$, $v_r$ mit den Schlüsseln $k_l$ bzw. $k_r$, so dass $k_l > k_r$ gilt und $v_l$ liegt weiter links im Baum als $v_r$. Ist $v_l$ ein Vorfahre von $v_r$, so enthält der rechte Teilbaum von $v_l$ einen Schlüssel der kleiner ist als $k_l$. Ist $v_r$ Vorfahre von $v_l$, so enthält der linke Teilbaum von $v_r$ einen Schlüssel der größer ist als $k_r$. Ist keiner der Knoten Vorfahre des anderen, muss es zumindest einen gemeinsamen Vorfahren geben, denn dann kann weder $v_r$ noch $v_l$ die Wurzel des BST sein. Sei $v_v$ der gemeinsame Vorfahre mit der größten Tiefe. Der linke Teilbaum von $v_v$ enthält dann einen größeren Schlüssel, als der rechte Teilbaum dieses Knotens. In jedem Fall erhält man einen Widerspruch zu der von BSTs geforderten Eigenschaft. Aus Platzgründen passiert es bei Zeichnungen von BSTs manchmal, dass ein Knoten in einem linken Teilbaum weiter rechts steht als die Wurzel des Teilbaumes, oder umgekehrt, weshalb man bei der Betrachtung solcher Zeichnungen etwas vorsichtig sein muss. Abbildung \ref{fig:linksRechts} enthält keine solche Konstellation.  

\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Einleitung/linksRechts"}
	\caption{Schlüssel sind aufsteigend sortiert ablesbar. }
	\label{fig:linksRechts}
\end{figure}
\noindent Algorithmisch kann man sich die im BST enthaltenen Schlüssel aufsteigend sortiert durch eine \textbf{Inorder-Traversierung} ausgeben lassen. Es ist ein rekursives Verfahren, dass an der Wurzel startet und pro Aufruf drei Schritte ausführt.\\

Algorithmus \textit{inorder (Node $v$)}
\begin{enumerate}
	\item Existiert ein linkes Kind $\mathit{vl}$ von $v$, rufe $\mathit{inorder(vl)}$ auf. 
	\item Gib den Schlüssel von $v$ aus. 
	\item Existiert ein rechtes Kind $\mathit{vr}$ von $v$, rufe $\mathit{inorder(vr)}$ auf. 
\end{enumerate}

\noindent Dass das Verfahren funktioniert sieht man leicht, durch Induktion über die Anzahl der Knoten $n$.
Für $n = 1$ funktioniert es, da der einzige im BST enthaltene Schlüssel ausgegeben wird. Wir nehmen nun an, dass die Ausgabe für BSTs mit Knotenzahl $\leq n$ korrekt ist. Sei $T_1$ ein BST mit Knotenanzahl $n + 1$ und Wurzel $w$. Sowohl für den linken als auch für den rechten Teilbaum von $w$ gilt, dass die Anzahl enthaltener Knoten $\leq n$ ist. Als erstes wird der linke Teilbaum von $w$ korrekt ausgegeben, dann der Schlüssel von $w$ selbst und zuletzt der rechte Teilbaum von $w$. Damit wurde auch für den Gesamtbaum die richtige
Ausgabe erzeugt. 
Als \textbf{Vorgänger} eines Knoten $v$, mit Schlüssel $k_v$ wird der Knoten mit dem größten im BST enthaltenem Schlüssel $k$ für den gilt $k < k_v$ bezeichnet. Aus der Inorder-Traversierung kann man eine Anleitung zum Finden des Vorgängers ableiten. Wenn ein linker Teilbaum vorhanden ist, wird der größte Schlüssel in diesem, also der am weitesten rechts liegende, direkt vor $k$ ausgegeben. Anderenfalls wird der Schlüssel des tiefsten Knotens, auf dem Pfad von der Wurzel zu $v$ ausgegeben, bei dem $v$ im rechten Teilbaum liegt. Als \textbf{Nachfolger} von $v$, wird der Knoten mit dem kleinsten im BST enthaltenem Schlüssel $k$ für den gilt $k > k_v$ bezeichnet.
Da dieser Schlüssel bei der Inorder-Traversierung direkt nach $v$ ausgegeben wird, findet man den zugehörigen Knoten ganz links im rechten Teilbaum von $v$, falls ein solcher vorhanden ist. Ansonsten ist es der tiefste Knoten, auf dem Pfad von der Wurzel zu $v$, bei dem $v$ im linkem Teilbaum liegt. Abbildung \ref{fig:VorgängerNachfolger} zeigt Vorgänger und Nachfolger eines Knotens. Als \textbf{Vorfahre} eines Knotens $v$ bezeichnet man alle Knoten auf dem Pfad von der Wurzel zu $v$, inklusive $v$ selbst. 

\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Einleitung/VorgängerNachfolger"}
	\caption{Darstellung von Vorgänger und Nachfolger. }
	\label{fig:VorgängerNachfolger}
\end{figure}
\paragraph{Total geordnete Menge} 
Eine Menge $M$ wird als \textbf{total geordnet} bezeichnet wenn auf ihr eine zweistellige Relation $\leq$ definiert ist, die folgende Eigenschaften erfüllt.\\
Für alle $a$,$b$,$c$ $\in M$ gilt:
\begin{align*}
\text{1. } & (a,a) \in R  &\text{  (reflexiv)}\\
\text{2. } & (a,b) \in R  \land  (a,b) \in R \Rightarrow a = b  &\text{  (antisymmetrisch)}\\
\text{3. } & (a,b) \in R  \land  (b,c) \in R \Rightarrow  (a,c) \in R  &\text{  (transitiv)}\\
\text{4. } & (a,b) \notin R \Rightarrow  (b,a) \in R   &\text{  (total)}\\
\end{align*}
Die Eigenschaften 1,2 und 4 werden benötigt um für zwei beliebige Elemente aus der Menge feststellen zu können ob sie gleich sind, oder bei Ungleichheit, welches Element weiter links bzw. rechts im BST liegen muss. Dafür wird z.B getestet ob die Elemente $(a,b)$ und $(b, a)$ in der Relation liegen. Eigenschaft 3 ist notwendig, denn liegt $b$ weiter rechts im BST als $a$ und $c$ liegt weiter rechts als $b$, dann liegt $c$ natürlich auch weiter rechts als $a$. \\
Die von uns verwendete \enquote{Kleiner-Gleich-Beziehung} auf den natürlichen Zahlen erfüllt alle Eigenschaften.
\\
\\




\paragraph{Verändern eines BST durch Rotationen.}
Wird ein BST durch eine Veränderung in einen anderen BST überführt, kann es passieren, dass sich die Eigenschaften eines Knoten ändern. Um nicht immer erwähnen zu müssen auf welchen BST sich eine Aussage bezieht, wird es ab jetzt durchgängig so sein, dass sich ein Variablenname ohne angefügten Hochstrich auf den BST vor der Änderung bezieht. Der gleiche Variablenname mit angefügtem Hochstrich bezieht sich dann auf den selben Knoten nach der Änderung. Z.B. bezieht sich $x$ auf den Knoten mit Schlüssel $k$, in der Ausgangssituation, dann bezieht sich $x'$ auf den Knoten mit Schlüssel $k$ nach dem Ausführen der Änderung. \\

\noindent\textbf{Rotationen} können verwendet werden um lokale Änderungen an der Struktur eines BST durchzuführen, ohne eine der geforderten Eigenschaften zu verletzen. Es wird zwischen der Linksrotation und der Rechtsrotation 
unterschieden. Hier wird zunächst auf die in Abbildung \ref{fig:Linksrotation} dargestellte Linksrotation eingegangen. 
Sei $x$ der Knoten auf dem eine Linksrotation durchgeführt wird. Sei $z$ der Elternknoten von $x$. $z$ muss existieren, ansonsten darf auf $x$ keine Rotation durchgeführt werden. Sei $B$ der linke Teilbaum von $x$. Nach der Rotation ist $x'$ linkes bzw. rechtes Kind von dem Knoten, an dem $z$ linkes bzw. rechtes Kind war. $z'$ ist linkes Kind von $x'$. Die Wurzel von $B '$ ist rechtes Kind von $z'$. Unabhängig von der Anzahl der im BST enthaltenen Knoten und der Ausführungsstelle im BST ist eine Linksrotation also mit dem Aufwand verbunden drei Zeiger umzusetzen. Zu beachten ist, dass die Höhen von $x'$ und der Knoten in dessen, ansonsten unverändertem, rechtem Teilbaum jeweils um eins größer sind als die von $x$ und den Knoten in dessen rechtem Teilbaum. Die Höhe der Knoten im Teilbaum mit Wurzel $z'$ sind jeweils um eins kleiner als vor der Rotation.
Abbildung \ref{fig:Rechtsrotation} zeigt die symmetrische Rechtsrotation. Man muss im obigen Beschreibung lediglich links durch rechts ersetzen und umgekehrt. Dass es durch eine Rotation zu keiner Verletzung der BST Eigenschaften kommt, sieht man den Abbildungen direkt an. In Abbildung \ref{fig:LinksRechtsRotation} erkennt man, dass sich die Wirkung einer Rotation auf $x$ durch eine gegenläufige Rotation auf $z'$ aufheben lässt.  
\begin{figure}[h]
	\centering
	\includegraphics[width= 1.2\textwidth]{"Medien/Einleitung/Linksrotation"}
	\caption{Linksrotation auf Knoten x. }
	\label{fig:Linksrotation}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width= 1.2\textwidth]{"Medien/Einleitung/Rechtsrotation"}
	\caption{Rechtsrotation auf Knoten x. }
	\label{fig:Rechtsrotation}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width= 1.2\textwidth]{"Medien/Einleitung/LinksRechtsRotation"}
	\caption{Gegenseitiges aufheben von Rotationen}
	\label{fig:LinksRechtsRotation}
\end{figure}

\paragraph{Grundoperationen \textit{search}, \textit{insert} und \textit{delete}} \label{BST Operationen}
Hier geht es nur um die Standardvarianten eines BST. Später werden Varianten gezeigt die von diesem Verhalten zum Teil deutlich abweichen. Innerhalb Operationen wird häufig von einem Knoten aus direkt
auf dessen Elternknoten zugegriffen, so dass man sich im Baum auch nach oben hin bewegen kann. In Implementierungen wird das so umgesetzt, dass es zusätzlich zu den beiden Zeigern auf die Kinder noch einen zum Elternknoten gibt.  Innerhalb eines Pfades werden in dieser Arbeit jedoch entweder nur Zeiger auf Kinder oder nur auf Elternknoten verwendet. Es sei ein BST $T$ gegeben. \\
Die Operation \textit{search(key $k$)} gibt eine Referenz auf den Knoten im BST zurück, dessen Schlüssel mit $k$ übereinstimmt. Die Operation startet an der Wurzel und vergleicht den darin enthaltenen Schlüssel mit dem Gesuchten. Ist der gesuchte Schlüssel kleiner, muss er sich im linken Teilbaum des betrachtetem Knoten befinden und die Suche wird bei dessen Wurzel fortgesetzt. Ist der Schlüssel größer, muss er sich im rechten Teilbaum befinden und die Suche wird bei dessen Wurzel fortgesetzt. Dieses Verhalten iteriert solange bis der gesuchte Schlüssel gefunden ist, oder der Teilbaum bei dem die Suche fortgesetzt werden müsste, leer ist. Ist das Letztere der Fall, ist der gesuchte Schlüssel im Baum nicht vorhanden und es wird eine leere Referenz zurückgegeben. In keinem Fall kommt es zu einer Veränderung des BST.\\
Mit \textit{insert(key $k$)}  kann eine Schlüsselmenge um den Schlüssel $k$ erweitert werden. 
Bei \textit{insert(key $k$)} wird sich zunächst wie bei  \textit{search(key $k$)} verhalten. Wird $k$ gefunden, wird die Operation abgebrochen und der BST bleibt unverändert. Wird ein leerer Teilbaum $T_2$ erreicht, wird ein neu erzeugter Knoten mit Schlüssel $k$ an der Position von $T_2$ eingefügt. Durch den neuen Knoten wird keine BST Eigenschaft verletzt. Durch ersetzen eines leeren Teilbaumes, durch einen Knoten bleibt es bei einem binären Baum. Das Verhalten von  \textit{insert} stellt sicher, dass $k$ nur in linken Teilbäumen von Knoten mit Schlüssel $> k$ bzw. in rechten Teilbäumen von Knoten mit Schlüssel~ $< k$ enthalten ist.    \\
\begin{figure}[h]
	\centering
	\includegraphics[width= 1.2\textwidth]{"Medien/Einleitung/SuchenEinfügen"}
	\caption{Links zeigt eine Suche nach dem Schlüssel 15. Rechts das Einfügen des Schlüssels 13}
	\label{fig:SuchenEinfügen}
\end{figure}
\noindent Auch bei \textit{delete(key $k$)} wird sich zunächst wie beim  \textit{search(key $k$)} verhalten. Ist $k$ im BST nicht vorhanden wird abgebrochen und der BST bleibt unverändert. Ansonsten werden drei Fälle unterschieden.
Sei $v$ der Knoten mit Schlüssel $k$.
\begin{enumerate}
	\item $v$ ist ein Blatt: \\
	$v$ kann ohne weiteres aus dem BST entfernt werden.
	\item $v$ hat genau ein Kind $c$:\\
	Ist $v$ die Wurzel kann er entfernt werden und $c$ wird zur neuen Wurzel. Ansonsten ist $v$ entweder ein linkes oder ein rechtes Kind eines Knoten $w$. $c$ nimmt nun den Platz von $v$ im BST ein. Das bedeutet, dass die Kanten von $w$ nach $v$ und von $v$ nach $c$ entfernt werden. Außerdem wird eine Kante von $w$ nach $c$ so eingefügt, dass $c$ wie zuvor $v$ das linke bzw. rechte Kind von $w$ wird. 
	\item $v$ hat zwei Kinder:\\
	Sei $T_l$ der linke Teilbaum von $v$ und $T_r$ der Rechte.
	Sei $z$ der Knoten mit dem kleinsten Schlüssel im rechten Teilbaum von $v$. Als Knoten mit dem kleinsten Schlüssel im rechten Teilbaum von $v$, kann $z$ kein linkes Kind haben. Ist $z$ ein Blatt wird seine eingehende Kante entfernt. Hat $z$ ein rechtes Kind $z_r$, so nimmt dieses, analog zur Beschreibung im Fall 2, den Platz von $z$ ein. In beiden Fällen ist $z$ nun ein Knoten ohne Kante. Im nächsten Schritt nimmt nun $z$ den Platz von $v$ ein, $T_l$ wird links an $z$ angefügt und $T_r$ rechts. War $v$ zu Beginn die Wurzel, so wird $z'$ zur neuen Wurzel.\\
	In keinen Teilbäumen eines Knotens außer denen von $z$ kommen Schlüssel hinzu. Um eventuelle Verletzungen von Eigenschaften festzustellen, kann sich also auf $z'$ beschränkt werden. Der linke Teilbaum von $z'$ war der linke Teilbaum von $v$ und der Schlüssel von $v$ ist kleiner als der von $z$. Der rechte Teilbaum von $z$ enthält die Schlüssel des rechten Teilbaumes von $v$ mit Ausnahme des Schlüssels von $z$ selbst. $z$ wurde gerade ausgewählt weil sein Schlüssel der Kleinste in diesem Teilbaum ist. 
	
	
	
	
\end{enumerate} 
\begin{figure}[h]
	\centering
	\includegraphics[width= 1.2\textwidth]{"Medien/Einleitung/löschen"}
	\caption{Löschen des Schlüssels 10}
	\label{fig:löschen}
\end{figure}
\paragraph{Laufzeit}
Die worst-case-Laufzeit der drei Operationen ist jeweils $\mathit{O(h)}$, wobei $h$ die Höhe von $T$ ist. Bei \textit{search} werden maximal $h$ Knoten aus $T$ betrachtet. Beim Einfügen überlagern die Kosten der Suche, die konstanten Kosten für das Anhängen des neuen Knotens. Bei \textit{delete} wird in Fall eins und zwei nach dem Suchen ebenfalls nur noch lokal beim gesuchten Knoten gearbeitet. Bei \textit{delete} mit Fall drei muss zunächst zum Knoten $z$ erreicht werden, dafür sind maximal $h$ Schritte notwendig. Danach muss $v$ erreicht werden, wozu ebenfalls maximal $h$ Schritte notwendig sind. Die Kosten für das Entfernen und Hinzufügen von Kanten sind an beiden Stellen konstant.  



\paragraph{Unterschiedliche Baumhöhen}
Da die Höhe $h$ eines BST $T$ mit $n$ Knoten entscheidend für die Laufzeit der vorgestellten Operationen ist, wird hier auf diese eingegangen. Die maximale Höhe $n$ erreicht ein BST wenn es ein Blatt im BST gibt und jeder andere Knoten ein Halbblatt ist. Die Baumstruktur geht in diesem Fall über zu einer Listenstruktur über, dies wird als \textbf{entarten} bezeichnet. Minimal wird $h$ wenn $T$ \textbf{vollständig balanciert} ist. Das ist der Fall wenn alle Ebenen über der Untersten vollständig besetzt sind. Sind zusätzlich in der untersten Ebene, links von jedem Knoten, alle Knoten enthalten, wird der BST als \textbf{komplett} bezeichnet, siehe Abbildung \ref{fig:kompletterBaum}. 
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Einleitung/kompletterBaum"}
	\caption{Kompletter BST mit 12 Knoten}
	\label{fig:kompletterBaum}
\end{figure}


\begin{Lemma} Die Höhe eines vollständig balancierten BST $T$ mit $n$ Knoten ist $ \lfloor \log_2{(n)} \rfloor + 1 $. 
\end{Lemma}
\begin{proof}
	
	Es sei $\mathit{N(h)}$ die maximale Anzahl an Knoten in einem vollständig balancierten BST mit Höhe $h$.
	$\mathit{N(h)}$  berechnet sich indem die maximale Anzahl an Knoten jeder Ebene aufaddiert wird.\\
	\begin{align*}
	\mathit{N(h)} = \sum\limits_{i=0}^{h-1} 2^i = 2^h - 1 
	\end{align*}
	
	\noindent	$h$ ist minimal wenn gilt:\\
	\begin{align*}
	\mathit{N(h-1)} &< n \leq \mathit{N(h)}\\
	\Leftrightarrow \mathit{N(h-1)} + 1 &\leq n < \mathit{N(h)} + 1\\
	\end{align*}
	Einsetzen:\\
	\begin{align*}
	&2^{h - 1} \leq n < 2^h\\
	\Rightarrow & h =  \lfloor \log_2{(n)} \rfloor + 1
	\end{align*}
	
\end{proof}


\newpage
\section{Dynamische Optimalität}
Dieses Kapitel beschäftigt sich vor allem mit der Laufzeit von Folgen von \textit{access} Operationen, eine speziellere Form der \textit{search} Operation.  
\subsection{BST Zugriffsfolgen}
Sei $T$ ein BST mit der Schlüsselmenge $K$. Beschränkt man den Parameter von \textit{search} auf $k \in K $, wird  die Operation als \textit{access} bezeichnet. In diesem Kapitel werden Folgen solcher \textit{access} Operationen auf einem BST mit unveränderlicher Schlüsselmenge betrachtet. Notiert wird eine solche \textbf{Zugriffsfolge} durch Angabe der Parameter. Bei der Zugriffsfolge $x_1,x_2,...x_m$ wird also zunächst \textit{access($x_1$)} ausgeführt, dann \textit{access($x_2$)} usw. $m$ ist die Länge von $X$. Bei BST wird bezüglich Zugriffsfolge zwischen online und offline Varianten unterschieden. Bei \textbf{offline BST} ist die Zugriffsfolge zu Beginn bereits bekannt, somit kann ein Startzustand gewählt werden, der die Kosten minimiert. Beim \textbf{online BST} ist die Zugriffsfolge zu Beginn nicht bekannt. Bei einer worst case Laufzeit-Analyse muss somit von dem Startzustand ausgegangen werden, bei dem die Kosten am höchsten sind.
In dieser Arbeit werden \textit{access} Operation betrachtet die folgende Eigenschaften einhalten:

\begin{enumerate} 
	\item Die Operation verfügt über genau einen Zeiger $p$ in den BST. Dieser wird zu Beginn so initialisiert, dass er auf die Wurzel zeigt. Terminiert der Algorithmus muss $p$ auf den Knoten mit Schlüssel $k$ zeigen.
	\item Der Algorithmus führt eine Folge dieser Einzelschritte durch:
	\begin{itemize}
		\item Setze $p$ auf das linke Kind von $p$.
		\item Setze $p$ auf das rechte Kind von $p$.
		\item Setze $p$ auf den Elternknoten von $p$.
		\item Führe eine Rotation auf $p$ aus.
	\end{itemize}  
	
\end{enumerate}


\noindent 	Zur Auswahl des nächsten Einzelschrittes können zusätzliche in $p$ gespeicherte Hilfsdaten verwendet werden. Es darf nur auf die Daten des Knotens zugegriffen (lesend oder schreibend) werden, auf den $p$ zeigt. Es wird $n = \vert K \vert$ gesetzt. Außerdem werden hier pro Knoten als Hilfsdaten nur konstant viele Konstanten und Variablen zugelassen, die jeweils eine Größenordnung von $O\left(\log \left(n\right)\right)$  haben dürfen.

\noindent Die Initialisierung und die Ausführung jedes Einzelschrittes aus Punkt 2 kann in konstanter Zeit durchgeführt werden. Es werden jeweils Einheitskosten von $1$ verwendet. Höhere angenommene Kosten würden die Gesamtkosten lediglich um einen konstanten Faktor erhöhen. Es sei $a$ die Anzahl der insgesamt durchgeführten Einzelschritte während einer Zugriffsfolge $X$ mit Länge $m$. Dann berechnen sich die Gesamtkosten zum Ausführen von $X$ mit $a + m$. Es muss zu jeder Schlüsselmenge und jeder Zugriffsfolge zumindest einen offline BST geben, so dass die Gesamtkosten keines anderen niedriger sind. Diese Kosten werden als \textbf{$\mathit{OPT\left(X\right)}$} bezeichnet.\\  In \cite{nRotations} wurde gezeigt, dass der Zustand eines BST mit maximal $2n -2$ Rotationen in jeden anderen BST mit der gleichen Schlüsselmenge überführt werden kann. Da bei der Berechnung der Kosten für  $\mathit{OPT(X)}$, $m$ ebenfalls als Summand vorkommt, können die zusätzlichen Kosten der online Varianten, für $m > n$ asymptotisch betrachtet vernachlässigt werden. \\
\noindent Als \textbf{dynamisch optimal } wird ein BST bezeichnet wenn er eine beliebige Zugriffsfolge $X$ in $O\left(\mathit{OPT}\left(X\right)\right)$ Zeit ausführen kann. Ein BST der jede Zugriffsfolge in $O\left(c \cdot \mathit{OPT}\left(X\right)\right)$ Zeit ausführt, wird als \textbf{c-competitive} bezeichnet. Es konnte bis heute für keinen BST bewiesen werden, dass er dynamisch optimal ist. Es wurden aber mehrere untere Schranken für $\mathit{OPT}\left(X\right)$ gefunden. Eine davon wird  nun vorgestellt.


\subsection{Erste untere Schranke von Wilber} \label{wilberBound}
Robert Wilber hat in \cite{wilberLowerBounds} zwei Methoden zur Berechnung unterer Schranken für die Laufzeit von Zugriffsfolgen bei BST vorgestellt. Hier wird auf die Erste davon eingegangen. Im folgenden werden offline BST betrachtet, bei denen während einer \textit{access($k$)} Operation, der Knoten mit Schlüssel $k$, durch Rotationen zur Wurzel des BST gemacht wird. Ein solcher BST wird als \textbf{standad offline BST} bezeichnet. Asymptotisch betrachtet entsteht hierdurch kein Verlust der Allgemeinheit. Sei $v_p$ der Knoten auf den $p$ zum Zeitpunkt $t$ direkt vor der Terminierung von \textit{access} zeigt. Sei $d$ die Tiefe von $v_p$ . Dann sind mindestens Kosten $d + 1$ entstanden. Mit $d$ Rotationen kann $v_p$ zur Wurzel gemacht werden und mit $d$ weiteren Rotationen kann der Zustand zum Zeitpunkt $t$ wieder hergestellt werden.
Für einen BST $T$ mit Schlüsselmenge $K_T$ und einer Zugriffsfolge $X$ notieren wir die minimalen Kosten eines wie eben vorgestellt arbeitenden BST mit $W(X, T)$. Im folgenden wird angenommen, dass 
$K = \{  i \in \mathbb{N} \vert i \in \left[j,k\right] \textit{ mit } j,k \in  \mathbb{N} \} $ gilt. Dadurch entsteht kein Verlust der Allgemeinheit, denn anderenfalls könnte man die Schlüsselmenge einfach aufsteigend sortiert mit $j$ startend durchnummerieren. Eine Rotation wird innerhalb dieses Kapitels mit $\left(i, j\right)$ notiert. $i$ ist dabei der Schlüssel des Knotens $v$ auf dem die Rotation ausgeführt wird. $j$~ist der Schlüssel des Elternknoten von $v$, vor Ausführung der Rotation. Aus einer Folge von Rotationen $r~=~\left(i_1,j_1 \right),\left(i_2,j_2 \right),..,\left(i_m,j_m \right)$ erhält man die Folge  $r^y_x = \left(i_{1'},j_{1'}\right),\left(i_{2'},j_{2'} \right),..,\left(i_{m'},j_{m'} \right)$  in dem man aus $r$ jede Rotation entfernt bei der $i\notin \left[l,r\right] \lor j\notin \left[l,r\right]$ gilt. Ähnlich erhält man aus $X$ die Zugriffsfolge $X^y_x$ in dem aus $X$ alle Schlüssel $k$ entfernt werden, für die $k < x  \lor k > y$ gilt.

\paragraph{lower bound tree} \label{wilberLowerBoundTree}
Ein lower bound tree $Y$ zu $T$ ist ein BST, der genau $2 \vert K\vert  - 1$ Knoten enthält. Seine $\vert K \vert$ Blätter enthalten die Schlüssel aus $K$. Die $\vert K \vert - 1$ internen Knoten enthalten die Schlüssel aus der Menge $\{r \in R \vert \exists i,j \in K \colon \left( i + 1 = j \land r = i + 0,5\right)\}$. $Y$ kann immer erstellt werden indem zunächst ein BST $Y_i$ mit den internen Knoten von $Y$ erzeugt wird. Ein Blatt wird dann an der Position angefügt, an der die Standardvariante von \textit{insert} angewendet auf $Y_i$ ihren Schlüssel einfügen würde. Dass hierbei für zwei Blätter mit Schlüssel $k_1, k_2$ die gleiche Position gewählt wird ist ausgeschlossen, da es einen internen Knoten mit Schlüssel $k_i$ so geben muss dass $\left(k_1 < k_i < k_2\right) \lor \left(k_1 > k_i > k_2 \right)$ gilt. An der Konstruktionsanleitung ist zu erkennen, dass zu den meisten BST mehrere mögliche lower bound trees existieren. Abbildung \ref{fig:lowerBoundTree} zeigt eine beispielhafte Konstellation. \\



\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{"Medien/DynOpt/lowerBoundTree"}
	\caption{Rechts ist ein möglicher lower bound tree zum linken BST dargestellt.  }
	\label{fig:lowerBoundTree}
\end{figure}

\noindent Nun wird die Funkion $_X(T, Y, X) $ vorgestellt. Ihre Parameter sind ein BST $T$, ein lower bound tree $Y$ und eine Zugriffsfolge $X$. $Y$ und $X$ müssen passend für $T$ erstellt sein, ansonsten ist $_X(T, Y, X) $ undefiniert . Die Auswertung erfolgt zu einer natürlichen Zahl. Sei $U$ die Menge der internen Knoten von $Y$ und $m$ die Länge von $X$. Sei $u \in U$ und $l$ der kleinste Schlüssel eines Blattes im Teilbaum mit Wurzel $u$, sowie $r$ der größte Schlüssel eines solchen Blattes. Sei $v$ der tiefste gemeinsame Vorfahre der Knoten mit Schlüssel aus $\left[l, r\right]$  in $T$. Sei $o$ die Folge $o_0, o_1,..,o_m =  \mathit{key}(v) \circ X^r_l$. $i \in \left[1,m\right]$ ist eine \textit{u-Transition} wenn gilt $\left( o_{i-1} < u \land o_i > u \right) \lor \left( o_{i-1} > u \land o_i < u \right)$. Die Funktion $\mathit{score}\left(u\right) \colon U \rightarrow \mathbb{N}$ ist definiert durch $\mathit{score}\left(u\right) = \vert\{i \in \mathbb{N}\ \vert \textit{i ist eine u-Transition}\} \vert$. Mit Hilfe von $\mathit{score}$ kann nun  $_X(T, Y, X) $ definiert werden.

\begin{align*}
_X(T, Y, X)  = m + \sum_{u \in U} {\mathit{score}} \left(u\right)
\end{align*} 

\noindent Im eigentlichen Satz wird $\mathit{W\left(X, T\right)} \geq {_X(T, Y, X)} $ gezeigt werden. Dafür werden aber noch ein Lemma und einige Begriffe benötigt Lemma. Der \textbf{linke innere Pfad} $\left(v_0,v_1,..,v_n \right)$ eines Knotens $v$ ist der längst mögliche Pfad für den gilt, $v_0$ ist das linke Kind von $v$ und für $i \in \{1,..,n\}$,$v_i$ ist das rechte Kind von $v_{i-1}$. Der \textbf{rechte innere Pfad} $\left(v_0,v_1,..,v_n \right)$ eines Knotens $v$ ist der längst mögliche Pfad für den gilt, $v_0$ ist das rechte Kind von $u$ und $v_i$ ist das linke Kind von $v_{i-1}$.\\ $T^r_l$ ist ein mit $\left[l,r\right]$ von $T$ abgeleiteter BST, so dass er genau die Schlüssel aus $T$ enthält, die in $\left[l, r\right]$ liegen. Sei $v_d$ der tiefste gemeinsame Vorfahre der Knoten mit Schlüssel aus  $\left[l,r\right]$ in $T$. (Existiert ein solcher nicht ist $T^r_l$ der leere Baum). Es muss $\mathit{key}(v_d) \in \left[l,r\right]$ gelten. Denn hat $v_d$ keine Kinder ist sein Schlüssel der Einzige aus $\left[l,r\right]$. Hat $v_d$ ein Kind $v_{c}$ und $\mathit{key}(v_d) \notin \left[l,r\right]$, dann wäre $v_{c}$ ein tieferer gemeinsamer Vorgänger der entsprechenden Knoten. Hat $v_d$ zwei Kinder gibt es drei Fälle:
\begin{itemize}
	\item Im linken und rechten Teilbaum von $v_d$ sind Schlüssel aus $\left[l,r\right]$ enthalten. Dann muss aufgrund der Links-Rechts-Beziehung  $\mathit{key}(v_d)$ auch in $\left[l,r\right]$ enthalten sein.
	\item In genau einem Teilbaum von $v_d$ sind Schlüssel aus $\left[l,r\right]$ enthalten. Sei $v_{c}$ die Wurzel dieses Teilbaumes. Gilt zusätzlich $\mathit{key}(v) \notin K^r_l$, dann wäre $v_c$ ein tieferer gemeinsamer Vorgänger der entsprechenden Knoten.
	\item In den beiden Teilbäumen sind keine Schlüssel aus $\left[l,r\right]$ enthalten.  Dann muss $\mathit{key}(v_d)$ der Einzige in $T^r_l$ enthaltene Schlüssel sein.
\end{itemize}

\noindent Ein Knoten $u_d$ mit Schlüssel $\mathit{key}(v_d)$ bildet die Wurzel von $T^r_l$. Nun wird beschrieben wie Knoten zu $T^r_l$ hinzugefügt werden.
Dazu werden zwei Mengen verwendet. $U$ ist eine zu Beginn leere Menge, $W$ enthält zu Beginn $u_d$.
\begin{enumerate}
	\item Gilt $U = W$, beende das Verfahren.
	\item Sei $w \in W$ ein Knoten mit $w \notin U$.  Sei $v$ der Knoten in $T$ mit $\mathit{key}(w ) = \mathit{key}(v)$. Sei $P_l$ der linke innere Pfad von $v$ und $P_r$ der rechte innere Pfad von $v$.
	\item Ist $P_l$ der leere Pfad weiter mit $5$.
	\item Sei $k_l$ der Schlüssel des Knoten mit der kleinsten Tiefe in $P_l$, für den gilt $k \geq l$. Erzeuge einen Knoten $w_l$ mit Schlüssel $k_l$ und füge ihn als linkes Kind an $w$ an. Füge $w_l$ zu $W$ hinzu.
	\item Ist $P_r$ der leere Pfad weiter mit $7$.
	\item Sei $k_r$ der Schlüssel des Knoten mit der kleinsten Tiefe in $P_r$, für den gilt  $k \leq r$. Erzeuge einen Knoten $w_r$ mit Schlüssel $k_r$ und füge ihn als rechtes Kind an $w$ an. Füge $w_r$ zu $W$ hinzu.	
	\item Füge $w$ zu $U$ hinzu, weiter mit $1$
\end{enumerate}
Das Verfahren muss terminieren da die Anzahl der Knoten von $T$ endlich ist. So konstruiert muss $T^r_l$ ein BST sein. Ein Beispiel stellt Abbildung \ref{fig:T_r_l} dar. 
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/DynOpt/T_r_l"}
	\caption{Links ein BST $T$. Rechts ein davon abgeleiteter BST $T^8_4$ .  }
	\label{fig:T_r_l}
\end{figure}

\noindent Sei $K_1$ die Schlüsselmenge von $T$ und $K_2$ die von $T^r_l$. Sei ${K^r_l = K_1 \cap \{i \in \mathbb{N}\vert i \in \left[l,r\right] \}}$. Jetzt wird noch darauf eingegangen warum $K_2 = K^r_l$ gilt \\

\noindent $K_2 \subseteqq  K^r_l$ ergibt sich direkt aus dem Verfahren zur Konstruktion von $T^r_l$.\\

\noindent $ K^r_l \subseteqq K_2$:\\
Sei $k \in K^r_l$ und $v_k$ der Knoten in $T$ mit $\mathit{key}(v_k) = k$. Es muss einen Pfad $P_T = \left(v_0,..,v_n\right)$ in $T$ geben, mit $v_0 = v_d$, $v_n = v_k$. Sei $m$ die Anzahl der Knoten in $P_T$, mit einem Schlüssel in  $\left[l,r\right]$. Nun folgt Induktion über $m$.\\
Für $m = 1$ gilt $k = \mathit{key}\left(v_d\right)$  und $k \in K_2$. \\
Induktionsschritt:\\
Sei $v_w$ der Knoten mit der größten Tiefe in $ v_0,..,v_{n-1}$ mit $\mathit{key}(v_w) \in~K_2$. Nach Induktionsvoraussetzung gibt es einen Knoten $u_w$ mit $\mathit{key}(u_w) = \mathit{key}(v_w)$ in $T^r_l$.  Es sei $\mathit{key}(v_w) > \mathit{key}(v_k)$, der andere Fall ist symmetrisch. Ist $v_k$ das linke Kind von $v_w$, dann enthält das linke Kind von $u_w$ den Schlüssel $\mathit{key}(v_k)$. Anderenfalls gilt für alle $v_j$ mit $w < j < k$, $\mathit{key}(v_j) < l < \mathit{key}(v_k)$. Somit muss $v_{w+1}$ ein linkes Kind sein und die Knoten in $P_T$ mit größerer Tiefe als der von $v_{w+1}$ müssen rechte Kinder sein. Damit ist auch in diesem Fall ein Knoten $u_k$ mit $\mathit{key}(u_k) = \mathit{key}(v_k)$ linkes Kind von $u_w$.  \\

\noindent Nun kommen wir zum Lemma:\\






\noindent Sei $v$ ein Knoten in $T$, dann wird ein Knoten in $T^r_l$ mit Schlüssel $\mathit{key}(v)$  mit $v^*$ bezeichnet.  
\newtheorem{Lemma3}{Lemma}[section] \label{lemmaWilber1}
\begin{Lemma3} Es sei $T$ ein BST mit Knoten $u, v$ so, dass $u$ ein Kind von $v$ ist. $T'$ ist der BST, der durch ausführen der Rotation $\left(\mathit{key}\left(u\right),\mathit{key}\left(v\right)\right)$ aus $T$ entsteht. Gilt $\mathit{key}\left(u\right),\mathit{key}\left(v\right) \in \left[l,r\right]$, dann ist ${T'}^r_l$ der BST der aus $T^r_l$ durch Ausführen von  $\left(\mathit{key}\left(u\right),\mathit{key}\left(v\right)\right)$ entsteht. Anderenfalls gilt ${T'}^r_l = T^r_l$.
\end{Lemma3}
\begin{proof}
	\noindent Für $u,v \notin \left[l,r\right]$ wird bei keinem inneren Pfad ein Knoten mit Schlüssel aus $\left[l,r\right]$ entfernt oder hinzugefügt.
	Nun werden die vier Fälle betrachtet bei denen entweder $\mathit{key}\left(u\right)$ oder $\mathit{key}\left(v\right)$ in $\left[l,r\right]$ liegt.
	\begin{enumerate}
		\item $u$ ist das linke Kind von $v$ und $\mathit{key}\left(u\right) < l$:\\
		Sei $w$ ein Knoten aus $T^r_l$ und $w'$ einer aus $T'{^r_l}$, mit $\mathit{key}(w) = \mathit{key}(w')$ und $\mathit{key}(w) \in \left[l,r\right]$. Es muss gezeigt werden, dass wenn $w$ ein linkes bzw. rechtes Kind mit Schlüssel $k$ hat, dann gilt dies auch für $w'$. Da $\mathit{key}(u) < l \leq \mathit{key}(w) $ gilt, kann weder $u$ noch $v$ im rechten Teilbaum von $w$ liegen. Somit ist bezüglich der rechten Kinder nichts zu zeigen. 
		Sei $P_l$ der linke innere Pfad von $w$. Ist $v$ nicht in $P_l$ enthalten und gilt $v \neq w$ dann gilt $P_l = P{_l}'$. Sei $w = v$, dann gilt $P_l = u  \circ  {P_l}'$, vergleiche Abbildung \ref{Kapitel 1 Rotationen}, und da $\mathit{key}(u) < l$, bleibt das linke Kind von $w$ unverändert. Nun sei $v$ in $P_l$ enthalten. Dann unterscheiden sich  $P_l$ und  ${P_l}'$ dadurch, dass ein Knoten mit $\mathit{key}(u)$ in $P'_l$ enthalten ist. Mit $u < l$ gilt aber, dass sich $w$ und $w'$ bezüglich des Schlüssels ihres linken Kindes nicht unterscheiden.
		\item $u$ ist das linke Kind von $v$ und $\mathit{key}\left(v\right) > r$:\\
		Mit vertauschen der Bezeichnungen von $v$ und $u$, erreicht man von $T'$ aus Fall 3, mit Ausführung der Rotation auf dieser Konstellation wieder $T$ aus Fall 3. Somit muss nichts weiter gezeigt werden. 
		\item $u$ ist das rechte Kind von $v$ und $\mathit{key}\left(u\right) > r$:\\
		Links-Rechts-Symmetrisch zu Fall 1. 
		\item $u$ ist das rechte Kind von $v$ und $\mathit{key}\left(v\right) < l$:\\
		Links-Rechts-Symmetrisch zu Fall 2. \\
		
	\end{enumerate}	
	\noindent Übrig bleibt noch die Konstellation $\mathit{key}\left(u\right),\mathit{key}(v) \in \left[l,r\right]$. 
	Betrachtet wird eine Rechtsrotation $\left(\mathit{key}\left(u\right),\mathit{key}\left(v\right)\right)$, die Linksrotation ist wieder symmetrisch. 
	Zu zeigen ist ${T'}^r_l = T{^r_l}' $.\\
	In $T$ verändern sich maximal drei innere Pfade.
	\begin{enumerate}
		\item Sei $u_r$ das rechte Kind von $u$. Sei $u,u_r,v_1,..,v_n$ der linke innere Pfad von $v$, dann ist $\left({u_r}',{v_1}',..,{v_n}'\right)$ der linke innere Pfad von $v'$. Es gilt ${l \leq \mathit{key}\left(u\right) < \mathit{key}\left(u_r\right) < \mathit{key}\left(v\right) \leq r}$. Damit ist ${{u_r}'}^*$ das linke Kind von ${v'}^*$.
		\item Sei $v_1,..,v_n$ der rechte innere Pfad von $u$, dann ist $\left(v',{v_1}',..,{v_n}'\right)$ der rechte innere Pfad von $u'$. Damit  ${v'}^*$ ist das rechte Kind von ${u'}^*$.
		\item Ist $v$ das linke bzw. rechte Kind eines Knoten $z$ mit $\mathit{key}(z) \in \left[r,l\right]$, dann sei  $v,v_1,..,v_n$ der linke bzw. rechte innere Pfad von $z$. Dann ist  $\left(u',v',{v_1}',..,{v_n}\right)'$ der linke bzw. rechte innere Pfad von $z'$. Dann ${u'}^*$ das linke bzw. rechte Kind von ${z'}^*$.
	\end{enumerate}
	\noindent Nun wird auf ${T}^r_l$ die Rotation $ \left(\mathit{key}\left(u^*\right),\mathit{key}\left(v^*\right)\right)$ ausgeführt. ${{u_r}^*}'$ ist linkes Kind von $v{^*}'$. $v{^*}'$ das rechte Kind von $u{^*}'$. Ist $v^*$ das linke bzw. rechte Kind eines Knoten $z^*$, dann ist $u{^*}'$ das linke bzw. rechte Kind von $z{^*}'$ und $u{^*}'$ das linke bzw. rechte Kind von $z{^*}'$. Damit gilt ${T'}^r_l = T{^r_l}'$.\\
	
\end{proof}

\newtheorem{Satz1}{Satz}[section] \label{satzWilber1}
\begin{Satz1} Es sei $T$ ein standard offline BST mit Schlüsselmenge\\ ${K = \{  i \in \mathbb{N} \vert i \in \left[j,k\right] \textit{ mit } j,k \in  \mathbb{N} \}} $. Sei $Y$ ein für $T$ erstellter lower bound tree und $X$ eine zu $T$ erstellte Zugriffsfolge mit Länge $m$. Dann gilt\\  $W\left(X, T\right) \geq {_X(T_0, Y, X)} $.  
\end{Satz1}
\begin{proof}
	Sei $U$ die Menge der internen Knoten von $Y$. Die Kosten zum Ausführen von $X$ sind die \textit{Anzahl der Einzelschritte} $ +~m$. Es reicht also aus zu zeigen, dass mehr als $\sum_{u \in U} {\mathit{score}} \left(u\right)$ Rotationen benötigt werden. Es wird Induktion über  $n = \vert K \vert$ angewendet. Sei $n = 1$, dann gibt es keinen internen Knoten in $Y$ und $\sum_{u \in U} {\mathit{score}} \left(u\right) = 0$. Der Induktionsanfang ist somit gemacht. Im folgenden sei $n \geq 2$.\\
	Sei $R = r_1,r_2,..,r_l$ die Folge der insgesamt durchgeführten Rotationen. Für $i \in \{1,..,r\}$ sei $T_i$ der BST, der entsteht nachdem $r_i$ auf $T_{i-1}$ ausgeführt wurde. Sei $w$ die Wurzel von $Y$, mit Schlüssel $k_w$,. Sei $Y^1$ bzw. $Y^2$ der linke bzw. rechte Teilbaum von $w$. Es ist zu beachten, dass $Y^1$ ein lower bound tree zu $T_{1}^{k_w}$ ist und  $Y^2$ einer zu $T^\infty_{k_w}$. ${T_{i}}_1^{k_w}$ wird im folgenden als ${T_i}^1$ bezeichnet und ${T_{i}}_{k_w}^{\infty}$ als ${T_i}^2$. Da $n \geq 2$ muss $w$ ein interner Knoten sein. Sei  $R^1 = {r^1}_1,{r^1}_2,..,{r^1}_{l^1} = R^{k_w}_1$ und $R^2 = r^2_1,r^2_2,..,r^2_{l^2} = R^\infty_{k_w}$. Mit $M$ wird die Folge bezeichnet, die entsteht, wenn aus $R$ alle Rotationen entfernt werden, die in $R^1$ oder $R^2$ enthalten sind. Sei $l_M$ die Länge von $M$. Es muss $l = l^1 + l^2 + l_M$ gelten, da keine Rotation sowohl in $R^1$ als auch in $R^2$ enthalten sein kann. $X_1$ ist die Folge die entsteht wenn aus $X$ alle Schlüssel $k > k_w$ entfernt werden. $X_2$ entsteht durch entfernen aller Schlüssel $k < k_w$ aus $X$. Für $j \in \{1,2\}$, sei $U^j$ die Menge der internen Knoten von $Y^j$. Sei $T^{j*}_0,T^{j*}_1,..,T^{j*}_{l^t}$ die entstehende Folge, wenn aus $T^{j}_0,T^{j}_1,..,T^{j}_{l}$ die $T^j_t$ entfernt werden für die $T^j_{t-1} = T^j_t$ gilt.\\ Mit Lemma \ref{lemmaWilber1} kann  $T^{j*}_{t}$ durch Ausführung der Rotation $r^j_t$ auf $T^{j*}_{t-1}$ abgeleitet werden. Dadurch folgt durch dieses Lemma, dass wenn ein Knoten mit Schlüssel $k < w$ bzw. $k > w$ die Wurzel von $T_t$ ist dann muss die Wurzel von $T^1_t$ bzw. $T^2_t$ auch Schlüssel $k$ haben. $R^j$ bringt also der Reihe nach, die Knoten mit den Schlüsseln aus $X^j$ an die Wurzel von $T^j$ und  $X^j$ kann als Zugriffsfolge für $T^j$ aufgefasst werden. Da die Knotenzahl in $T^j$ kleiner $n$ sein muss gilt mit der Induktionsvoraussetzung  $l_j \geq \sum_{u \in U^j} {\mathit{score}} (u)$.\\
	Sei $\sigma = \mathit{key}(w) \circ X$. Sei $a$ eine $w$-Transition. Nun wird angenommen dass $\sigma_{a-1} < \mathit{key}(w)  \land \sigma_{a} > \mathit{key}(w)$. Der andere Fall kann davon problemlos abgeleitet werden. Sei $y$ der Knoten in $T$ mit $\mathit{key}(y) = \sigma_{a-1}$ und $z$ der Knoten in $T$ mit $\mathit{key}(z) = \sigma_{a}$. Nach \textit{access($\sigma_{a-1}$)} ist $y$ die Wurzel von $T$. $z$ muss sich im rechten Teilbaum von $y$ befinden. Nach  \textit{access($\sigma_{a}$)} ist $z$ die Wurzel von $T$. $y$ muss sich im linken Teilbaum von $z$ befinden. Somit muss während \textit{access($\sigma_{a}$)} die Rotation $(\mathit{key}(z),\mathit{key}(y))$ ausgeführt worden sein. $(\mathit{key}(z),\mathit{key}(y))$ muss in $M$ enthalten sein. Für jede $w$-Transition ist also mindestens eine Rotation in $M$ enthalten, also $l_M \geq  \mathit{score} \left(w\right)$.\\
	Zusammengefasst ergibt sich:
	
	\begin{align*}
	l = l^1 + l^2 + l_M \geq \sum_{u \in U^1} {\mathit{score}} (u) + \sum_{u \in U^2}{\mathit{score}} (u) +  {\mathit{score}} (w)
	\end{align*}
	
	
	
	
\end{proof}

\noindent Daraus folgt direkt $\mathit{OPT}\left(X\right) \geq {_X(T, Y, X)} $ für beliebige BST $T$.  


\subsection{Bit reversal permutation } \label{abschnittBitReversal}
In diesem Abschnitt wird gezeigt, dass es Zugriffsfolgen mit Länge $m$ für BST $T$ gibt, so dass für die Laufzeit  $\Theta\left(m \log n\right)$ gilt, mit $n$ ist die Anzahl der Knoten von $T$. Hier werden speziell die Zugriffsfolgen betrachtet, die als \textbf{bit reversal permutation} bezeichnet werden. Auf $O\left(m \log n\right)$ wird hier nicht weiter eingegangen. Die balancierten BST garantieren jedoch diese Schranke und mit dem Rot-Schwarz-Baum wird später ein solcher noch vorgestellt.
$\Omega\left(m \log n\right)$  wird mit Hilfe der ersten unteren Schranke von Wilber gezeigt und ein Beweis ist ebenfalls in \cite{wilberLowerBounds} enthalten. \\
Nun wird zunächst der Aufbau einer solchen Zugriffsfolge eingegangen. Sei $l \in \mathbb{N}$ und $i \in \{0,1,..,l-1\}$. Eine Folge  $b_{l-1},b_{l-2},..,b_0$ mit $b_i \in \{0,1\}$, kann als Zahl zur Basis $2$ interpretiert werden. $T$ enthält alle Schlüssel die als solche Folge dargestellt werden können. Die Schlüsselmenge von $T$ ist deshalb $K_l = \{0,1,..,2^l -1\}$. 
Die Funktion $\mathit{br}_l(k)\colon K \rightarrow K$ ist wie folgt definiert. Sei {$b_{l-1},b_{l-2},..,b_{0}$} die Binärdarstellung von $k$, dann gilt 
\begin{align*}
\mathit{br}_l(k) = \sum_{i = 0}^{l-1} b_{\left(l-1-i\right)} \cdot 2^i
\end{align*}
$\mathit{br}_l(k)$ gibt also gerade den Wert der \enquote{umgekehrten} Binärdarstellung von $k$ zurück. Die bit reversal permutation zu $l$ ist die Zugriffsfolge\\ ${\mathit{br}_l(0),\mathit{br}_l(1),..,\mathit{br}_l(2^l-1)}$. Diese wird ab jetzt mit $X$ bezeichnet. Tabelle \ref{tab:bitReversal} zeigt die bit reveral permutation mit $l  = 4$. Sei $y = \max\left(K_l\right) /2 = 2^{l-1} - 0,5 $. Da $b_0$ in den Binärdarstellungen zu $0, 1,.., 2^l-1$ alterniert, alterniert $b_{l-1}$ in $X$. Aus $2^{l-1} > y$ folgt $\mathit{br}_l(k) < y \Rightarrow \mathit{br}_l(k +1) > y$ und $\mathit{br}_l(k) > y \Rightarrow \mathit{br}_l(k +1) < y$. Da $\vert K_l \vert = 2^l$ kann zu $T$ ein vollständig balancierter lower bound tree $Y$ erstellt werden. Sei $w$ die Wurzel von $Y$. Da im linken Teilbaum von $w$ genau so viele Blätter wie im rechten vorhanden sein müssen, kann nur $y$ der Schlüssel von $w$ sein. Zu einer Zugriffsfolge $X = x_0,x_1,..,x_m$ bezeichnet $X^r_l$ wieder die Zugriffsfolge, die entsteht wenn aus $X$ alle Schlüssel $k$, mit $k < l \lor k > r$ entfernt werden. $X + i$ mit $i \in \mathbb{N}$ bezeichnet im Folgenden die Folge $x_0 + i, x_1 + i,.., x_m + i$.\\

\begin{table}
	\begin{center}
		\begin{tabular}[c]{|l|l|l|l|}
			\hline
			$i$ & $\mathit{bin}\left(i\right)$ &$\mathit{bin}\left(\mathit{br}\left(i\right)\right)$  &$x_i$\\
			\hline
			$0$ & $0000$ &$0000$  &$0$\\
			\hline
			$1$ & $0001$ &$1000$  &$8$\\
			\hline
			$2$ & $0010$ &$0100$  &$4$\\
			\hline
			$3$ & $0011$ &$1100$  &$12$\\
			\hline
			$4$ & $0100$ &$0010$  &$2$\\
			\hline
			$5$ & $0101$ &$1010$  &$10$\\
			\hline
			$6$ & $0110$ &$0110$  &$6$\\
			\hline
			$7$ & $0111$ &$1110$  &$14$\\
			\hline
			$8$ & $1000$ &$0001$  &$1$\\
			\hline
			$9$ & $1001$ &$1001$  &$9$\\
			\hline
			$10$& $1010$ &$0101$  &$5$\\
			\hline
			$11$& $1011$ &$1101$  &$13$\\
			\hline
			$12$ &$1100$ &$0011$  &$3$\\
			\hline
			$13$ &$1101$ &$1011$  &$11$\\
			\hline
			$14$ &$1110$ &$0111$  &$7$\\
			\hline
			$15$ &$1111$ &$1111$  &$15$\\
			\hline
		\end{tabular}
		\caption{bit reveral permutation für $l=4$} 
		\label{tab:bitReversal}
	\end{center}
\end{table}



\newtheorem{Korollar1}{Korollar}[section]
\begin{Korollar1} Sei $l \in \mathbb{N}$. Sei $T$ ein BST mit Schlüsselmenge\\ ${K_l = \{0,1,..,2^l -1\}}$ und $n = 2^l$. Sei $X = x_0, x_1,..,x_{n-1}$ die bit reversal permutation zu $l$ und $Y$ der vollständig balancierte lower bound tree zu $T$. Dann gilt  $W\left(X,T\right) \geq n \log_2 \left(n\right) + 1 $. 
\end{Korollar1}
\begin{proof}
	Sei $U$ die Menge der internen Knoten von $Y$. Mit Satz \ref{satzWilber1} reicht es aus 
	
	\begin{align*}
	\sum_{u \in U} {\mathit{score}\left(u\right)} \geq n \log_2 n + 1 - n 
	\end{align*} 
	zu zeigen. Dies geschieht mit Induktion über $l$. Für $l = 0$ besteht $Y$ aus einem einzigen Blatt. Damit gilt\\ $ W\left(X,T\right) \geq  \sum_{u \in U} {\mathit{score}\left(u\right)} + 1  > 0 = n \log_2 n + 1 - n $. \\
	Nun sei $l > 0$. Sei $w$ die Wurzel von $Y$, mit $k_w = \mathit{key}(w)$. Sei $T_0^{k_w}$ ein BST mit Schlüsselmenge $K_0^{k_w} =\{k \in \mathbb{N}\vert k \leq k_w\} = \{k \in \mathbb{N}\vert k \leq 2^{l-1} - 1\}$ und $T_{k_w}^\infty$ ein BST mit Schlüsselmenge  $ K^\infty_{k_w} = \{k \in \mathbb{N}\vert \exists n \in K_0^{k_w}\colon  k = n + 2^{l-1}\}$. Sei $Y^1$ bzw. $Y^2$ der linke bzw. rechte Teilbaum von $w$ und $U^1$ bzw. $U^2$ die Menge der internen Knoten von $Y^1$ bzw. $Y^2$. $Y^1$ und $Y^2$ sind vollständig balancierte lower bound trees zu $T_0^{k_w}$ und $T_{k_w}^\infty$. $X^{k_w}_0$ ist die bit reversal permutation für $T_0^{k_w}$. Außerdem gilt $X_{k_w}^\infty = X^{k_w}_0 + 2^{l-1}$. Mit der Induktionsvoraussetzung gilt deshalb, für $i \in \{1,2\}$,
	\begin{align*}
	\sum_{u \in U^i} {\mathit{score}\left(u\right)} \geq  \frac{n}{2} \log_2 \left(\frac{n}{2} \right) + 1 - \frac{n}{2}  
	\end{align*}
	Aus $\left(x_j < k_w \Rightarrow x_{j-1} > k_w \right) \land \left(x_j > k_w \Rightarrow x_{j-1} < k_w \right)$ folgt $\mathit{score}\left(w\right) \geq n-1$. Zusammenfassen ergibt
	\begin{align*}
	\sum_{u \in U} {\mathit{score}\left(u\right)} &\geq 2 \left( \frac{n}{2}  \log_2 \left(\frac{n}{2} \right) + 1 - \frac{n}{2} \right) + n - 1\\	
	&= n (l-1)  + 1 \\	
	&= n l + 1 -n \\
	&= n \log_2\left( n\right) + 1 - n\\	
	\end{align*}
	
\end{proof}

\noindent Die Schlüsselmenge  wurde beim Korollar auf ${K_l = \{0,1,..,2^l -1\}}$ festgelegt. Vielleicht wäre es aber mit einer anderen Schlüsselmenge $K$ möglich $X$ schneller auszuführen ? In jedem Fall müsste $K_l \subseteqq K$ gelten. Sei $R$ die Folge von Rotationen, die beim Ausführen von $X$ bei einem BST $T$ mit Schlüsselmenge $K$ entsteht. Sei $y = 2^l -1$ Mit Lemma \ref{lemmaWilber1} ist dann $R_0^y$ eine Folge von Rotationen zum Ausführen von $X$ auf $T_0^y$ und die Länge von $R$ kann nicht kleiner als die von $R_0^y$ sein. 



\subsection{Amortisierte Laufzeitanalyse}
Im nächsten Anschnitt werden die Kosten von amortisierten Laufzeitanalysen verwendet. Deshalb wird diese hier nun vorgestellt.
Sei $i \in \{0,..,m\}$. Bei der \textbf{amortisierten Laufzeitanalyse} wird eine Folge von $m$ Operationen betrachtet. Hierbei kann es sich $m$ mal um die gleiche Operation handeln, oder auch um verschiedene. Die \textbf{tatsächlichen Kosten}  $t_i$ stehen für die Kosten zum ausführen der $i$-ten Operation. Durch aufaddieren der tatsächlichen Kosten jeder einzelnen Operation erhält man \textbf{tatsächlichen Gesamtkosten}.  Stehen für die Laufzeit der Operationen jeweils nur obere Schraken zur Verfügung, kann man mit diesen genau so vorgehen, um eine obere Schranke für die Gesamtlaufzeit zu erhalten. So erzeugte obere Schranken können jedoch unnötig hoch sein. Die Idee bei einer amortisierten Analyse ist es, eingesparte Zeit durch schnell ausgeführte Operationen, den langsameren Operationen zur Verfügung zu stellen. Dabei wird insbesondere der aktuelle Zustand der zugrunde liegenden Datenstruktur vor und nach einer Operation betrachtet. Es gibt drei Methoden zur amortisierten Analyse, bei BST wird in der Regel die \textbf{Potentialfunktionmethode} verwendet.
\paragraph{Potentialfunktionmethode} \label{potentialfunktionsmethode} Eine Potentialfunktion $\Phi(D)$ ordnet einem Zustand einer Datenstruktur $D$ eine natürliche Zahl, \textbf{Potential} genannt, zu. Es bezeichnet $\Phi(D_i)$ das Potential von $D$ nach Ausführung der $i$-ten Operation. Die \textbf{amortisierten Kosten} $a_i$ einer Operation berücksichtigen die von der Operation verursachte Veränderung am Potential, $a_i = t_i + \Phi(D_{i}) - \Phi(D_{i-1})$. Um die \textbf{amortisierten Gesamtkosten} $A$ zu berechnen bildet man die Summe der amortisierten Kosten aller Operationen. 
\begin{align*}
A = \sum_{i = 1}^{m} a_i =  \sum_{i = 1}^{m} \left(t_i + \Phi\left(D_{i}\right) - \Phi\left(D_{i-1}\right)\right) = \Phi\left(D_{m}\right) - \Phi\left(D_{0}\right) + \sum_{i = 1}^{m} t_i 
\end{align*}
Folgendes gilt für die Summe der $t_i$:
\begin{align*}
&\sum_{i = 1}^{m} t_i =  \sum_{i = 1}^{m} \left(a_i - \Phi\left(D_{i}\right) + \Phi\left(D_{i-1}\right)\right) = \Phi\left(D_{0}\right) - \Phi\left(D_{m}\right) + \sum_{i = 1}^{m} a_i \\
\Rightarrow &\left( \Phi\left(D_{m}\right) \geq \Phi\left(D_{0}\right) \Rightarrow \sum_{i = 1}^{m} a_i \geq \sum_{i = 1}^{m} t_i \right)
\end{align*}
Ist das Potenzial nach Ausführung der Operationsfolge also nicht kleiner als zu Beginn, dann sind die amortisierten Gesamtkosten eine obere Schranke für die tatsächlichen Gesamtkosten. Die wesentliche Aufgabe ist es nun eine Potentialfunktion zu finden, bei der die amortisierten Gesamtkosten möglichst niedrig sind und für die gilt $\Phi\left(D_{m}\right) \geq \Phi\left(D_{0}\right)$. Dies wird jetzt noch an einem einfachen Beispiel demonstriert.

\paragraph{Potentialfunktionmethode am Beispiel eines Stack} 
Der Stack verfügt wie gewöhnlich über eine Operation \textit{push} zum Ablegen eines Elementes auf dem Stack und über \textit{pop} zum Entfernen des oben liegenden Elementes. Zusätzlich gibt es eine Operation \textit{popAll}, die so oft \textit{pop} aufruft, bis der Stack leer ist. Sei $n$ die Anzahl der Elemente die maximal im Stack enthalten sein kann. \textit{push} und \textit{pop} können in konstanter Zeit durchgeführt werden und wir berechnen jeweils eine Kosteneinheit. Für die Laufzeit von \textit{popAll} gilt $O(n)$, da \textit{pop} bis zu $n$ mal aufgerufen wird. Für die Gesamtlaufzeit einer Folge von $m$ Operationen kann $O(mn)$ angegeben werden. Mit einer amortisierten Analyse wird nun aber $O(m)$ für \textit{popAll} gezeigt. Als $\Phi$ verwenden wir eine Funktion, welche die aktuelle Anzahl der im Stack enthaltenen Elemente zurück gibt. $\Phi_0$ setzen wir auf $0$, das heißt wir starten mit einem leeren Stack. \textit{push} erhöht also das Potential um eins, während \textit{pop} es um eins vermindert. Nun werden die amortisierten Kosten bestimmt. 

\begin{align*}   
&a_{\mathit{push}} = t_{\mathit{push}} + \Phi_{i} - \Phi_{i-1}  &= 2\\
&a_{\mathit{pop}} = t_{\mathit{pop}} + \Phi_{i} - \Phi_{i-1}  &= 0\\
&a_{\mathit{popAll}} = n \cdot a_{\mathit{pop}} &= 0
\end{align*}\\
Alle drei Operationen haben konstante amortisierte Kosten. Auf jedem Fall gilt $ \Phi_m \geq  \Phi_0 = 0 $. Für die Ausführungszeit der Folge gilt deshalb $O(m)$. \\
Bei diesem einfachen Beispiel ist sofort klar warum es funktioniert. Aus einem zu Beginn leerem Stack kann nur entfernt werden, was zuvor eingefügt wurde. \textit{push} zahlt für die Operation, welche das eingefügte Element eventuell wieder entfernt gleich mit, bleibt bei den Kosten aber konstant. Deshalb kann \textit{pop} amortisiert kostenlos durchgeführt werden, wodurch einer der beiden Faktoren zur Berechnung der Kosten von \textit{popAll} zu $0$ wird. 



\subsection{Eigenschaften eines dynamisch optimalen BST }\label{upperBounds}
Im folgendem werden einige obere Laufzeitschranken für Zugriffsfolgen vorgestellt. Es ist bekannt, dass es obere Schranken sind, da mit dem Splay Baum ein BST bekannt ist, der jede der Schranken einhält. Der Splay Baum wird später noch vorgestellt. Es wird wieder ohne Verlust der Allgemeinheit eine Schlüsselmenge $K = \{1,2,..,n\}$ angenommen. Wenn nicht anders angegeben wird  $X = x_1,x_2,..,x_m$ als Zugriffsfolge verwendet. Es wird $m \geq n$ angenommen.


\paragraph{Balanced Property}
Ein BST erfüllt das balanced property, wenn er $X$ in amortisiert $O\left((m \log \left(n \right)\right)$ Zeit ausführt. 

\paragraph{Static Finger Property}
Die Idee hinter dieser Eigenschaft ist, dass es einfacher ist, Zugriffsfolgen schnell auszuführen, wenn ihre Schlüssel betragsmäßig nahe beieinander liegen. 
Sei $k_f \in K$. Ein BST erfüllt static finger wenn für die amortisierte Laufzeit von $X$ 
\begin{align*}
O\left(n \log_2 n + \sum_{i = 1}^{m} \log \vert k_f - x_i  \vert	+ 1	\right)
\end{align*}
gilt. Ein BST mit der static finger Eigenschaft erfüllt auch die balanced Eigenschaft, denn $ \vert k_f - x_i  \vert < n$.


\paragraph{Statisch optimal}
Sei $k \in K$ und $q(k)$ die Anzahl des Vorkommens von $k$ in  $X$. Ein BST ist statisch optimal wenn er Zugriffsfolgen, in denen jeder seiner Schlüssel zumindest einmal enthalten ist, in amortisiert 
\begin{align*}
O\left(\sum_{k = 1}^{n}q(k)\log \left( \frac{m}{q(k)} \right)\right) 
\end{align*}
Zeit ausführt. Der Name kommt daher, dass es sich hierbei um eine untere Schranke für die Ausführungszeit von X bei statischen BST handelt, siehe \cite{staticOptimal}. Solche ändern ihren Struktur während \textit{access} nicht.

\paragraph{Working Set Property}
Ein BST mit dem working set property führt Zugriffsfolgen schnell aus, bei denen auf die gleichen Schlüssel in kurzen Abständen zugegriffen wird.
Für $x_i$ sei $J_i = \{j \in \mathbb{N} \vert j < i \land x_j = x_i \}$.
Sei $t_{xi} = \max \left(J\right)$, falls $J$ nicht leer ist, ansonsten $t_{xi} = 0$. $t_{xi}$ liefert also den Index des vorherigen Zugriffes auf $x_i$, falls ein solcher existiert. Sei ${w_i = \vert\{x_j \vert t_{xi} < j \leq i   \} \vert }$.
Ein BST erfüllt das working set propery wenn für seine amortisierte Laufzeit für $X$
\begin{align*}
O\left(n \log_2 n + \sum_{i = 1}^{m} \log w_i \right)
\end{align*} 
gilt. 


\paragraph{Dynamic Finger Property}
Diese Eigenschaft ist static finger sehr ähnlich, man kann jedoch durch das Unified Property nicht direkt auf dynamic finger schließen. 
Ein BST erfüllt das Dynamic Finger Property, wenn für die amortisierte Laufzeit von $X$
\begin{align*}
O\left( m + \sum_{i = 2}^{m} \log \left(\vert x_{i-1} - x_i  \vert	+ 1	\right)\right)
\end{align*} 
gilt. 

\noindent Abbildung \ref{fig:upperBounds} zeigt Implikationen zwischen den Eigenschaften und basiert auf einer Abbildung aus \ref{fig:upperBounds}.

\begin{figure}[h]
	\centering
	\includegraphics[width= 0.6\textwidth]{"Medien/DynOpt/upperBounds"}
	\caption{Implikationen zwischen den Eigenschaften, abgeleitet aus einer Abbildung aus \cite{upperBounds} }
	\label{fig:upperBounds}
\end{figure}


\section{Tango Baum} \label{TangoAbschnitt}
Der Tango Baum ist ein aus BSTs, den \textbf{Hilfsbäumen}, bestehender BST. Auf die Anforderungen an die Hilfsbäume wird in Abschnitt \ref{aufbauDesTango} eingegangen und mit dem Rot-Schwarz-Baum wird eine mögliche Variante noch detailliert vorgestellt. Der Tango Baum wurde in \cite{demainDinamicOpti},von Demaine, Harmon, Iacono und Patrascu beschrieben, inklusive eines Beweises über seine $\log\left(\log\left(n\right)\right)$-competitiveness. Ebenfalls in \cite{demainDinamicOpti} enthalten ist eine als \textbf{Interleave Lower Bound} bezeichnete Variation der ersten unteren Schranke von Wilber. Da diese für das Verständnis des Tango Baumes wesentlich ist, wird mit ihr gestartet, bevor es zur Beschreibung der Struktur selbst kommt. 


\subsection{Interleave Lower Bound} \label{interBound}
Sei $X = x_1,x_2,.,x_m$ eine Zugriffsfolge und sei $K = \{k \in \mathbb{N} \vert k \textit{ ist in $X$ enthalten}\}$. Auch hier wird ein lower bound tree verwendet. Dieser ist jedoch etwas anders definiert als in Abschnitt \ref{wilberBound}. Hier ist der lower bound tree $Y$ zu einer Zugriffsfolge $X$, der komplette BST mit Schlüsselmenge $K$. Anders als in Abschnitt \ref{wilberBound}  gibt es hier somit zu jeder Zugriffsfolge nur genau einen lower bound tree. Abbildung \ref{fig:demlowerBoundTree} zeigt den lower bound tree zur Zugriffsfolge $1, 2,.., 15$. Zu jedem Knoten $v$ in $Y$ werden zwei Mengen definiert. Die \textbf{linke Region} von $v$ enthält den Schlüssel von $v$, sowie die im linken Teilbaum von $v$ enthaltenen Schlüssel.  Die \textbf{rechte Region} von $v$ enthält die im rechten Teilbaum von $v$ enthaltenen Schlüssel. Sei $l$ der kleinste Schlüssel im Teilbaum mit Wurzel $v$ und $r$ der größte. Sei  $X^r_l = {x_{1'},x_{2'},..,x_{m'}}$ wie in Abschnitt \ref{wilberBound} definiert. $i \in \{2,3,..,m'\}$ ist ein \enquote{\textbf{Interleave} durch $v$} wenn $x_{\left(i -1\right)}$ in der linken Region von $v$ liegt und $x_i$ in der rechten Region von $v$, oder umgekehrt. In $Y$ sind Knoten enthalten, bei denen die rechte Region leer ist. Durch diese kann es keinen Interleave geben. Sei $U$ die Menge der Knoten von $Y$, mit einer nicht leeren rechten Region. Sei \textit{inScore($u$)} die Funktion die zu dem Knoten $u \in U$ die Anzahl der Interleaves durch $u$ zurückgibt.  Die Funktion \textit{IB$\left(X\right)$} ist definiert durch:
\begin{align*}
\mathit{IB}\left(X\right) = \sum_{u \in U} \mathit{inScore}\left(u\right)
\end{align*}
Sei $T_0$ der BST mit Schlüsselmenge $K$ auf der $X$ ausgeführt wird. Für $i \in \{1,2,..,m\}$ sei $T_i$ der BST, der entsteht nachdem \textit{access}$\left(x_i\right)$ auf $T_{i-1}$ ausgeführt wurde. Zu $u \in U$ und  $j \in \{0,1,..,m\}$ gibt es einen \textbf{transition point} $v$ in $T_j$. $v$ ist ein Knoten mit folgenden Eigenschaften:\\
\begin{enumerate}
	\item Der Pfad von der Wurzel von $T_j$ zu $v$ enthält einen Knoten dessen Schlüssel in der linken Region von $u$ enthalten ist.
	\item Der Pfad von der Wurzel von $T_j$ zu $v$ enthält einen Knoten dessen Schlüssel in der rechten Region von $u$ enthalten ist.
	\item In $T_i$ ist kein Knoten mit Eigenschaft 1 und 2 enthalten, der eine kleinere Tiefe als $v$ hat. 
\end{enumerate}
\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{"Medien/Tango/lowerBoundTree"}
	\caption{Der lower bound tree zur Zugriffsfolge $1 ,2, .., 15$  }
	\label{fig:demlowerBoundTree}
\end{figure}

\noindent Im Beweis dieses Abschnittes wird gezeigt das $\mathit{OPT}\left(X\right) \geq \frac{\mathit{IB}\left(X\right)}{2} - n$ gilt, wobei $n$ die Anzahl der Knoten im lower bound tree ist. Dafür werden jedoch noch drei Lemmas zu den Eigenschaften von $Y$ benötigt. 

\begin{Lemma} \label{demaineLemma1}
	Sei $X = x_1,x_2,..,x_m$ eine Zugriffsfolge und $Y$ ein zu $X$ erstellter lower bound tree mit Schlüsselmenge $K$. Sei $T_0$ der BST mit Schlüsselmenge $K$ auf dem $X$ ausgeführt wird. Für $i \in \{1,2,..,m\}$ sei $T_i$ der BST der durch Ausführen von \textit{access}$\left(x_i\right)$ auf $T_{\left(i-1\right)}$ entsteht. Sei $U$ die Menge der Knoten von $Y$, bei denen die rechte Region nicht leer ist. Dann gibt es zu jedem Knoten $u \in U$ und $j \in \{0,1,..,m\}$ genau einen transition point in $T_j$. 	
\end{Lemma}


\begin{proof}
	Sei $l$ der kleinste Schlüssel in der linken Region von $u$ und $r$ der Größte Schlüssel in der rechten Region. Im Teilbaum mit Wurzel $u$ sind genau die Schlüssel $K^r_l = \{k \in K \vert k \in \left[l,r\right]\}$ enthalten. Sei $v_l$ der gemeinsame Vorfahre aller Knoten mit einem Schlüssel aus der linken Region von $u$ in $T_j$, mit der größten Tiefe. Sei $v_r$ der gemeinsame Vorfahre aller Knoten mit einem Schlüssel aus der rechten Region von $u$ in $T_j$, mit der größten Tiefe. $\mathit{key\left(l\right)}$ bzw. $\mathit{key\left(r\right)}$ muss selbst in der linken bzw. rechten Region von $u$ enthalten sein, vergleiche \ref{wilberLowerBoundTree}. Sei $w$ der gemeinsame Vorfahre aller Schlüssel aus der linken und der rechten Region von $u$ in $T^r_l$ mit der größten Tiefe. Es muss $\mathit{key}\left(w\right) \in \left[l,r\right]$ gelten. Somit muss  $\mathit{key}\left(w\right)$ entweder in der linken oder rechten Region von $u$ enthalten sein. Da $w$ der Knoten mit der größten Tiefe sein muss, für den  $\mathit{key\left(w\right)} \in \left[l,r\right]$  gilt, muss entweder $w = v_l$ oder $w = v_r$ gelten, je nachdem wessen Tiefe kleiner ist. Für den Fall $w = v_l$ ist $v_r$ der transition point in $T_j$ zu $u$ und für den Fall $w = v_r$ ist es $v_l$.
	Es wird der Fall $w = v_l$ betrachtet, der andere kann direkt daraus abgeleitet werden. Im Pfad $P_u = v_0,v_1,..,v_r$ von der Wurzel $v_0$ zu $v_r$ ist $v_l$ enthalten und da $v_r$ ein gemeinsamer Vorfahre der Schlüssel aus der rechten Region von $u$ ist muss $v_r$ der einzige Knoten mit einem Schlüssel aus der rechten Region von $u$ in $P_u$ sein. Jeder Pfad $P$ in $T_j$ von der Wurzel zu einem Knoten mit einem Schlüssel aus der rechten Region von $u$ muss mit $v_0,v_1,..,v_r$ beginnen, somit kann es keinen weiteren transition point für $u$ in $T_j$ geben. 
	
\end{proof}
\noindent Der Knoten auf den der Zeiger $p$ zum ausführen von \textit{access} gerade zeigt wird als \textbf{berührter Knoten} bezeichnet.
Im zweiten Lemma geht es darum, dass sich der transition point $v$ eines Knoten nicht verändern kann, solange $v$ nicht wenigstens einmal der berührte Knoten war. In den zwei verbleibenden Lemmas und dem Satz seien  $T_j$, $X$, $Y$, $U$ und $u$ wie in  Lemma \ref{demaineLemma1} definiert. 



\begin{Lemma} \label{demaineLemma2} \label{lemmaDemaine2}
	Sei $v$ der transition point zu $u$ in $T_j$.  Sei  $l \in \mathit{N}$, mit $j < l \leq m$. Gilt für alle $x_i$, mit $i \in \left[j,l\right]$, während der Ausführung von \textit{access}$\left(x_i\right)$,  $v$ war nicht wenigstens einmal der berührte Knoten, dann ist $v$ während der gesamten Ausführungszeit von $\textit{access}\left(x_j\right),\textit{access}\left(x_{j+1}\right),..,\textit{access}\left(x_l\right)$ der transition point zu $u$. 
\end{Lemma}

\begin{proof}
	Sei $v_l$ der gemeinsame Vorfahre aller Knoten mit einem Schlüssel aus der linken Region von $u$ in $T_j$, mit der größten Tiefe. Sei $v_r$ der gemeinsame Vorfahre aller Knoten mit einem Schlüssel aus der rechten Region von $u$ in $T_j$, mit der größten Tiefe. Hier wird wieder ohne Verlust der Allgemeinheit der Fall $v = v_r$ betrachtet. Da $v_r$ nicht berührt wird, wird auch kein Knoten mit einem Schlüssel aus der rechten Region von $u$ berührt. $v_r$ ist somit während der gesamten Ausführungszeit von $\textit{access}\left(x_j\right),\textit{access}\left(x_{j+1}\right),..,\textit{access}\left(x_l\right)$  der gemeinsame Vorfahre der Schlüssel aus der rechten Region von $u$, mit der größten Tiefe. Knoten mit Schlüssel in der linken Region von $u$ könnten berührt werden. Zu einem Ausführungszeitpunkt $t$ kann deshalb ein Knoten $v_{lt} \ne v_l$ mit einem Schlüssel aus der linken Region von $u$ der gemeinsame Vorfahre der Knoten mit diesen Schlüsseln mit der größten Tiefe sein. Da $v_r$ nicht berührt wird kann zu keinem Zeitpunkt $v_l$ im Teilbaum mit Wurzel $v_r$ enthalten sein. Somit kann auch $v_{lt}$ nicht in diesem Teilbaum enthalten sein. Somit muss die Tiefe von  $v_{lt}$ kleiner sein, als die von $v_r$ und $v_r$ bleibt der transition point von $u$. 
\end{proof}

\noindent Im dritten Lemma wird gezeigt dass ein Knoten $v$ in $T_j$ nur der transition point zu einem Knoten aus $U$ sein kann.


\begin{Lemma}\label{lemmaDemaine3}
	Sei $u_1, u_2 \in U$, mit $u_1 \ne u_2$.  Sei $v$ der transition point zu $u_1$ und $w$ der zu $u_2$ in $T_j$. Dann muss $v_1 \neq v_2$ gelten.
\end{Lemma}

\begin{proof}
	Sei $v_l$ bzw. $v_r$ der gemeinsame Vorfahre aller Knoten mit einem Schlüssel aus der linken bzw. rechten Region von $u_1$ in $T_j$, mit der größten Tiefe.  Sei $w_l$ bzw. $w_r$ der gemeinsame Vorfahre aller Knoten mit einem Schlüssel aus der linken bzw. rechten Region von $u_2$ in $T_j$, mit der größten Tiefe. Ist weder $u_1$ ein Vorfahre von $u_2$ noch $u_2$ einer von $u_1$, dann muss auch $w_l \ne v_l \land w_l \ne v_r$ sowie $w_r \ne v_l \land w_r \ne v_r$ gelten, da die Teilbäume mit Wurzel $u_1$ und $u_2$ dann über disjunkte Schlüsselmengen verfügen. Somit müssen die transition points von $u_1$ und $u_2$ unterschiedlich sein. Sei $u_1$ ein Vorfahre von $u_2$. Es werden drei Fälle unterschieden:
	\begin{enumerate}
		\item Ist $\mathit{key}\left(v_1\right)$ ist nicht im Teilbaum mit Wurzel $u_2$ enthalten, so kann $v_1$ nicht der transition point von $u_2$ sein.
		\item $\mathit{key}\left(v_1\right)$ ist im Teilbaum mit Wurzel $u_2$ enthalten und $\mathit{key}\left(v_1\right)$ ist  in der linken Region von $u_1$ enthalten:\\
		Da $u_1$ Vorfahre von $u_2$ ist, müssen alle Schlüssel im Teilbaum mit Wurzel $u_2$ in der linken Region von $u_1$ enthalten sein. Da der Schlüssel von $v_1$ in der linken Region von $u_1$ liegt, muss $v_r$ ein Vorfahre von $v_l$ in $T_j$ sein. $\mathit{key}\left(v\right)$ muss somit der Schlüssel von $w_l$ bzw. $w_r$ sein, je nachdem wessen Tiefe kleiner ist. Denn andererseits könnte man einen Pfad von der Wurzel von $T_j$ zu $v$ angeben der zwei Knoten aus der linken Region von $u_1$ enthält, dass ist jedoch ein Widerspruch dazu, dass  $\mathit{key}\left(v_1\right)$ in der linken Region von $u_1$ enthalten ist und $v_1$ zudem der transition point für $u_1$ ist.\\
		$w$ ist entweder der Knoten $w_l$ oder $w_r$ je nachdem wessen Tiefe größer ist, somit gilt $v \ne w$.
		\item $\mathit{key}\left(v_1\right)$ ist im Teilbaum mit Wurzel $u_2$ enthalten und $\mathit{key}\left(v_1\right)$ ist in der rechten Region von $u_1$ enthalten:\\
		Symmetrisch zu Fall 2.
	\end{enumerate}
	
	
	
	
	
	
\end{proof}

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{"Medien/Tango/transitionPoints"}
	\caption{Transition point Zuordnung. Links ein lower bound tree, rechts ein möglicher $T_j$.   }
	\label{fig:transitionPoints}
\end{figure}



\begin{Satz} \label{satzDemaine1}
	Sei $X = x_0, x_1,.., x_m$  eine Zugriffsfolge und $n$ die Anzahl der Knoten im zu $X$ erstellten lower bound tree. Dann gilt\\	
	$\mathit{OPT}\left(X\right) \geq \mathit{IB}\left(X\right) /2 - n$ .
\end{Satz}
\begin{proof}
	Es wird die Mindestanzahl der Berührungen von transition points gezählt. Durch Lemma \ref{lemmaDemaine3} kann die Anzahl der Berührungen für jedes $y \in P$ einzeln bestimmt werden, diese müssen dann lediglich noch aufaddiert werden. Sei $l$, $r$, $v_r$ und $v_l$ wie in Lemma \ref{demaineLemma1} zu $y$ definiert, so dass entweder $v_l$ oder $v_r$ der transition point zu $y$ sein muss, je nachdem welcher der beiden Knoten die größere Tiefe hat. Sei $X{^r_l}' = x_{i_0},x_{i_1},..,x_{i_p}$ die Folge die entsteht, wenn aus $X^r_l$ alle $x_k$ entfernt werden, für die gilt $x_k$ ist in der gleichen Region von $y$ wie $x_{k-1}$. Damit gilt $\mathit{inScore}\left(y\right) = p$. Nun wird angenommen, dass die $x_{i_j}$ mit $j$ ist gerade in der rechten Region von $y$ liegen, und die $x_{i_j}$ mit $j$ ist ungerade in der linken Region. Der andere Fall kann wieder direkt abgeleitet werden. Sei $q \in \mathbb{N}$ mit $1 \leq q \leq \lfloor p / 2 \rfloor$. \textit{access}$\left( x_{i_{2q-1}} \right)$ muss $v_l$ berühren und \textit{access}$\left( x_{i_{2q}} \right)$ muss $v_r$ berühren. Sei $k_{1}$ der Schlüssel des transition point von $y$ zu Beginn von \textit{access}$\left( x_{i_{2q-1}} \right)$ und  $k_{2}$ der Schlüssel des transition point von $y$ zu Beginn von \textit{access}$\left( x_{i_{2q}} \right)$. Gilt $k_{1} = k_{2}$ so muss der transition point von $y$ in \textit{access}$\left( x_{i_{2q}} \right)$ berührt worden sein.  Gilt $k_{1} \ne k_{2}$ so muss der transition point von $y$, nach Lemma \ref{demaineLemma2}, in \textit{access}$\left( x_{i_{2q-1}} \right)$ berührt worden sein. Aus der Konstruktion von $X{^r_l}'$ folgen daraus mindestens $\lfloor p/2 \rfloor \geq p/2 - 1$ Berührungen des transition point von $y$. Sei $U$ wie in Lemma  \ref{demaineLemma1} definiert. Aufaddieren über alle $u \in U$ ergibt bei den Werten der $\mathit{inScore}$ Funktion die Interleave Bound und bei den Berührungen von transition points zumindest  $\mathit{IB}\left(X\right) /2 - \vert U \vert \geq \mathit{IB}\left(X\right) /2 - n$.
	
\end{proof}


\subsection{Aufbau des Tango Baum} \label{aufbauDesTango}
Wie bereits erwähnt besteht ein Tango Baum $T$ mit Schlüsselmenge $K$ aus Hilfsbäumen. Eine Anforderung an einen Hilfsbaum mit $n$ Knoten ist, dass für seine Höhe $h = O\left(\log n\right)$ gilt. $T$ bietet lediglich eine \textit{access} Operation an. Ist $T$ also erst einmal für $K$ erzeugt, ist seine Schlüsselmenge unveränderlich. Sei $P$ der lower bound tree aus Abschnitt \ref{interBound} mit Schlüsselmenge $K$. $P$ wird auch als \textbf{Referenzbaum} für $T$ bezeichnet. $P$ ist kein Hilfsbaum und muss in Implementierungen auch nicht erstellt werden. Er dient aber dazu den Aufbau von $T$ vor und nach einer \textit{access} Operation zu veranschaulichen. Jeder innere Knoten $p$ in $P$ kann ein \textbf{preferred child} haben.  Wurde während der Ausführungszeit von $X$ noch keine \textit{access} Operation mit einem im Teilbaum mit Wurzel $p$ enthalten Schlüssel als Parameter ausgeführt, so hat $p$ kein preferred child. Ansonsten sei \textit{access}$\left(k\right)$ die zuletzt ausgeführte Operation mit einem Schlüssel der im Teilbaum mit Wurzel $p$ enthalten ist. Liegt $k$ in der linken Region von $p$, dann ist das linke Kind von $p$, das preferred child von $p$. Ist $k$ in der rechten Region von $p$ enthalten, dann ist das rechte Kind von $p$, das preferred child von $p$. Wir erweitern die Knoten von $P$ mit einer weiteren Variable \textit{prefChild} welche drei Werte annehmen kann. Sie enthält \textit{none} wenn ihr Knoten kein preferred Child besitzt, \textit{left} wenn das linke Kind das preferred child ist, ansonsten entsprechend \textit{right}. Hier kann man bereits die Kopplung zur interleave lower bound erkennen. Ein Wechsel von \textit{prefChild}  von \textit{left} zu \textit{right}, oder umgekehrt, findet genau dann statt, wenn es zu einem interleave durch den Knoten kommt. Abbildung \ref{fig:prefChilds} stellt einen möglichen Zustand von $P$ zwischen zwei \textit{access} Operationen dar. Dieser Zustand wird in diesem Abschnitt nun als durchgängiges Beispiel dienen. Man erkennt sofort, dass der Parameter der letzten \textit{access} Operation $8$, $4$, $2$ oder $1$ gewesen sein muss, da man von der Wurzel aus über preferred childs zu den Knoten mit diesen Schlüsseln gelangen kann. Die Schlüssel $10$ und $9$ können noch nie Parameter einer \textit{access} Operation gewesen sein, ansonsten müsste der Knoten mit dem Schlüssel $10$ ein preferred child haben. Mit Hilfe der preferred childs lassen sich die \textbf{preferred path} erstellen. Sei $v$ ein Knoten in $P$, der nicht preferred child eines anderen Knoten aus $P$ ist. Dann ist der preferred path zu $v$, der längst mögliche Pfad $\left(v_0, v_1,..,v_l\right)$, mit $v_0 = v$ und $\forall i \in \{1,2,..,l\} \colon v_i \textit{ ist preferred child von }v_{i-1   }$.  

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{"Medien/Tango/prefChilds"}
	\caption{Die preferred childs werden durch die grünen Pfeile markiert. }
	\label{fig:prefChilds}
\end{figure}

\noindent Nun werden die preferred path des BST aus Abbildung \ref{fig:prefChilds} angegeben, wobei der Schlüssel jeweils als Bezeichner für den ihn enthaltenden Knoten verwendet wird.
\begin{align*}
&P_1 = 8, 4, 2,1 \\
&P_2 = 3 \\
&P_3 = 6, 7 \\
&P_4 = 5 \\
&P_5 = 11, 12 \\
&P_6 = 10 \\
&P_7 = 9
\end{align*}

\noindent Da jeder Knoten nur preferred child eines Knoten sein kann und Knoten die kein preferred child sind als Startknoten eines Pfades dienen, muss jeder Knoten in genau einem preferred Pfad enthalten sein.\\
Zu jedem preferred path gibt es einen Hilfsbaum der genau die Schlüssel enthält, die in den Knoten des Pfades enthalten sind. Da der Tango Baum den inneren Aufbau der Hilfsbäume nicht exakt vorschreibt, zeigt Abbildung \ref{fig:Hilfsbäume} nur eine mögliche Konstellation.


\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{"Medien/Tango/Hilfsbäume"}
	\caption{Hilfsbäume zu den preferred path aus dem Beispiel. }
	\label{fig:Hilfsbäume}
\end{figure}
Sei $H$ die Menge der erstellten Hilfbäume aus $P$. Mit dem folgenden Verfahren können Hilfsbäume zu einem Tango Baum zusammengefügt werden:
\begin{enumerate}
	\item Gilt $\vert H \vert = 1$, dann ist das in $H$ enthaltene Element der Tango Baum und es wird abgebrochen.
	\item Wähle $h_1 \in H$ so, dass $h_1$ nicht den Schlüssel der Wurzel von $P$ enthält.
	\item Aufgrund der Konstruktion der preferred paths muss es genau einen Knoten $v$ in $h_1$ geben, so dass der Knoten $u$ in $P$ mit $\mathit{key}\left(v\right) = \mathit{key}\left(u\right) $ nicht preferred child seines Elternknotens ist.
	Sei $h_2$ der Hilfsbaum, der den Schlüssel $\mathit{key}\left(u\right)$ enthält. Entferne $h_1$ und $h_2$ aus $H$.
	\item Sei $w_1$ die Wurzel von $h_1$. Sei $a$ der Knoten in $H_2$ an dem die Standartvariante von \textit{insert} einen für Schlüssel  $\mathit{key\left(w_1\right)}$ erzeugten Knoten anfügen würde. Dann wird $h_1$ an $a$ angefügt. Aufgrund der Links-Rechts-Beziehung in BST, kann es nur eine Möglichkeit dafür geben. Sei $h_3$ der so entstandene BST.
	\item Füge $h_3$ zu $H$ hinzu, weiter mit $1$.
\end{enumerate}

\noindent Bei Punkt $4$ ist sofort ersichtlich, dass es durch $\mathit{key}\left(w_1\right)$ zu keiner Verletzung der Links-Rechts-Beziehung kommt. Wie sieht es aber mit bei den anderen Schlüsseln aus $h_1$ aus ? 
In $P$ sind alle in $h_1$ enthaltenen Schlüssel im Teilbaum mit Wurzel $u$ enthalten. Sei $l$ der kleinste Schlüssel in diesem Teilbaum und $r$ der Größte. In $P$ kann es außerhalb des Teilbaumes mit Wurzel $u$ keinen Schlüssel $k$ mit $l \leq k \leq r$ geben. $h_2$ kann nur Schlüssel enthalten die in $P$ aber nicht im Teilbaum mit Wurzel $u$ enthalten sind. Ein Vorgänger von $a$ in $h_2$ muss einen Schlüssel haben der kleiner als $l$ ist. Ein Nachfolger von $a$ in $h_2$ muss einen Schlüssel haben, der größer als $r$ ist. Im Tango Baum kann es also keine Verletzung der Links-Rechts-Beziehung geben.\\




\noindent Abbildung \ref{fig:Tangobaum} zeigt unseren Tango Baum zum Beispiel. Die Wurzeln von Hilfsbäumen sind grün dargestellt.

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{"Medien/Tango/Tangobaum"}
	\caption{Tango Baum zu dem Beispiel. }
	\label{fig:Tangobaum}
\end{figure}
\noindent Nehmen wir an auf $T$ wird \textit{access}$\left(9\right)$ ausgeführt wird. Abbildung \ref{fig:prefChilds2} zeigt den Zustand von $P'$.

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{"Medien/Tango/prefChilds2"}
	\caption{Preferred childs nach  \textit{access}$\left(9\right)$. }
	\label{fig:prefChilds2}
\end{figure}

Abbildung \ref{fig:TangoTree2} zeigt einen möglichen Zustand von $T'$.
\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{"Medien/Tango/Tangobaum2"}
	\caption{Tango Baum nach  \textit{access}$\left(9\right)$. }
	\label{fig:Tangobaum2}
\end{figure}
\noindent Im nächsten Abschnitt wird es vor allem darum gehen, wie eine Transformation, wie die von $T$ zu $T'$, effizient durchgeführt werden kann.

\subsection{Die \textit{access} Operation beim Tango Baum}
Die Knoten in einem Tango Baum sind mit zusätzlichen Daten erweitert. Sei $v$ ein Knoten im Tango Baum. Es gibt eine boolesche Variable \textit{isRoot}, die genau dann Wert \textit{true} hat, wenn $v$ die Wurzel eines Hilfsbaumes ist. In einer Konstante \textit{depth} wird die Tiefe des Knoten mit Schlüssel $\mathit{key}\left(v\right)$ in $P$ gespeichert. Außerdem gibt es noch Variablen \textit{minDepth} und \textit{maxDepth}. Sei $v$ im Hilfsbaum $H$ enthalten und sei $H_v$ der Teilbaum mit Wurzel $v$ in $H$. Da $H$ die Schlüssel von Knoten aus einem preferred path enthält, können die \textit{depth} Konstanten zweier Knoten in $H$ nicht den gleichen Wert haben. Sei $\mathit{min}$ der kleinste Wert aller \textit{depth} Konstanten in $H_v$, dann entspricht $\mathit{min}$ dem  Wert der \textit{minDepth} Variable von $v$. Sei $\mathit{max}$ der größte Wert aller \textit{depth} Konstanten in $H_v$, dann entspricht $\mathit{max}$ dem  Wert der \textit{maxDepth} Variable von $v$. Auf die Variablen und Konstanten eines Knoten $v$ wird im folgenden mit dem Punkt als Trennzeichen zugegriffen, z. B. $v$.\textit{depth} \\
Nun werden die Anforderungen an einen Hilfsbaum $H$ aufgezählt:
\begin{enumerate}
	\item Sei $n$ die Anzahl der Knoten von $H$. Für die Höhe $h$ von $H$ gilt $h = O\left(\log n\right)$.
	\item $H$ aktualisiert seine Zeiger auf andere Hilfsbäume.
	\item $H$ aktualisiert die Variablen  \textit{minDepth} und \textit{maxDepth}.
	\item $H$ bietet eine Operation \textit{concatenate(HB $H_1$, key $k$, HB  $H_2$)} an. HB ist eine Abkürzung für Hilfsbaum. Bei maximal einem \textit{HB}  darf die \textit{isRoot} Variable der Wurzel den Wert \textit{true} haben. Sei $K_1$ die Schlüsselmenge von $H_1$ und $K_2$ die von $H_2$. Die Operation kann verwenden, dass für $k_1 \in K_1$ und $k_2 \in K_2$, $k_1 < k < k_2$ gilt. Es gibt drei Fälle. Sei $w_1$ die Wurzel von $H_1$ und $w_2$ die von $H_2$
	\begin{enumerate}
		\item $w_1$.\textit{isRoot} $=$ \textit{false} und $w_2$.\textit{isRoot} $=$ \textit{false}:\\
		Die Operation gibt die Wurzel eines Hilfsbaum $H$ mit Schlüsselmenge $K_1 \cup K_2 \cup \{k\} $ zurück.
		\item $w_1$.\textit{isRoot} $=$ \textit{true}:\\	
		Die Operation gibt die Wurzel eines Hilfsbaum $H$ mit Schlüsselmenge $K_2 \cup \{k\} $ zurück. An $H$ ist ein Hilfsbaum $H_3$ mit Schlüsselmenge $K_2$ angefügt. \textit{isRoot} der Wurzel von $H_3$ hat den Wert \textit{true}.
		\item $w_2$.\textit{isRoot} $=$ \textit{true}:\\	
		Die Operation gibt die Wurzel eines Hilfsbaum $H$ mit Schlüsselmenge $K_1 \cup \{k\} $ zurück. An $H$ ist ein Hilfsbaum $H_3$ mit Schlüsselmenge $K_1$ angefügt. \textit{isRoot} der Wurzel von $H_3$ hat den Wert \textit{true}.	 
	\end{enumerate}
	Bei allen Fällen hat \textit{isRoot} der Rückgabe den Wert \textit{false}.
	Für die Laufzeit der Operation muss $O\left(\log \left(\vert K_1 \vert + \vert K_2 \vert\right)\right)$ gelten.
	\item $H$ bietet eine Operation \textit{split(key $k$)} an Die Operation kann verwenden, dass in $H$ einen Knoten mit Schlüssel $k$ existiert. Sei $K$ die Schlüsselmenge von $H$. Die Operation gibt einen Knoten $v$ mit Schlüssel $k$ zurück. Das linke Kind von $v$ muss die Wurzel eines Hilfsbaumes mit Schlüsselmenge ${K_l=\{i\in K \mid  i <k\}}$ sein. Das rechte Kind von $v$ muss die Wurzel eines Hilfsbaumes mit Schlüsselmenge ${K_r=\{i\in K \mid  i > k\}}$ sein. Für die Laufzeit der Operation muss $O\left(\log \left(\vert K \vert\right) \right)$ gelten.
\end{enumerate} 
Jetzt werden noch zwei Hilfsoperationen vorgestellt, die für \textit{access} benötigt werden.\\

\paragraph{cut Operation} \label{cut}

\noindent \textit{cut(depth $d$)} zerteilt einen Hilfsbaum $A$ in zwei Hilfsbäume $A_1$ und $A_2$. Es dürfen nur Werte für $d$ übergeben werden zu denen es in $A$ einen Knoten $v$ mit $v$\textit{depth} $ = d $ gibt. Wobei die Knoten in $A$ bei denen \textit{depth} $\leq d$ gilt in $A_1$ enthalten sind und die mit \textit{depth} $ > d$ in $A_2$. Die Rückgabe ist die Wurzel eines Hilfsbaumes $H$ mit den Schlüsseln der Knoten mit \textit{depth} $\leq d$ in $A$. An $H$ ist ein Hilfsbaum mit den restlichen Schlüsseln aus $A$ angefügt. Zunächst werden Knoten $l$,  $l'$, $r$ und $r'$ in $H$ gesucht. $l$ ist der kleinste Schlüssel eines Knoten $v_l$ mit $v_l$.\textit{depth} $> d$  in $A$ . $r$ ist der größte Schlüssel eines Knoten $v_r$ mit $v_r$.\textit{depth} $> d$  in $A$  . $l'$ ist der Schlüssel des Vorgängers von $v_l$ und $r'$ der Schlüssel des Nachfolgers von $v_r$. $l$ und $r$ müssen in $A$ enthalten sein, $l'$ und $r'$ könnten auch fehlen. $v_l$ kann wie folgt gefunden werden. Man startet mit dem Zeiger $p$ an der Wurzel von $A$. Zeigt $p$ nicht auf $v_l$, muss es im linken Teilbaum von $p$ einen Knoten $v$ mit $v$.\textit{depth} $> d$ geben, und das ist an der \textit{maxDepth} Variable des linken Kindes von $p$ direkt abfragbar. Ist $v_l$ erreicht , kann $l'$ über eine Suche des Vorgängers von $v_l'$ zu gefunden werden. Die Suche nach $r$ und $r'$ verläuft analog. \\
$A$ besteht aus Schlüsseln aus einem preferred path. Somit muss für jeden Schlüssel $k$ eines Knotens $v$ mit $v$.\textit{depth} $\leq d$ in $A$ entweder $k > r$ oder $k < l$ gelten, denn alle Schlüssel aus $\left[l,r\right]$ liegen in $P$ entweder im linken oder im rechten Teilbaum des Knotens mit Schlüssel $k$. \\
Es wird nun der Ablauf von \textit{cut} gezeigt. Wobei angenommen wird, dass sowohl $l'$ als auch $r'$ existieren. Die anderen Fälle können einfach abgeleitet werden.
\begin{enumerate}
	\item Sei $w_a$ die Wurzel von $A$. Setze $w_a$.\textit{isRoot} auf \textit{false} 
	\item Führe \textit{split}$\left(l'\right)$ auf $A$ aus. Sei $v_l$ die Rückgabe von \textit{split}$\left(l'\right)$. Sei $B$ der linke Teilbaum von $v_l$ und $C$ der Rechte. 
	\item Führe \textit{split}$\left(r'\right)$ auf $C$ aus. Sei $v_r$ die Rückgabe von \textit{split}$\left(r'\right)$. Sei $D$ der linke Teilbaum von $v_r$ und $E$ der Rechte. 
	\item Setze $v_r$ als rechtes Kind von $v_l$. 
	\item Setze die \textit{isRoot} Variable der Wurzel von $D$ auf \textit{true}.
	\item Führe $F = \textit{concatenate}\left(D, ~ r', ~ E \right)$ aus.
	\item Führe $G = \textit{concatenate}\left(B, ~ l',~ F \right)$ aus.
	\item Setze die \textit{isRoot} Variable der Wurzel von $G$ auf \textit{true} 
	\item Setze die Wurzel von $G$ als Wurzel des Tango Baumes.	 
\end{enumerate}
Abbildung \ref{fig:cut} demonstriert den Ablauf nochmals und Abbildung \ref{fig:cut2} zeigt einen verkürzten Ablauf bei fehlendem $r'$
\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{"Medien/Tango/cut"}
	\caption{Ablauf von \textit{cut($d$)}. Die Abbildung basiert auf einer aus \cite{demainDinamicOpti}, Wurzeln von Hilfsbäumen werden mit einem Kreis markiert }
	\label{fig:cut}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{"Medien/Tango/cut2"}
	\caption{Ablauf von \textit{cut($d$)} bei fehlenden $r'$. Die Abbildung basiert auf einer aus \cite{demainDinamicOpti}, Wurzeln von Hilfsbäumen werden mit einem Kreis markiert }
	\label{fig:cut2}
\end{figure}
\noindent Sei $n$ die Anzahl der Knoten von $A$. Jeder der neun Schritte kann in $O\left(\log \left(n\right)\right)$ Zeit ausgeführt werden. Somit gilt auch für die Gesamtlaufzeit $O\left(\log \left(n\right)\right)$.


\paragraph{join Operation}
\noindent \textit{join(HB $H_1$, HB $H_2$)} fügt die Hilfsbäume $H_1$ und $H_2$ zu einem Hilfsbaum $H$ zusammen. Auch $H$ muss einen preferred path repräsentieren. An die Parameter werden deshalb Anforderungen gestellt. Sei $v_1$ die Wurzel von $H_1$ und $v_2$ die von $H_2$. Es muss $v_1$.\textit{maxDepth} $+ 1$ =  $v_2$.\textit{minDepth} gelten. Auch hier werden Schlüssel $l$, $l'$, $r$ und $r'$ verwendet. Sei $l$ der kleinste Schlüssel in $H_2$ und $r$ der größte Schlüssel in $H_2$. 
Für jeden Schlüssel $k$ in $H_1$ muss entweder $k < l$ oder $k > r$ gelten, vergleiche Abschnitt \ref{cut}. $l'$ ist der größte Schlüssel in $H_1$ mit $l' < l$. $r'$ ist der kleinste Schlüssel in $H_1$ mit $r' > r$. Wird in $H_1$ ein Schlüssel aus $H_2$ gesucht so muss $l'$ bzw. $r'$ zurückgegeben werden. Der andere Schlüssel kann dann mit einer Suche nach dem Nachfolger bzw. Vorgänger gefunden werden. Der Ablauf von \textit{join} ist dem von \textit{cut} recht ähnlich. Wieder wird angenommen, dass $l'$ und $r'$ existieren.
\begin{enumerate}
	\item Sei $w_1$ die Wurzel von $H_1$ und d $w_2$ die von $H_2$. Setze $w_1$.\textit{isRoot} und  $w_2$.\textit{isRoot} auf \textit{false} 
	\item Führe \textit{split}$\left(l'\right)$ auf $H_1$ aus. Sei $v_l$ die Rückgabe von \textit{split}$\left(l'\right)$. Sei $B$ der linke Teilbaum von $v_l$ und $C$ der Rechte. 
	\item Führe \textit{split}$\left(r'\right)$ auf $C$ aus. Sei $v_r$ die Rückgabe von \textit{split}$\left(r'\right)$. Sei $E$ der rechte Teilbaum von $v_r$. Der linke Teilbaum von $v_r$ muss der leere Baum sein. 
	\item Setze $v_r$ als rechtes Kind von $v_l$. Setze die Wurzel von $H_2$ als linkes Kind von $v_r$.
	\item Führe $F = \textit{concatenate}\left(H_2, ~ r', ~ C \right)$ aus.
	\item Führe $H = \textit{concatenate}\left(B, ~ l',~ F \right)$ aus.
	\item Setze die \textit{isRoot} Variable der Wurzel von $H$ auf \textit{true} 
	\item Setze die Wurzel von $H$ als Wurzel des Tango Baumes. 
\end{enumerate}

Abbildung \ref{fig:join} demonstriert den Ablauf nochmals und Abbildung \ref{fig:join2} zeigt einen verkürzten Ablauf bei fehlendem $r'$
\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{"Medien/Tango/join"}
	\caption{Ablauf von \textit{join($H_1$, $H_2$)}. Die Abbildung basiert auf einer aus \cite{demainDinamicOpti}, Wurzeln von Hilfsbäumen werden mit einem Kreis markiert }
	\label{fig:join}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{"Medien/Tango/join2"}
	\caption{Ablauf von  \textit{join($H_1$, $H_2$)} bei fehlendem $r'$. Die Abbildung basiert auf einer aus \cite{demainDinamicOpti}, Wurzeln von Hilfsbäumen werden mit einem Kreis markiert }
	\label{fig:join2}
\end{figure}

Sei $n$ die Anzahl der Knoten von $H$. Jeder der neun Schritte kann in $O\left(\log \left(n\right)\right)$ Zeit ausgeführt werden. Somit gilt auch für die Gesamtlaufzeit $O\left(\log \left(n\right)\right)$.
\paragraph{access Operation}
Nun wird die \textit{access} Operation des Tango Baumes betrachtet. Sei $k$ der Parameter der Operation und $p$ der Zeiger der Operation in den BST. Solange sich $p$ im Hilfsbaum mit der Wurzel des Tango Baumes $T$ befindet, verhält sich die Operation wie die Standardvariante von \textit{search}. Erreicht $p$ die Wurzel eines anderen Hilfsbaumes $H_2$, muss sich ein preferred child in $P$ verändert haben. $T$ wird mit \textit{cut} und \textit{join} so angepasst, dass er wieder die preferred paths in $P$ repräsentiert. Anschließend startet $p$ wieder an der Wurzel von $T$. Erreicht $p$ den Knoten mit $\mathit{key}\left(k\right)$ so wird das preferred child des Knoten mit Schlüssel $k$ in $P$ auf \textit{left} gesetzt. So dass nochmals eine Anpassung notwendig sein kann. Die Operation wird noch etwas detaillierter beschrieben. Zur Vereinfachung bezeichnet $T$ immer den aktuellen Zustand des Tango Baums und $H_1$ immer den Hilfsbaum mit der Wurzel von $T$:
\begin{enumerate}
	\item Setze $p$ auf die Wurzel von $H_1$
	\item Suche nach $k$. Wird $k$ innerhalb von $H_1$ erreicht weiter bei \ref{gefunden}. Ansonsten wird die Wurzel eines Hilfsbaumes $H_2$ erreicht.
	\item Sei $w_2$ die Wurzel von $H_2$. Führe $H_3 =$ \textit{cut}$\left(w_2.\textit{minDepth} - 1\right)$ aus.
	\item Führe \textit{join}$\left(H_3, ~H_2\right)$ aus. Weiter bei 1.
	\item \label{gefunden} Sei $v$ der Knoten mit \textit{key}$\left(v\right) = k$. Führe $H_3=$\textit{cut}$ \left(v.\textit{depth}\right)$ aus. 
	\item Suche im linken Teilbaum von $v$ nach dem Vorgänger von $v$, bis die Wurzel eines Hilfsbaumes erreicht wird, oder ein rechtes Kind fehlt. Wird keine Wurzel erreicht weiter mit \ref{ende}.
	\item Sei $H_4$ der Hilfsbaum, auf dessen Wurzel $p$ zeigt. Führe \textit{join}$\left(H_3, ~H_4\right)$ aus.
	\item \label{ende} Gib $p$ zurück.
\end{enumerate}
Zu klären ist noch, warum im sechsten Punkt, der die Wurzel des richtigen Hilfsbaums gefunden werden muss. Seien $u$ und $u_l$ Knoten in $P$, so dass $u_c$ das linke Kind von $u$, aber nicht das preferred child von $u$ ist. Sei $v$ bzw. $v_c$ der Knoten in $T$ mit $\mathit{key}\left(v\right) = \mathit{key}\left(u\right)$ bzw. $\mathit{key}\left(v_c\right) = \mathit{key}\left(u_c\right)$. Sei $H_1$, mit Wurzel $w_1$, der Hilfsbaum der $v$ enthält und $H_2$, mit Wurzel $w_2$, der Hilfsbaum der $v_c$ enthält. Es muss einen Pfad $P = \left(v_0, v_1,.., v_m \right)$ geben, mit $v_0 = w_1$, $v_m = w_2$ und $v_{m-1}$ ist in $H_1$ enthalten. Aufgrund der Links-Rechts-Beziehung in $H_1$, muss $v_m$ entweder das linke Kind von $v$ sein, oder das rechte Kind des Vorgängers $v_v$ von $v$ in $H_1$. \\
Sei $v_m$ das rechte Kind von $v_v$. Dann kann $v$ nicht im rechten Teilbaum von $v_v$ liegen (im linken natürlich auch nicht). Angenommen $v$ ist kein Vorfahre von $v_v$, dann muss es einen Knoten $w$ geben, mit $v_v$ liegt im linken Teilbaum von $w$ und $v_v$ im rechten. Ein Widerspruch dazu, dass $v_v$ der Vorgänger von $v$ ist.\\
Es gibt also in jedem Fall einen Pfad von $v$ zu $w_2$. $w_2$ kann bezogen auf $T$ nur im linken Teilbaum von $v$ enthalten und für alle in $H_1$ enthaltenen Schlüssel $k_1$ gilt entweder $k_1 > \mathit{key}\left(v\right) > \mathit{key}\left(v_v\right) $ oder  $ \mathit{key}\left(v\right) > \mathit{key}\left(v_v\right) > k_1 $.


\subsection{Laufzeitanalyse für access}
Zunächst wird in zwei Lemmas die Einzeloperation betrachtet, bevor es dann im Satz um Zugriffsfolgen geht. Alle drei Abschnitte basieren auf \cite{demainDinamicOpti}.

 
\begin{Lemma} \label{demaineLemma4}
	Sei $n$ die Anzahl der Knoten eines Tango-Baum $T_{i-1}$. Sei $k$ die Anzahl der Knoten bei denen sich während der Ausführung von \textit{access}$\left(x_i\right)$ eine Änderung des preferred child ergeben hat. Für die Laufzeit \textit{access}$\left(x_i\right)$ gilt dann $O\left(\left(k + 1\right) \left(1 + \log \left( \log  \left(n \right)\right)\right)\right)$.
\end{Lemma}
\begin{proof}
	Bezeichne $T_i$ den Tango-Baum nach der Ausführung von \textit{access}$\left(x_i\right)$. Zuerst werden die Kosten für das Suchen betrachtet. Der Zeiger $p$ der Operationen startet maximal $k + 1$ mal an der Wurzel des Tango-Baum. Für die Länge eines Pfades innerhalb eines Hilfsbaumes gilt $O\left(\log \left( \log  \left(n \right)\right)\right)$, denn für die Anzahl der Knoten eines preferred path gilt $O\left( \log \left(n\right)  \right)$ und ein Hilfsbaum muss ein balancierter BST sein. Die Gesamtkosten ergeben sich damit zu $O\left(\left(k + 1\right) \left(1 + \log \left( \log  \left(n \right)\right)\right)\right)$.\\
	Nun werden die Kosten zum erzeugen von $T_i$ aus $T_{i-1}$ betrachtet. Pro Veränderung eines preferred childs kommt es zu Kosten $O\left( \log_2\left(\log_2 \left(n\right)\right)\right)$ aufgrund einer \textit{cut} und einer \textit{join} Operation. Für das Suchen des Hilfsbaumes im bei der letzten Transformation zu $T_i$ (Punkt 6 in der Beschreibung) entstehen auch wieder Kosten von $O\left(\log \left( \log  \left(n \right)\right)\right)$. Somit gilt auch für die Gesamtkosten $O\left(\left(k + 1\right) \left(1 + \log \left( \log  \left(n \right)\right)\right)\right)$.
	
	
\end{proof}
\noindent Sei $\mathit{IB}_i\left(X\right)$ die Differenz von $\mathit{IB}\left(x_1, x_2,..,x_i\right)$ und  $\mathit{IB}\left(x_1, x_2,..,x_{i-1}\right)$. 

\begin{Lemma} \label{demaineLemma5}
	Während der Ausführung von \textit{access}$\left(x_i\right)$ kommt es an genau $\mathit{IB}_i\left(X\right)$ Knoten zu einer Änderung des preferred child.
\end{Lemma}
\begin{proof}
	Sei $p \in P$. Das preferred child von $p$ wechselt während  \textit{access}$\left(x_i\right)$ von links nach rechts  wenn $x_i$ in der rechten Region von $p$ liegt und der letzte Zugriff innerhalb des Teilbaumes mit Wurzel $p$ in der linken Region von $p$ lag.  Das preferred child von $p$ wechselt während  \textit{access}$\left(x_i\right)$ von rechts nach links  wenn $x_i$ in der linken Region von $p$ liegt und der Schlüssel des vorherigen Zugriffs innerhalb des Teilbaumes mit Wurzel $p$ in der rechten Region von $p$ lag. Das entspricht jeweils genau einem Interleave durch $p$. Zu beachten ist noch, dass der erste Zugriff auf den Teilbaum mit Wurzel $p$ weder zu einem Interleave noch zu einem Wechsel eines preferred child von links bzw. rechts zu rechts bzw. links führt. 	
\end{proof}

\begin{Satz} \label{demaineSatz2}
	Für die Laufzeit eines Tango Baum mit $n$ Knoten für eine Zugriffsfolge $X = x_1, x_2,.., x_m$ gilt $O\left(\left(\mathit{OPT}\left(X\right) + n\right)  + \left(  1 + \log\left(\log \left(n\right)\right)\right)   \right)$
\end{Satz}
\begin{proof}
	Nach Lemma \ref{demaineLemma5} gibt es nicht mehr als  $\mathit{IB}\left(X\right)$ Wechsel der preferred childs von links nach rechts oder umgekehrt. Zudem gibt es maximal $n$ zusätzliche Änderungen bei preferred childs. (Erstzugriff in den Teilbaum). Die Gesamtanzahl der Änderungen von preferred childs ist somit höchstens $\mathit{IB}\left(X\right) + n$. Mit Lemma \ref{demaineLemma4} ergeben sich Gesamtkosten von\\ $O\left(\left(\mathit{IB}\left(X\right) + n +m \right) \left( 1 + \log \left(\log\left(n\right)\right)\right) \right)$. Mit $\mathit{OPT}\left(X\right) \geq \mathit{IB}\left(X\right) /2 -n $ aus Satz \ref{satzDemaine1} ergibt sich 
	$O\left(\left(\mathit{OPT}\left(X\right) + n +m \right) \left( 1 + \log \left(\log\left(n\right)\right)\right) \right)$. Mit $\mathit{OPT}\left(X\right) \geq m$ ergibt sich dann die Behauptung.
\end{proof}
\noindent Mit $m \in \Omega\left(n\right)$ gilt dann auch 
$O\left(	\mathit{OPT}\left(X\right) 	\left( 1 + \log \left(\log \left(n\right)\right)\right)	 \right)$.
Außerdem kann die angegebene obere Schranke nicht verbessert werden. Kommt es bei \textit{access}$\left(x\right)$ zu $\Omega\left(\log\left(n\right)\right)$ Wechsel bei preferred childs, muss der Hilfsbaum an der Wurzel des Tango-Baumes $\Omega\left(\log\left(n\right)\right)$ mal durchlaufen werden. Somit hat der Tango-Baum die balanced Eigenschaft aus Abschnitt \ref{upperBounds} nicht. Somit kann er aufgrund der Implikationen auch die anderen Eigenschaften aus diesem Abschnitt nicht haben. Später werden zwei $\log\left(\log\left(n\right)\right)$-competitve BST vorgestellt, welche das balanced property erfüllen.      

\section{Rot-Schwarz-Baum}
Der Rot-Schwarz-Baum gehört zur Gruppe der \textbf{balancierten BST} und erfüllt alle Eigenschaften um ihn als Hilfsstruktur im Tango Baum zu verwenden. Genau das ist auch die Rolle des Rot-Schwarz-Baumes in dieser Ausarbeitung. Damit die Beschreibungen nicht zu kleinteilig werden, wird darauf verzichtet, die Pflege der \textit{depth} Variablen und der Zeiger auf andere Hilfsbäume zu beschreiben. Bei balancierten BST gilt für die Höhe $h = \mathit{O(\log n)}$, mit $n =$ Anzahl der Knoten. Jeder Knoten benötigt ein zusätzliches Attribut, um eine Farbinformation zu speichern. Der Name der Datenstruktur kommt daher, dass die beiden durch das zusätzliche Attribut unterschiedenen Zustände als \textit{rot} und \textit{schwarz} bezeichnet werden. Die Farbe ist also eine Eigenschaft der Knoten und im folgenden wird einfach von roten bzw. schwarzen Knoten gesprochen. Als Blätter werden schwarze Sonderknoten verwendet, deren Schlüssel auf einen Wert außerhalb des Universums, hier \textit{null}, gesetzt wird, um sie eindeutig erkennen zu können. $\mathit{null}$ gehört nicht zur Schlüsselmenge des RBT. Fehlende Kinder von Knoten mit gewöhnlichem Schlüssel werden durch solche Blätter ersetzt.  

\noindent Folgende zusätzliche Eigenschaften müssen bei einem Rot-Schwarz-Baum erfüllt sein. 

\begin{enumerate}
	\item Jeder Knoten ist entweder rot oder schwarz.
	\item Die Wurzel ist schwarz.
	\item Jedes Blatt (Sonderknoten) ist schwarz.
	\item Der Elternknoten eines roten Knotens ist schwarz.
	\item Für jeden Knoten gilt, dass alle Pfade, die an ihm starten und an einem Blatt (Sonderknoten) enden, die gleiche Anzahl an schwarzen Knoten enthalten. 
\end{enumerate}  
Sei $(v_0,v_1,...,v_n)$ ein Pfad von einem Knoten $v_0$ zu einem Blatt $v_n$. Die Anzahl der schwarzen Knoten innerhalb $(v_1,...,v_n)$ wird als \textbf{Schwarz-Höhe} $\mathit{bh(v_0)}$ von Knoten $v_0$ bezeichnet. Die eigene Farbe des betrachteten Knotens bleibt dabei also außen vor. Dadurch hat ein Knoten die gleiche Schwarz-Höhe wie ein rotes Kind und eine um eins erhöhte Schwarz-Höhe gegenüber einem schwarzen Kind. Die Schwarz-Höhe der Wurzel entspricht der \textbf{Schwarz-Höhe des Baumes~ $bh(T)$}, wobei ein leerer Baum Schwarz-Höhe $0$ hat. Die Schwarz-Höhe eines Knoten $x$ ist genau dann eindeutig wenn er Eigenschaft 5 nicht verletzt. Hält $x$ Eigenschaft 5 ein und sei $i$ die Anzahl schwarzer Knoten in den entsprechenden Pfaden, so gilt $\mathit{bh(x)} = i$ wenn $x$ rot ist und $\mathit{bh(x)} = i - 1$ wenn $x$ schwarz ist. Ist $\mathit{bh(x)}$ eindeutig, so enthält jeder Pfad der mit $x$ startet und an einem Blatt endet $\mathit{bh(x)} + 1$ schwarze Knoten, wenn $x$ schwarz ist und  $\mathit{bh(x)}$ schwarze Knoten wenn $x$ rot ist.\\ Jeder Knoten speichert seine Schwarz-Höhe als weiteres Attribut, da wir dieses in Abschnitt \ref{vereinigen} benötigen. Natürlich muss das Attribut, dann auch gesetzt und gepflegt werden, wobei es bei Sonderknoten fest mit $0$ belegt ist. Im folgenden wird \textbf{RBT} (Red Black Tree) als Abkürzung für Rot Schwarz Baum verwendet. Aufgrund der Sonderknoten gibt es eine etwas spezielle Situation, bei einem RBT mit Höhe 1. Diese Konstellation ist nur mit einem einzelnen Sonderknoten erreichbar, so dass man statt dessen auch einfach den leeren Baum verwenden könnte. Auch diese Konstellation erfüllt aber die Eigenschaften, so dass sie kein Problem darstellt. \\



\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/RotSchwarzBaum/IOBaum"}
	\caption{Rot Schwarz Baum ohne Verletzung von Eigenschaften. }
	\label{fig:IOBaum}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/RotSchwarzBaum/NIOBaumZweiRote"}
	\caption{Rot Schwarz Baum bei dem Eigenschaft vier und fünf verletzt sind. }
	\label{fig:NIOBaumZweiRote}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/RotSchwarzBaum/NIOBaumPfadlänge"}
	\caption{Rot Schwarz Baum bei dem Eigenschaft fünf verletzt ist.  }
	\label{fig:NIOBaumPfadlänge}
\end{figure}
\subsection{Grundoperationen}
\paragraph{Suchen im Rot-Schwarz-Baum}
Die Suche unterscheidet sich nur in einem Punkt von der in \ref{BST Operationen} vorgestellten. Wird nach einem Schlüssel gesucht, der im RBT nicht vorhanden ist, so wird einer der Sonderknoten erreicht. In diesem Fall wird die Suche abgebrochen und eine leere Referenz zurückzugeben. Die Operation verändert den RBT nicht. 

\paragraph{Einfügen in den Rot-Schwarz-Baum}
\textit{insert} wird für eine Hilfsstruktur zum Tango Baum eigentlich nicht benötigt. Für \textit{concatenate} wird später jedoch eine Hilfsoperation benötigt, die am Besten zu \textit{insert} beschrieben werden kann.
Sei $k$ der einzufügende Schlüssel. Zunächst wird wie beim Suchen vorgegangen. Wird $k$ gefunden wird der RBT nicht verändert. Ansonsten wird ein Sonderknoten $b$ erreicht. Ein neu erzeugter roter Knoten $v_k$ mit Schlüssel $k$ und Schwarz-Höhe $1$ nimmt den Platz von $b$ ein. $k$ werden Sonderknoten als linkes und rechtes Kind angefügt. $k$ ist nun im Baum enthalten, es muss jedoch auf mögliche Verletzungen der fünf Eigenschaften geachtet werden. Welche können betroffen sein ?

\begin{enumerate}
	\item Es ist immer noch jeder Knoten entweder rot oder schwarz.
	\item Wurde in den leeren Baum eingefügt, so ist der neu eingefügte rote Knoten die Wurzel, was eine Verletzung darstellt.  Waren bereits Knoten im Baum vorhanden blieb die Wurzel unverändert.
	\item Aufgrund der Sonderknoten sind die Blätter immer noch schwarz.
	\item Der Baum wird nur direkt an der Einfügestelle verändert. Der neue Knoten hat schwarze Kindknoten, er könnte jedoch einen roten Elternknoten haben, so dass diese Eigenschaft verletzt wäre.
	\item Die Schwarz-Höhe von $v_k$ ist korrekt gesetzt. Die Schwarz-Höhe keines anderen Knotens hat sich verändert, denn den Platz eines schwarzen Knoten mit Schwarz-Höhe $0$ nimmt nun ein roter Knoten mit Schwarz-Höhe $1$ ein. Eigenschaft fünf bleibt also erhalten. 
\end{enumerate}  

\noindent Es können also die Eigenschaften zwei und vier betroffen sein. Jedoch nur eine von ihnen, denn Eigenschaft zwei wird genau dann verletzt wenn der neue Knoten die Wurzel des Baumes ist, dann kann er aber keinen roten Elternknoten haben.

\noindent Zur Korrektur wird zum Ende von \textit{insert} eine zusätzliche Operation, \textbf{insertFixup(Node $v_{in}$)} aufgerufen. Diese Operation arbeitet sich von $v_i$ startend, solange in einer Schleife nach oben im BST durch, bis alle Eigenschaften wieder erfüllt sind. Die Schleifenbedingung ist, dass eine Verletzung vorliegt. Dazu muss geprüft werden ob der betrachtete Knoten $x$ die rote Wurzel des Gesamtbaumes ist, oder ob er und sein Elternknoten beide rot sind. Vor dm ersten Durchlauf wird $x = v_{in}$ gesetzt. Innerhalb der Schleife werden sechs Fälle unterschieden. Im folgenden wird auf vier Fälle detailliert eingegangen. Die restlichen zwei verhalten sich symmetrisch zu einem solchen. Jeder der Fälle verantwortet, dass zum Start der nächsten Iteration wieder nur maximal eine der beiden Eigenschaften zwei oder vier verletzt sein kann und Eigenschaft vier höchstens an einem Knoten verletzt ist. Die Fallauswertung geschieht in aufsteigender Reihenfolge. Deshalb kann man innerhalb einer Fallbehandlung verwenden, dass die vorherigen Fallbedingungen nicht erfüllt sind. Eigenschaft eins bleibt in der Beschreibung außen vor, da es während der gesamten Ausführungszeit der Operation nur Knoten gibt, die entweder rot oder schwarz sind. \\

\noindent\textbf{Fall 1: $x$ ist die rote Wurzel des RBT: }
Dieser Fall wird behandelt in dem die Wurzel schwarz gefärbt wird. Man muss noch zeigen, dass es durch das Umfärben zu keiner anderen Verletzung gekommen ist.\\

Betrachtung der Eigenschaften:
\begin{enumerate}
	\item -
	\item Die Wurzel wurde schwarz gefärbt.
	\item Die Blätter (Sonderknoten) sind unverändert.
	\item Es wurden weder rote Knoten hinzugefügt, noch wurde die Kantenmenge verändert. 
	\item Das Umfärben der Wurzel kann hierauf keinen Einfluss haben, da sie in der Berechnung der Schwarz-Höhe jedes Knotens außen vor ist.
\end{enumerate}  

\noindent Es wird also keine Eigenschaft mehr verletzt und die Schleife wird keine weitere Iteration durchführen.\\
Die Fälle 2 - 6 behandeln nun die Situationen, in denen sowohl $x$ als auch dessen Elternknoten $y$ rote Knoten sind. Da Eigenschaft fünf nach jeder Iteration erfüllt ist muss $y$ einen Geschwisterknoten haben. Denn da zu Beginn einer Iteration nur eine Eigenschaft verletzt sein kann, kann der rote $y$ nicht die Wurzel sein, also muss auch $y$ einen Vorgänger $z$ haben. Da $z$ kein Blatt(Sonderknoten) ist, müssen beide Kinder vorhanden sein.\\
Außerdem muss $z$ schwarz sein, ansonsten wäre Eigenschaft vier an zwei Knoten verletzt.\\

\noindent\textbf{Fall 2: $y$ hat einen roten Geschwisterknoten: }
\noindent Diesen Fall veranschaulicht Abbildung \ref{fig:EinfügenFixUpFall2}. Es wird $z$ rot gefärbt und beide Kinder von $z$, also $y$ und dessen Geschwisterknoten, schwarz. Die Schwarz-Höhe von $z$ wird um eins erhöht. Somit ist der Elternknoten von $x$ nun schwarz und die Verletzung der Eigenschaft vier wurde an dieser Stelle behoben. Wie sieht es aber mit den Verletzungen insgesamt aus ? \\

Betrachtung der Eigenschaften:

\begin{enumerate}
	\item -
	\item Wenn $z$ die Wurzel des Baumes ist, wurde sie rot gefärbt und eine Verletzung liegt vor.
	\item Der rot umgefärbte Knoten $z'$ hat zwei Kinder, somit wurde kein Blatt rot gefärbt.
	\item  Wenn der rot gefärbte Knoten $z'$ nicht die Wurzel ist, könnte er einen roten Elternknoten haben und Eigenschaft vier ist weiterhin Verletzt. Das Problem liegt nun aber zwei Baumebenen höher.
	\item  Die Schwarz-Höhen der Vorfahren von $z'$ bleiben unverändert, da jeder Pfad von ihnen zu einem Blatt auch entweder $y'$ oder dessen Geschwisterknoten enthält. $z'$ Schwarz-Höhe steigt um eins gegenüber $z$, bleibt aber eindeutig. An keinem anderen Knoten ändert sich die Schwarz-Höhe. 
	
\end{enumerate} 
Es kann also wieder nur entweder Eigenschaft zwei oder vier verletzt sein. Wenn das Problem noch nicht an der Wurzel ist, liegt es zumindest zwei Ebenen näher daran. $x$ wird auf $z'$ gesetzt. 
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7 \textwidth]{"Medien/RotSchwarzBaum/EinfügenFixUpFall1"}
	\caption{\textit{insertFixup}. Dargestellt ist Fall 1  }
	\label{fig:EinfügenFixUpFall1}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/RotSchwarzBaum/EinfügenFixUpFall2"}
	\caption{\textit{insertFixup}. Dargestellt ist Fall 2  }
	\label{fig:EinfügenFixUpFall2}
\end{figure}

\noindent\textbf{Fall 3: $x$ ist ein linkes Kind. $y$ ist ein linkes Kind: }\\
\noindent Abbildung \ref{fig:EinfügenFixUpFall3} zeigt eine entsprechende Situation. Es wird eine Rechtsrotation auf $y$ ausgeführt. Anschließend wird $z$ rot gefärbt und $y$ schwarz. \\

\noindent Betrachtung der Eigenschaften:\\
\noindent Dazu werden vier weitere Variablen auf Knoten verwendet. Es zeigt $\mathit{xl}$ auf das linke Kind von $x$,  $\mathit{xr}$ entsprechend das rechte Kind. $\mathit{yr}$ und $zr$ bezeichnen die rechten Kinder von $y$ bzw. $z$. Nachfolgend wird verwendet, dass die Teilbäume mit den Wurzeln $xl$, $xr$, $yr$ und $zr$ durch die Ausführung unverändert bleiben.
\begin{enumerate}
	\item -
	\item Wenn $z$ zu Beginn nicht die Wurzel des Gesamtbaumes war, bleibt diese unverändert. Ansonsten wurde durch die Rotation $y'$ zur neuen Wurzel und $y'$ wurde schwarz gefärbt. 
	\item  In der zweiten Ebene unter $y'$ befinden sich ausschließlich die unveränderten Teilbäumen mit den Wurzeln $xl'$, $xr'$, $yr'$ oder $zr'$. An den Blättern verändert sich also durch die Ausführung nichts.
	\item  Knoten $x'$ ist linkes Kind des schwarzen $y'$. Die Teilbäume von $x'$ blieben unverändert. Der linke Teilbaum von $y'$ enthält somit keine aufeinanderfolgenden roten Knoten. Das rechte Kind von $y'$ ist der rote Knoten $z'$. Rechts an $z'$ hängt nun ein unveränderter Teilbaum, dessen Wurzel zuvor Geschwisterknoten von $y$ war. Dieser ist nach Fallunterscheidung ein schwarzer Knoten. Links hängt ebenfalls ein unveränderter Teilbaum, dessen Wurzel zuvor rechter Nachfolger von $y$ war. Der rechte Nachfolger von $y$ muss schwarz sein, ansonsten wäre Eigenschaft vier an zwei Knoten verletzt gewesen. Im Teilbaum mit Wurzel $y$ gibt es also keine aufeinanderfolgenden roten Knoten. Da $y'$ schwarz gefärbt wurde, kann auch außerhalb des Teilbaumes mit $y'$ keine neue Verletzung entstanden sein.
	\item  Es gilt  $\mathit{bh(xl)} = \mathit{bh(xr)} = \mathit{bh(yr)} =  \mathit{bh(zr)} = \mathit{bh(z)} - 1$. Wie oben bereits erwähnt wird die zweite Ebene unter der Wurzel $y'$ von den unveränderten Teilbäumen $\mathit{xl'}$, $\mathit{xr'}$, $\mathit{yr'}$ und $\mathit{zr'}$ gebildet. Es müssen also lediglich die Knoten $x'$, $y'$ und $z'$ betrachtet werden. Die Kinder von $x'$ und $z'$ sind schwarze Knoten mit der Schwarz-Höhe $\mathit{bh(z)} - 1$. Die Schwarz-Höhen von $x'$ und $z'$ sind also eindeutig und es gilt $\mathit{bh(x')} = \mathit{bh(z')} = \mathit{bh(z)}$. $y'$ Kinder sind die roten Knoten $x'$ und $z'$. Da beide Kinder rot sind gilt $\mathit{bh(y')} = \mathit{bh(x')} = \mathit{bh(z)}$. Somit sind alle Schwarz-Höhen im betrachteten Teilbaum eindeutig. Die neue Wurzel der Teilbaumes $y'$ hat die gleiche Schwarz-Höhe und die gleiche Farbe wie die vorherige Wurzel $z$. Damit kann es auch im Gesamtbaum zu keiner Verletzung der Eigenschaft gekommen sein.
\end{enumerate} 

\noindent Es ist keine der Eigenschaften verletzt, daher wird es zu keiner Iteration mehr kommen.


\noindent\textbf{Fall 4: $x$ ist ein rechtes Kind. $y$ ist ein linkes Kind.: }\\      
Dieser in Abbildung \ref{fig:EinfügenFixUpFall4} gezeigte Fall wird so umgeformt, dass eine Situation entsteht bei der Fall drei angewendet werden kann. Dazu wird eine Linksrotation an Knoten $x$ durchgeführt.\\

\noindent Betrachtung der Eigenschaften:\\
Zu Veränderungen kommt es durch die Rotation lediglich im linken Teilbaum von $z$. Es sei $\mathit{xl}$ das linke Kind von $x$,  und $\mathit{xr}$ das rechte Kind von $x$. $\mathit{yl}$ ist das linke Kind von $y$. $\mathit{xl}$, $\mathit{xr}$ und $\mathit{yl}$ müssen schwarz sein, ansonsten wäre Eigenschaft vier mehrfach verletzt gewesen.
\begin{enumerate}
	\item -
	\item Die Wurzel bleibt unverändert.
	\item  Die Teilbäume mit den Wurzeln $\mathit{xl}$, $\mathit{xr}$ und $\mathit{yl}$ enthalten alle Blätter innerhalb des linken Teilbaumes von $z$. Die Teilbäume  $\mathit{xl}$, $\mathit{xr}$ und $\mathit{yl}$ bleiben durch die Rotation unverändert und $\mathit{xl'}$, $\mathit{xr'}$ und $\mathit{yl'}$ enthalten auch alle Blätter des linken Teilbaumes von $z'$.
	\item Da $x$ und $y$ rot sind müssen $z$, $\mathit{xl}$ und $\mathit{xr}$ schwarz sein. Nach der Rotation ist $y'$ linkes Kind von $x'$. $x'$ ist Kind vom schwarzen $z'$. Alle verbleibenden Kinder von $x'$ und $y'$ werden durch die unveränderten Teilbäume $\mathit{xl'}$, $\mathit{xr'}$ und $\mathit{yl'}$ gebildet. Deren Wurzeln müssen schwarz sein, ansonsten hätte es in ursprünglichen Baum an mehr als einem Knoten eine Verletzung von Eigenschaft vier gegeben. Durch die Rotation verbleibt es also bei einer Verletzung der Eigenschaft vier in der gleiche Baumebene. Die beiden beteiligten roten Knoten sind nun aber jeweils linke Kinder.   
	\item $ \mathit{bh(yl)} = \mathit{bh(xl)} = \mathit{bh(xr)} = \mathit{bh(yl')} = \mathit{bh(xl')} = \mathit{bh(xr')} $. Die Schwarz-Höhen von $x$ und $y$ bleiben unverändert. Damit kommt es auch bei $z$ zu keiner Veränderung der Schwarz-Höhe. 
\end{enumerate}  

\noindent Es sind also weiterhin zwei rote aufeinanderfolgende rote Knoten in den gleichen Baumebenen vorhanden. Diese sind nun aber beides linke Kinder. Der Geschwisterknoten des oberen roten Knotens ist der selbe schwarze Knoten wie vor der Ausführung von Fall 4. Damit kann direkt mit dem bearbeiten von Fall 3 begonnen werden. Es benötigt keine weitere Iteration.\\

\noindent\textbf{Fall 5: $x$ ist ein rechtes Kind. $y$ ist ein rechtes Kind: }\\ 
Abbildung \ref{fig:EinfügenFixUpFall5} zeigt den zu Fall 3 Links/Rechts-Symmetrischen Fall 5.\\
\noindent\textbf{Fall 6:  $x$ ist ein linkes Kind.$y$ ist ein rechtes Kind: }\\ 
Abbildung \ref{fig:EinfügenFixUpFall6} zeigt den zu Fall 4 Links/Rechts-Symmetrischen Fall 6.\\


\paragraph{Laufzeit}
\noindent  Sei $h$ die Höhe des Gesamtbaumes vor Aufruf von einfügen-Fixup. Fall 2 kann maximal $h / 2$ mal ausgewählt werden, bevor $x$ oder $y$ an der Wurzel liegt. Nach einer Iteration bei der nicht Fall 2 ausgewählt wird, terminiert einfügen-fixup. Der Aufwand innerhalb jeder Fallbehandlung ist $O(1)$. Für die Gesamtlaufzeit gilt deshalb $\mathit{O(h)}$.
\begin{figure}[H]
	\centering
	\includegraphics[width=1 \textwidth]{"Medien/RotSchwarzBaum/EinfügenFixUpFall3"}
	\caption{\textit{insertFixup}. Dargestellt ist Fall 3  }
	\label{fig:EinfügenFixUpFall3}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=1 \textwidth]{"Medien/RotSchwarzBaum/EinfügenFixUpFall4"}
	\caption{\textit{insertFixup}. Dargestellt ist Fall 4  }
	\label{fig:EinfügenFixUpFall4}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1 \textwidth]{"Medien/RotSchwarzBaum/EinfügenFixUpFall5"}
	\caption{\textit{insertFixup}. Dargestellt ist Fall 5  }
	\label{fig:EinfügenFixUpFall5}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics[width=1 \textwidth]{"Medien/RotSchwarzBaum/EinfügenFixUpFall6"}
	\caption{\textit{insertFixup}. Dargestellt ist Fall 6  }
	\label{fig:EinfügenFixUpFall6}
\end{figure}   
\paragraph{Löschen aus dem Rot-Schwarz-Baum}
Die Reparatur des RBT nach dem entfernen eines Knotens ist aufwendiger, als die nach dem einfügen. Da der RBT in der Rolle als Hilfsstruktur für den Tango-Baum keine solche Operation benötigt, entfällt die Beschreibung. In \cite{algEinf} ist eine detaillierte Beschreibung enthalten. 
\paragraph{Laufzeit der Grundoperationen}
Zu Beginn des Kapitels wurde erwähnt, dass für die Höhe $h$ eines RBT mit $n$ Knoten $h = \mathit{O(\log {n})}$  gilt. Das wird nun gezeigt. 

\begin{Lemma} Für die Höhe $h$ eines RBT $T$ mit $n$ Knoten gilt $h = \mathit{O(\log {n})}$ . 
\end{Lemma}
\begin{proof}
	Sei $w$ die Wurzel von $T$ und $m$ die Anzahl der inneren Knoten von $T$. 
	Zunächst wird gezeigt, dass T mindestens $2^\mathit{bh(w)} - 1$ innere Knoten enthält.
	Dies geschieht mit Induktion über $h$. Für $h = 0$ und  $h = 1$ mit $2^0 - 1 = 0 $ stimmt die Behauptung, denn der Baum ist leer oder ein einzelner Sonderknoten.  
	Induktionsschritt mit Höhe $h + 1$:\\
	Sei $T_l$ der linke Teilbaum von $w$ und $T_r$ der rechte Teilbaum von $w$.  
	Im Induktionsschritt kann nun verwendet werden, dass $h > 1$ gilt und $w$ ein innerer Knoten sein muss. $T_l$ und $T_r$ haben Schwarz-Höhe $\mathit{bh(w)} - 1$ wenn ihre Wurzel schwarz ist und Schwarz-Höhe $\mathit{bh(w)}$ wenn ihre Wurzel rot ist. Ihre Höhe ist $h-1$ und somit enthalten sie nach Induktionsnahme mindestens  $2^\mathit{bh(w)- 1} - 1$ innere Knoten. Aufaddieren ergibt die Behauptung.\\    
	\begin{align*}
	&m \geq 2^\mathit{bh(w)- 1} - 1  + 1  + 2^\mathit{bh(w)- 1} - 1 = 2^\mathit{bh(w)} - 1
	\end{align*}
	Daraus folgt:\\
	\begin{align*}
	\Rightarrow  log_2(m + 1) \geq\mathit{bh(w)}\\ 
	\end{align*}
	\noindent Es gilt folgender Zusammenhang, da höchstens jeder zweite Knoten in einem Pfad rot sein kann\\
	\begin{align*}
	&\mathit{h(w)} \leq 2 \cdot \mathit{bh(w) } + 1 \\
	\Rightarrow &\frac{\mathit{h(w)} - 1}{2} \leq\mathit{bh(w) } \\
	\end{align*}
	\text{Einsetzen liefert:}\\
	\begin{align*}
	&log_2(m + 1) \geq\frac{\mathit{h(w)} - 1}{2} \\
	\Rightarrow	&2 \cdot log_2(m + 1) + 1 \geq\mathit{h(w)} \\
	\Rightarrow &\mathit{h(w)} = \mathit{O(\log {m})} 
	\end{align*}
	
	
	
	
	
	
	\noindent Es kann nur maximal doppelt so viele Blätter wie innere Knoten geben. Daraus folgt.
	\begin{align*}
	&n  \leq 3 m \\
	\Rightarrow &\mathit{h(w)} = \mathit{O(\log {n})} 
	\end{align*} 
	
	
\end{proof}
\noindent \textit{search} und \textit{insert} haben also Laufzeit $\mathit{O(\log {n})}$.


\subsection{Tango-Baum konformes vereinigen} \label{vereinigen}
\begin{figure}[h]
	\centering
	\includegraphics[height= 0.6\textwidth]{"Medien/RotSchwarzBaum/vereinigen"}
	\caption{Beispielhaftes \textit{concatenate} zweier RBT unterschiedlicher Schwarz-Höhe, nach Schritt 1. }
	\label{fig:vereinigen}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[height= 0.6\textwidth]{"Medien/RotSchwarzBaum/vereinigen2"}
	\caption{Beispielhaftes \textit{concatenate} zweier RBT gleicher Schwarz-Höhe, nach Schritt 1 }
	\label{fig:vereinigen2}
\end{figure}
\noindent Hier wird die \textit{concatenate(RBT $T_1$, key $k$, RBT $T_2)$} Operation eingeführt, wie es ein Tango-Baum von seiner Hilfsstruktur verlangt. Sei $K_1$ die Schlüsselmenge von $T_1$ und $K_2$ die von $T_2$. Die Operation gibt eine Referenz auf die Wurzel eines vereinigten RBT $T$ mit Schlüsselmenge $K_1 \cup K_2 \cup \{k\} $ zurück, dabei werden $T_1$ und $T_2$ zerstört. An die Parameter wird die Vorbedingung $(\forall i \in K_1: i < k ) \land (\forall j \in K_2: k < j )$ gestellt.\\
Es werden im ersten Schritt der Ausführung drei Fälle unterschieden, wobei wieder der erste zutreffende Fall in aufsteigender Reihenfolge ausgewählt wird. \\
\noindent\textbf{Fall 1: $bh(T_1) = bh(T_2) = 0$ }\\   
In diesem Fall wird ein roter Knoten $v$ mit Schlüssel $k$ und Schwarz-Höhe $1$ erzeugt. An diesem werden zwei Sonderknoten angefügt. $v$ ist die Wurzel von $T$. \\
In den restlichen Fällen ist nun immer zumindest ein Baum vorhanden, der über eine Wurzel verfügt. Der RBT mit der geringeren Schwarz-Höhe wird dabei an den mit der höheren \enquote{seitlich angefügt}. Abbildung \ref{fig:vereinigen} zeigt dies beispielhaft. Sind die Schwarz-Höhen gleich wird wie in Abbildung \ref{fig:vereinigen2} vorgegangen. Nun werden die verbleibenden Fälle beschrieben.\\
\noindent\textbf{Fall 2: $bh(T_2) \leq bh(T_1)$ }\\
In diesem Fall wird $T_2$ bei $T_1$, mit Hilfe von $k$, so angefügt, dass die Schwarz-Höhe jedes Knoten unverändert bleibt. Es sei $w_1$ die Wurzel von $T_1$. Es sei $P$ ein Pfad $(r_0,r_1,...,r_l)$ in $T_1$, so dass $r_0 = w_1$, $r_l$ ein Blatt ist und $\forall i \in \{1,2,...l\} \colon r_i$  ist rechtes Kind von  $r_{i-1}$ gilt. $P$ ist also der am weitesten rechts liegende Pfad von der Wurzel zu einem Blatt. Sei $x$ der schwarze Knoten in $P$, mit $\mathit{bh}(x) = \mathit{bh}(w_2)$. $x$ muss existieren denn $\mathit{bh}(w_1) \geq \mathit{bh}(w_2)$ und $\mathit{bh}(r_l) \leq  \mathit{bh}(w_2)$, außerdem sind $w_1$ und $r_l$ schwarz.\\
Nun wird ein neuer roter Knoten $v$ mit Schlüssel $k$ und Schwarz-Höhe $\mathit{bh}(x) + 1$ erzeugt. Als linkes Kind von $v$  wird $x$ gesetzt, als rechtes Kind $w_2$. Ist $x$ die Wurzel in $T_1$, so ist $v$ die Wurzel von $T$. Ansonsten ist $x$ rechtes Kind eines Knoten $y$ und das rechte Kind von $y$ wird auf $v$ gesetzt. Außerdem ist dann $w_1$ die Wurzel von $T$.     \\  
\noindent\textbf{Fall 3: $bh(T_1) < bh(T_2)$ }\\ 
Dieser Fall ist fast symmetrisch zu Fall 2, jedoch kann der neue Knoten nicht zur Wurzel von $T$ werden, da $bh(T_1) \neq bh(T_2)$.
Es wird $T_1$ bei $T_2$, mit Hilfe von $k$ angefügt. Es sei $w_2$ die Wurzel von $T_2$. Es sei $P$ ein Pfad $(r_0,r_1,...,r_l)$ in $T_2$, so dass $r_0 = w_2$, $r_l$ ein Blatt ist und $\forall i \in \{1,2,...l\} \colon r_i$  ist linkes Kind von  $r_{i-1}$. $P$ ist also der am weitesten links liegende Pfad von der Wurzel zu einem Blatt. Sei $x$ der schwarze Knoten in $P$, mit $\mathit{bh}(x) = \mathit{bh}(w_1)$. $x$ muss existieren denn $\mathit{bh}(w_2) < \mathit{bh}(w_1)$ und $\mathit{bh}(r_l) \leq  \mathit{bh}(w_1)$, außerdem sind $w_2$ und $r_l$ schwarz. Nun wird ein neuer roter Knoten $v$ mit Schlüssel $k$ und Schwarz-Höhe $\mathit{bh}(x) + 1$ erzeugt. Als rechtes Kind von $v$  wird $x$ gesetzt, als linkes Kind $w_2$. $x$ ist linkes Kind eines Knoten $y$ und das linke Kind von $y$ wird auf $v$ gesetzt. $w_2$ ist die Wurzel von $T$. \\   
\paragraph{Resultat nach der Fallbehandlung}
Dass ein Baum mit Schlüsselmenge  $K_1 \cup K_2 \cup \{k\} $ entstanden ist, erkennt man direkt an den Abbildungen \ref{fig:vereinigen} und \ref{fig:vereinigen2}. Aufgrund der Vorbedingung an die Parameter, muss $T$ auch ein BST sein. Es müssen aber wieder die fünf Eigenschaften eines RBT betrachtet werden:
\begin{enumerate}
	\item Es ist immer noch jeder Knoten entweder rot oder schwarz.
	\item Gilt $bh(T_1) \neq bh(T_2)$ so wurde mit $w_1$ oder $w_2$ ein schwarzer Knoten zur Wurzel von $T$. Anderenfalls ist $v$ die rote Wurzel von $T$ und diese Eigenschaft ist verletzt.   
	\item Aufgrund der Sonderknoten sind die Blätter immer noch schwarz.
	\item Da $T_1$ und $T_2$ RBTs waren muss nur die Situation um $v$ betrachtet werden. $v$ hat in jedem Fall schwarze Kinder. Gilt $bh(T_1) \neq bh(T_2)$ könnte $v$ jedoch einen roten Elternknoten $y$ haben. 
	\item Die Schwarz-Höhe von $v$ ist korrekt gesetzt. Existiert $y$ so hat sich seine Schwarz-Höhe nicht verändert, denn $v$ ist rot. Bei keinem anderen Knoten hat sich bezüglich bzgl. der Schwarz-Höhe etwas geändert. 
\end{enumerate} 
Wir sind also in der Situation dass nur entweder Eigenschaft zwei oder vier verletzt sein kann. Wenn Eigenschaft vier verletzt ist dann nur an Knoten $v$. Das ist genau die Situation für die \textit{insertFixup} entworfen wurde.\\
In Schritt zwei wird also \textit{insertFixup} mit Parameter $v$ aufgerufen und die Wurzel des resultierenden RBT zurückgegeben. 
\paragraph{Laufzeit}
Sei $n_1$ die Anzahl der Knoten von $T_1$, sei $n_2$ die Anzahl der Knoten von $T_2$ und $n = n_1 + n_2$. Der Tango-Baum fordert von seiner Hilfsstruktur eine Laufzeit von $O(\log n)$ für die eben vorgestellte Operation.  Das Ablaufen eines Pfades in $T_1$ oder $T_2$ zum Finden von $x$ liegt in $O(\log (n))$. $v$ erzeugen und in die Struktur einzubinden benötigt konstante Zeit und \textit{insertFixup} benötigt  $O(\log (n))$ Zeit.\\
$O(\log (n)) + O(1) +O(\log (n)) = O(\log (n
))$\\
Die Vorgabe des Tango-Baumes wird also eingehalten.\\
Für das nächste Kapitel wird noch eine genauere Betrachtung der Laufzeit benötigt. Es sei $d = \vert \mathit{bh}(T_1) - \mathit{bh}(T_2)  \vert $. Die Suche nach $x$ endet spätestens nach dem ein Pfad der Länge $2d + 1$ betrachtet wurde. Dabei steht die $1$ für den Zugriff auf $x$ selbst. Zu jedem schwarzen Knoten über $x$ könnte noch ein roter kommen.\\
Nun wird noch auf die Anzahl der Iterationen innerhalb von \textit{insertFixup} eingegangen. Sei $v$ der Parameter von \textit{insertFixup}. Sei $w$ die Wurzel von $T$. $v$ ist ein roter Knoten mit $\mathit{bh}(v) = \mathit{bh}(w) - d + 1$ und liegt in Ebene $2d + 2$ oder höher. Deshalb führt \textit{insertFixup} maximal $d + 1$ Iterationen durch.  

\subsection{Tango-Baum konformes aufteilen}
Auch \textit{split (RBT $T$, key $k$)} wird so vorgestellt, wie es als Hilfsstruktur für einen Tango-Baum benötigt wird. Vorbedingung an die Parameter ist, dass $k$ in der Schlüsselmenge $K$ von $T$ vorhanden ist. Zurückgegeben wird eine Referenz auf den Knoten $v_k$ mit Schlüssel $k$. Linkes Kind von $v_k$ ist die Wurzel eines RBT $T_L$ mit Schlüsselmenge $K_L$, wobei gilt ${K_L=\{i \mid  i\in K \land i <k\}}$. Rechtes Kind von $v$ ist die Wurzel eines RBT $T_2$ mit Schlüsselmenge $K_R$, wobei gilt ${K_R = \{i \mid i\in K \land i > k\}}$. \textit{split} gibt also in den meisten Fällen keinen RBT zurück. Die Operation setzt zunächst $T_L$ auf den linken Teilbaum von $v$ und $T_R$ auf den rechten Teilbaum von $v_k$. Eventuell müssen die Wurzeln schwarz gefärbt werden. Sei $(v_0,v_1,..,v_m)$  der Pfad von der Wurzel von $T$ zu $v_k$. Es wird sich nun bei $v_m$ startend Knoten für Knoten in dem Pfad nach oben gearbeitet. Ist der Schlüssel eines Knotens kleiner als $k$, so wird dieser Schlüssel und der linke Teilbaum des Knotens zu $T_L$ hinzugefügt. Dies übernimmt unsere \textit{vereinigen} Operation. Ist der Schlüssel größer als $k$, so wird dieser Schlüssel und der rechte Teilbaum des Knotens zu $T_R$ hinzugefügt. Folgende Aufzählung beschreibt den Vorgang genauer.

\begin{enumerate}
	\item Verwende die \textit{search} Operation um den Knoten $v_k$ mit Schlüssel $k$ zu finden.
	\item Setze den linken Teilbaum von $v_k$ als $T_L$, den rechten als $T_R$. Löse beide Teilbäume aus $T$ heraus.
	\item Färbe die Wurzeln von $T_L$ und $T_R$ schwarz.
	\item $\forall i \in \{1,2,..,m\}$ absteigend sortiert. Ist der Schlüssel $k_i$ von $v_i$ kleiner als $k$, vereinige $T_L$ mit dem aus $T$ herausgelösten linken Teilbaum von $v_i$, mit  $k_i$ als dritten Parameter. Ansonsten vereinige $T_R$ mit dem aus $T$ herausgelösten rechten Teilbaum von $v_i$, mit  $k_i$ als dritten Parameter. Evtl. muss die Wurzel des herausgelösten Teilbaumes vor dem vereinigen schwarz gefärbt werden. 
	\item Füge $T_R$ rechts an $v$ an, $T_L$ links.
	\item Gib $v_k$ zurück.
\end{enumerate}   
Das $T_L$ und $T_R$ die gewünschten RBTs sind wird leicht erkannt. $v_0$ und einer der beiden Teilbäume wird korrekt zugeordnet. Die Wurzel des anderen Teilbaumes von $v_0$ ist $v_{1}$. Alle Schlüssel die nicht im Teilbaum mit Wurzel $v_{1}$ liegen sind somit korrekt zugeordnet. Diese Betrachtung iteriert bis man auf $v_k$ trifft. Die Schlüssel im Teilbaum mit Wurzel $v_k$ werden korrekt zugeordnet. 

\paragraph{Laufzeit}
Der Tango-Baum fordert eine Laufzeit von $O(\log(n))$ von seiner Hilfsstruktur für \textit{split}, mit $n$ ist die Anzahl der Knoten. Punkt 1 kostet $O(\log(n))$. Durchführen von Punkt 2,3,5 und 6 kostet $O(1)$. Punkt 4 führt $O(\log (n))$ Aufrufe von \textit{concatenate} durch. Das ergibt $O(\log (n) \log (n))$, was dann auch eine obere Schranke für die Gesamtlaufzeit ist. Diese Schranke ist für unseren Einsatzzweck jedoch zu hoch.\\ Deshalb wird Punkt 4 nun genauer betrachtet, speziell die Konstruktion von $T_L$. Es sei $l$ die Anzahl der Aufrufe von \textit{concatenate} nach denen $T_L$ neu gesetzt wird. Sei $\{t_1,t_2,..,t_l\}$ die Menge der aus $T$ herausgelösten Teilbäume die für die $l$ Aufrufe verwendet wurden, wobei $t_1$ zum ersten Aufruf gehört, $t_2$ zum zweiten usw.. Mit $T_{Li}$ wird der Zustand von $T_L$ bezeichnet nach dem $t_i$ Parameter von \textit{concatenate} war.  $T_{L0}$ steht für den Zustand vor dem ersten Aufruf.\\


\noindent Dass die zweite Ungleichung gilt, erkennt man direkt. 
\begin{align}
\mathit{bh}(T_{Li}) \leq \mathit{bh}(v_{i+1}) \leq\mathit{bh}(t_{i+1}) + 1  
\end{align}
Die Erste wird nun durch Induktion gezeigt:\\
$T_{L0}$ war der linke Teilbaum von $v_1$, der Induktionsanfang ist somit gemacht.\\
$\mathit{bh}(T_{Li})$ mit $i > 0$  entsteht durch \textit{concatenate($T_{Li-1}$, \textit{key}$\left(v_i\right)$, $t_i$)}.\\ 
Fall $v_i$ ist rot:
\begin{align*}
&\mathit{bh}(t_i) < \mathit{bh}(v_i)  \land  \mathit{bh}(T_{Li-1})  \overset{\textit{IA}}{\leq}  \mathit{bh}(v_{i}) \\
\Rightarrow  & \mathit{bh}(T_{Li})  \leq  \mathit{bh}(v_{i}) \leq  \mathit{bh}(v_{i+1}) 
\end{align*}
Fall $v_i$ ist schwarz:
\begin{align*}
&\mathit{bh}(t_i) \leq \mathit{bh}(v_i)  \land  \mathit{bh}(T_{Li-1})  \overset{\textit{IA}}{\leq}  \mathit{bh}(v_{i}) \\
\Rightarrow  &\mathit{bh}(T_{Li})  \leq \mathit{bh}(v_{i}) + 1 =    \mathit{bh}(v_{i+1})
\end{align*}
Dadurch gilt
\begin{align}
\sum_{i = 1}^{l} \vert\mathit{bh} \left(t_{i} \right) -\mathit{bh} \left(T_{Li-1} \right) \vert =  O \left(\log \left(n \right) \right)
\end{align}
denn
\begin{align*}
&\sum_{i = 1}^{l} \vert\mathit{bh} \left(t_{i} \right) -\mathit{bh} \left(T_{Li-1} \right) \vert \overset{\textit{1}}{\leq}
\sum_{i = 1}^{l} \left( \mathit{bh} \left(t_{i} \right) -\mathit{bh} \left(T_{Li-1} \right) + 2\right)\\
\leq &\sum_{i = 1}^{l} \left( \mathit{bh} \left(t_{i} \right) -\mathit{bh} \left(t_{i-1} \right) + 2\right)
=  \mathit{bh} \left(t_{l} \right) -\mathit{bh} \left(t_{0} \right) + 2 \cdot l  = O \left(\log \left(n \right) \right)
\end{align*}

\noindent Der Gesamtaufwand für das Suchen von $v$ in allen $l$ Aufrufen berechnet sich mit: 
\begin{align*}
\sum_{i = 1}^{l}  2 \vert\mathit{bh}(t_{i}) -\mathit{bh}(T_{Li-1}) \vert + 1 =
2 \left( \sum_{i = 1}^{l}   \vert\mathit{bh}(t_{i}) -\mathit{bh}(T_{Li-1}) \vert \right)+ l
= O \left(\log \left(n \right) \right)
\end{align*}
\noindent Für die Anzahl der Iterationen von \textit{insertFixup} in allen $l$ Aufrufen gilt: 
\begin{align*}
\sum_{i = 1}^{l}   \vert\mathit{bh}(t_{i}) -\mathit{bh}(T_{Li-1}) \vert +1 =
\sum_{i = 1}^{l}  \left( \vert\mathit{bh}(t_{i}) -\mathit{bh}(T_{Li-1}) \vert \right) + l 
= O \left(\log \left(n \right) \right)
\end{align*}
Die Kosten innerhalb einer Iteration sind konstant, damit ist  $O \left(\log \left(n \right) \right)$ eine ober Schranke für die Gesamtkosten zum konstruieren von $T_L$. Für $T_R$ gilt analog das Gleiche. Für die Gesamtkosten von \textit{concatenate} innerhalb \textit{split} gilt $O \left(\log \left(n \right) \right)$, denn neben den Kosten für die Suche und \textit{insertFixup} fallen pro Aufruf lediglich konstante Kosten an. Damit ist $O \left(\log \left(n \right) \right)$ eine obere Schranke für die Kosten von Punkt 4 und somit auch für \textit{split}. Der hier vorgestellte RBT hält also die Anforderung des Tango-Baumes bezüglich der Laufzeit von \textit{split} ein.







\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{"Medien/RotSchwarzBaum/aufteilen"}
	\caption{Beispielhaftes \textit{split} eines RBT mit Parameter $v$ }
	\label{fig:aufteilen}
\end{figure}

\section {Zipper Baum}
Der Zipper Baum basiert auf dem Tango Baum und nutzt auch preferred paths aus einem Referenzbaum $P$. Aufbau und Pflege der preferred paths in $P$ unterscheiden sich nicht vom Tango Baum, wohl aber ihre Repräsentation im eigentlichen BST $T$. Der Zipper Baum wurde in \cite{zipper} vorgestellt. Er ist ebenfalls $\log\left(\log\left(n\right)\right)$-competitive,  garantiert aber auch  $O\left(\log \left(n\right)\right)$ im worst case, bei einer einzelnen \textit{access} Operation. $n$ steht wieder für de Anzahl der Knoten von $T$. Das Verhalten der Operationen \textit{cut} und \textit{join} unterscheidet sich deutlich. Da die Operationen des Zipper Baumes recht aufwendig sind, werden sie hier wie in \cite{zipper} in zwei Schritten vorgestellt. Zunächst an einem Hybrid Baum, der kein  BST ist und dann am eigentlichen Zipper Baum. Die Knoten im Zipper Baum sind wie beim Tango Baum erweitert. Beim Hybrid Baum kommt ein zusätzlicher Zeiger auf einen Knoten hinzu.  Sei $v$ ein Knoten in $T$, dann ist in diesem Kapitel $v^*$ der Knoten in $P$, mit $\mathit{key}\left(v\right) = \mathit{key}\left(v^*\right)$.

\subsection{Hybrid Baum}
Znächst wird die Repräsentation eines preferred path in $T$ vorgestellt. Dann wird die \textit{access} Operationen, mit ihren Hilfsoperationen vorgestellt. Zum Schluss geht es noch um die Laufzeit. 


\subsubsection{Repräsentation eines preferred path beim Hybrid Baum} 
Die Repräsentation eines preferred path  $P_p = \left({p_1}^*,{p_2}^*,..,{p_m}^*\right)$ in $T$ stellt einen Hilfsbaum $H$ dar, der in zwei Teile unterteilt wird, den  \textbf{top path} und den \textbf{bottom tree}. Der bottom tree ist ein balancierter BST der genau die Schlüssel enthält, die in $P_p$ enthalten sind jedoch nicht im top path.  Der top path enthält $n_1 \in \left[\log\left(\log\left(n\right)\right), 3 \log\left(\log\left(n\right)\right) \right]$ Knoten falls ein bottom tree existiert, ansonsten  $n_1 \in \left[1, 3 \log\left(\log\left(n\right)\right) \right]$. Der top path besteht aus den Knoten $\left({p_1},{p_2},..,{p_{n_1}}\right)$ und stellt eine eins zu eins Repräsentation von $ \left({p_1}^*,{p_2}^*,..,p_{n_1}^*\right)$ dar. ${p_1}$ ist die Wurzel von $H$. Die Wurzel des bottom tree ist ein Kind von ${p_{n_1}}$. Abbildung \ref{fig:pathRepresentation} zeigt eine mögliche Darstellung zu dem preferred path in Abbildung \ref{fig:preferredPath}. Jeder Knoten in $H$ kann in $O\left(\log\left(\log \left(n\right)\right)\right)$ Zeit erreicht werden. Die Repräsentationen der preferred paths werden wie beim Tango Baum zu einer Gesamtstruktur entsprechend ihrer Schlüssel zusammengefügt. 

\begin{figure}[h]
	\centering
	\includegraphics[height= 0.5\textwidth]{"Medien/Zipper/preferredPath"}
	\caption{Beispiel preferred path }
	\label{fig:preferredPath}
\end{figure} 
\begin{figure}[h]
	\centering
	\includegraphics[height= 0.5\textwidth]{"Medien/Zipper/hybrid/pathRepresentation"}
	\caption{Mögliche Repräsentation des preferred path aus \ref{fig:preferredPath}. Grün der top path, blau der bottom tree. }
	\label{fig:pathRepresentation}
\end{figure} 


\subsubsection{Die \textit{access} Operation beim Hybrid Baum}
Sei $p$ der Zeiger der \textit{access}$\left(k\right)$ Operation in $T$. Erreicht $p$ während des Suchens in einem Hilfsbaum $H_1$ die Wurzel eines weiteren Hilfsbaum $H_2$, werden die Knoten von $H_1$, entsprechend ihrer \textit{depth} Variable, vergleichbar mit dem Tango Baum,  mit einer \textit{cut} Operation in zwei Bäume $D_1$ und $D_2$ aufgeteilt. Sei $D_2$ der Baum, bei dem die Werte der \textit{depth} Variablen die größeren Werte annehmen. $D_2$ wird sofort in eine gültige Pfadrepräsentation überführt, wie genau wird in \textit{cut} beschrieben. Die Knoten in $D_1$ werden nach der Ausführung von \textit{access} im Hilfsbaum mit der Wurzel von $T$ enthalten sein. Dieser wird mit \textit{join} erst erstellt, wenn der Knoten mit Schlüssel $k$ gefunden ist. $D_1$ bleibt also zunächst unverändert bestehen.       

\paragraph{\textit{cut} beim Hybrid Baum}
Es werden zwei Fälle unterschieden. Beim ersten Fall zeigte $p$ in $H_1$ nur auf Knoten im top path $\left(p_1,p_2,..,p_m\right)$ im zweiten Fall erreichte $p$ den bottom tree. Es wird davon ausgegangen dass in $H_1$ ein bottom tree enthalten ist, der andere Fall ist einfacher und ergibt sich aus der Beschreibung.\\
Fall 1:\\
Sei $q_i$ der Elternknoten der Wurzel von $H_2$, dann muss eine Laufzeit von $O\left(i\right)$ erreicht werden.  $q_{i+1}$ wird zur Wurzel von $H_1$. Es muss sichergestellt werden, dass die Anzahl der Knoten im top path von $H_1$ noch groß genug ist. Enthält er weniger als $2 \log\left(\log\left(n\right)\right)$ Knoten werden mit einem \textbf{Extraktionsprozess} Knoten aus dem bottom tree dem top path hinzugefügt. Dazu wird eine \textit{extract} Operation verwendet. Eine solche Operation fügt dem top path $\log\left(\log\left(n\right)\right)$ Knoten aus dem bottom tree hinzu. Um die Laufzeit einhalten zu können verteilt {\textit{extract}} dies über mehrere \textit{cut} Operationen. Dazu wird der bottom tree in einen Zwischenzustand versetzt, der keinem balancierten BST entspricht. Ein Hilfsbaum bei dem kein Extraktionsprozess aktiv ist hat  $2 \log\left(\log\left(n\right)\right)$ Knoten im top path. Der Extraktionsprozess wird im Abschnitt zu \textit{extract} beschrieben.  \\
Fall 2:\\
Es muss eine Laufzeit von $O\log\left(\log\left(n\right)\right)$ erreicht werden.Dieser Fall ist sehr ähnlich zum Tango Baum und es werden die Operationen von ihm verwendet. Sei \textit{tangoJoin} die \textit{join} Operation wie im Kapitel zum Tango Baum beschrieben und \textit{tangoCut} die \textit{cut} Operation von dort. Sei $v$ der Vater der Wurzel von $H_2$. Ist in $H_1$ ein Extraktionsprozess aktiv, muss dieser beendet werden und der top path muss in einen balancierten Baum $H_3$ überführt werden. Nun werden $H_3$ und der bottom tree mit \textit{tangoJoin}  zu $H_4$ vereinigt. Dann wird \textit{tangoCut} verwendet um die Knoten mit einem Wert der \textit{depth} Variable größer $v.$\textit{depth} aus in einen Hilfsbaum $H_5$ auszulagern. Auf $H_5$ werden zwei Extraktionsprozess ausgeführt um eine gültige Pfadrepräsentation zu erreichen.  \\
Im ersten Fall entstehen Kosten von $O\left(i\right)$ um $q_i$ zu erreichen, und dass auch in \textit{extract} Kosten von $O\left(i\right)$ entstehen wird weiter unten gezeigt. Im zweiten Fall entstehen Kosten von $O\left(\log\left(\log\left(n\right)\right)\right)$ sowohl um $v$ zu erreichen, um $H_4$ zu erzeugen (siehe \textit{join}) als auch in \textit{extract}.


\paragraph{\textit{join} beim Hybrid Baum}
\textit{join} wird verwendet um zum Abschluss von \textit{access} den Hilfsbaum $H$ mit der Wurzel von $T$ zu erstellen. Seien $H_1,H_2,..,H_m$ die Bäume die zu $H$ vereinigt werden, so dass für $i \in \{1,2,..m\}$ und $i > 1$, in $H_{i-1}$ ist der Vater der Wurzel von $H_i$ enthalten gilt. Abbildung \ref{fig:concatPfad} zeigt eine beispielhafte Konstellation. Zunächst werden die Bäume $H_1,H_2,..,H_m$ zu balancierten Bäumen $H_1',H_2',..,H_m'$ transformiert. Diese werden dann mit einer Folge von $m-1$ \textit{tangoJoin} Operationen zu $H$ zusammengefügt. Als erstes werden $H_1'$ und $H_2'$ zusammengefügt. Zu dem neu entstandenen Hilfsbaum wird dann $H_3'$ hinzugefügt usw.  Um $H$ zu erstellen werden dann noch $2\log\left(\log\left(n\right)\right)$ Knoten zu einem top path extrahiert. Abbildung \ref{fig:concatHybrid} zeigt den Ablauf für das Beispiel.\\
Um $H_i$ zu $H_i'$ zu überführen werden die Knoten in seinem top path als Bäume mit einem Knoten betrachtet. Diese werden mit Folgen von  \textit{tangoJoin} zusammengefügt. In jeder solchen Folge wird die Anzahl der Bäume halbiert, indem zwei aufeinanderfolgende Bäume jeweils zusammengeführt werden. Nach jeder \textit{tangoJoin} Folge halbiert sich die Anzahl der aus dem top path entstandenen Bäume und die Anzahl ihrer Knoten verdoppelt sich. Sei $n_i$ die Anzahl der Knoten im top path von $H_i$, dann summieren sich die Kosten über alle Folgen zu $O\left(\sum_{j = 1}^{\log n_i} j n_i / 2^j\right) = O\left(n_i\right)$. Diese Kosten sind bereits während des Suchens in $H_i$ entstanden und können deshalb vernachlässigt werden. Nach der Ausführung dieser \textit{tangoJoin} Folgen existiert ein aus dem top path entstandener balancierter BST und eventuell ein bottom tree. Diese werden mit einer weiteren \textit{tangoJoin} Operation zusammengeführt. Die Kosten für diese Operation betragen $O\left(\log\left(\log\left(n\right)\right)\right)$ und sind bereits beim Suchen im bottom tree von $H_i$ angefallen. Die Gesamtkosten zum erstellen von $H_i$ können also asymptotisch betrachtet vernachlässigt werden. \\
Die Kosten um $H$ aus  $H_1',H_2',..,H_m'$ zu bilden, sind analog zum Tango Baum. Für den Extraktionsprozess entstehen nochmals Kosten von $O\left(\log\left(\log\left(n\right)\right)\right)$.

\begin{figure}[h]
	\centering
	\includegraphics[height= 0.5\textwidth]{"Medien/Zipper/hybrid/concatPfad"}
	\caption{Mögliche Ausgangsituation vor \textit{concatenate}.}
	\label{fig:concatPfad}
\end{figure} 
\begin{figure}[h]
	\centering
	\includegraphics[height= 0.5\textwidth]{"Medien/Zipper/hybrid/concatHybrid"}
	\caption{Es werden zwei  \textit{concatenate} Operationen benötigt. Oben das Ergebnis der Ersten, unten dass der Zweiten }
	\label{fig:concatHybrid}
\end{figure} 
\paragraph{\textit{extract} beim Hybrid Baum} \label{hybridExtract}
Wie bereits erwähnt wird diese Operation benötigt um einen Extraktionsprozess durchzuführen. Ein Extraktionsprozess fügt dem top path $\log\left(\log n\right)$ Knoten hinzu. Er wird gestartet wenn der top path aufgrund einer \textit{cut} Operation, weniger als $2\log\left(\log n\right)$ enthält, oder zum Ende der \textit{join} Operation. Damit die Laufzeit von \textit{cut} eingehalten werden kann, erstreckt sich ein Extraktionsprozess über mehrere \textit{cut} Operationen, mit Fall 1. Ein Extraktionsprozess wird mit einer Folge von $O\left(\log\left(\log n\right)\right)$ Rotationen ausgeführt. Um die Invariante bezüglich der top path Länge einzuhalten, darf ein Extraktionsprozess auf so viele \textit{cut} Operationen verteilt werden, bis mehr als $\log\left(\log n\right)$ Knoten vom top path entfernt wurden. Der Hybrid Baum macht, mit einer Konstante,  die Anzahl der durchgeführten Rotationen nach einem \textit{cut} 1. Fall, von der Anzahl der abgespaltenen Knoten abhängig. So dass der  Extraktionsprozess spätestens dann abgeschlossen wird, wenn $\log\left(\log n\right)$ Knoten durch \textit{cut} entfernt wurden. Kommt es zu einer \textit{cut} Operationen, mit Fall 2 wird ein aktiver Extraktionsprozess abgebrochen. 
Von den Hilfsbäumen wird eine \textit{split} Operation wie vom Hilfsbaum des Tango Baumes verlangt. Diese darf jedoch nur Rotationen verwenden. Für den Rot Schwarz Baum ist eine solche Variante in \cite{zipper} dargestellt. 
Sei $H$ eine Repräsentation des preferred path $P_p = {v_1}^*,{v_2}^*,..,{v_m}^*$ und $i \in \{1, 2,..,m\}$. Sei $n_1 = \log_2\left(\log_2\left(n\right)\right)$. Sei $v_i$ der Elternknoten der Wurzel des bottom tree, mit $d = v_i.$\textit{depth}. Es müssen der Reihe nach die Knoten mit \textit{depth} Wert $d+1, d+2,..,d + n_1$ extrahiert werden, damit ein valider top path entsteht. 
$P_p$ wird in \textbf{zig Segmente} und \textbf{zag Segmente} unterteilt.  zig Segmente entsprechen den längst möglichen Pfaden von Knoten mit rechten Kindern in $P_p$. zag Segmente entsprechen den längst möglichen Pfaden von Knoten mit linken Kindern in $P_p$. Das Blatt in $P_p$ wird dem Segment seines Vaters zugeordnet. In Abbildung  \ref{fig:preferredPathZigZag} sind zig und zag Segmente dargestellt.  Sei $S_{zig}$ die Folge der in zig Segmenten enthalten Knoten, aufsteigend sortiert nach der Tiefe und $S_{zag}$ die Folge der in zag Segmenten enthalten Knoten, aufsteigend sortiert nach der Tiefe der enthaltenen Knoten. Ist $u^*$ der tiefste Knoten eines zig bzw. zag Segmentes, so können in den Segmenten mit Knoten größerer Tiefe nur noch größere bzw. kleinere Schlüssel enthalten sein, vergleiche Abbildung \ref{fig:preferredPathZigZag}. Deshalb müssen die Knoten in $S_1 \circ S_2$ aufsteigend sortiert nach Schlüssel sein. Da die Knoten in $S_{zig}$ bzw. $S_{zag}$ aber auch aufsteigend bzw. absteigend nach Tiefe sortiert sind, können aus $S_{zig} \circ S_{zag}$ Intervalle $\left[l, r\right]$ für die Schlüsselmengen, von Pfaden in $P_p$ mit Endknoten ${p_m}^*$ abgeleitet werden, siehe Abbildung \ref{fig:preferredPathZigZag}, wobei $l$ in $S_{zig}$ enthalten sein muss und $r$ in $S_{zag}$.  Sei $\left[l,r\right]$ ein so erstelltes Intervall zu dem Pfad von ${v_{i + {n_1} + 1}}^*$ zu ${p_m}^*$. Es müssen genau die Knoten im bottom tree zum extrahieren vorbereitet werden, deren Schlüssel nicht in $\left[l, r\right]$ liegt. Der Knoten mit Schlüssel $l$ sowie dessen Vorgänger $v_l$ sowie der Knoten mit Schlüssel $r$ und dessen Nachfolger $v_r$ werden gefunden wie in Abschnitt \ref{TangoAbschnitt} gezeigt. Sei $l'$ der Schlüssel von $v_l$ und $r'$ der Schlüssel von $v_r$. Mit zwei \textit{split} Operationen werden die Knoten $v_l$ und $v_r$ herausgelöst. Das linke Kind von $v_l$ ist ein balancierter BST $B$, der alle Schlüssel aus $H$ enthält die kleiner als $l$ sind. Das rechte Kind von $v_l$ ist $v_r$. Das linke Kind von $v_r$ ist ein balancierter BST $D$, der alle Schlüssel aus $H$ enthält die in $\left[l, r\right]$ enthalten sind.  Das rechte  Kind von $v_r$ ist ein balancierter BST $E$, der alle Schlüssel aus $H$ enthält die größer als $r$ sind. Es werden also genau die Knoten aus $B$ und $E$ vorbereitet. Schritt zwei in Abbildung \ref{fig:extractHybrid} ist damit bereits vollzogen. In Schritt drei werden $B$ und $E$ nun zu BST in Listendarstellung gewandelt. Sei $B'$ bzw. $E'$ der Baum der dadurch von $B$ bzw. $E$ entsteht. Es wird $B'$ betrachtet, $E'$ ist dazu symmetrisch.  Die Wurzel von $B'$ enthält den größten Schlüssel in $B'$, somit sind alle anderen Knoten in $B'$ linke Kinder. Die Umwandlung geschieht wie folgt:\\
Es werden so oft Linksrotationen auf das rechte Kind der Wurzel ausgeführt, bis der rechte Teilbaum der Wurzel leer ist. In Schritt zwei wird der rechte Teilbaum des linken Kindes der Wurzel auf die gleiche Art und Weise geleert und dann wird eine Rechtsrotation auf das linke Kind der Wurzel ausgeführt. Schritt zwei wird so oft wiederholt bis $B'$ erzeugt ist. Abbildung \ref{fig:listeHybrid} stellt diesen Vorgang dar. Da $l$ der Schlüssel eines Knoten in $S_{zig}$ ist, müssen alle Schlüssel aus $B'$ auch als Schlüssel von Knoten in $S_{zig}$ enthalten sein. $S_{zig}$ ist aufsteigend nach den Schlüsseln als auch nach den Tiefen sortiert, somit müssen dies auch die Knoten in $B'$ sein. Das bedeutet für einen Knoten $v$ aus $B'$, dass alle Knoten in seinem rechten Teilbaum einen größeren Wert bei der \textit{depth} Variable haben als $v.$\textit{depth}. Für  $v$ aus $E'$ gilt für den linken Teilbaum das gleiche. Aus den gleichen Gründen muss $v_l.$\textit{depth} bzw. $v_r.$\textit{depth} einen größeren Wert haben, als die \textit{depth} Variablen aller Knoten in $B'$ bzw. $E'$. $v_l$, $v_r$ sowie die Knoten aus $B'$ und $E'$ sind nun zum extrahieren vorbereitet. Sei $u$ die Wurzel von $B'$ oder $E'$, je nachdem bei welchem Knoten die \textit{depth} Variable einen kleineren Wert hat. Dann kann $u$ mit maximal zwei Rotationen den top path hinzugefügt werden. Sind $B'$ und  $E'$ erschöpft und auch $v_r$ und $v_l$ dem top path hinzugefügt, ist der Vorgang beendet.\\
Muss ein Extraktionsprozess aufgrund \textit{cut} Fall 2 vorzeitig abgebrochen werden, werden aus $B'$ und $E'$ wieder balancierte BST erzeugt, analog zu der Beschreibung in \textit{join}. Im Anschluss wird mit zwei \textit{tangoJoin} Operationen wieder ein bottom tree erstellt.\\
Um die Laufzeit von \textit{cut} einhalten zu können, werden die Knoten im Hybrid Tree um einen weiteren Zeiger erweitert. Ist in einem Hilfsbaum $H$ mit Wurzel $w$ ein Extraktionsprozess aktiv, zeigt der zusätzliche Zeiger in $w$, auf den Knoten, auf dem die nächste Rotation ausgeführt wird. Da $p$ nach dem extrahieren von Knoten, nochmals auf $w$ zeigen muss, bevor er auf einen Knoten außerhalb von $H$ zeigt, kann dieser Knoten einfach gepflegt werden. Aufgrund dieses Zeigers ist der Hybrid Baum jedoch kein BST.\\
Bei Schritt eins und zwei entstehen Kosten von $O\left(\log \left(\log n\right)\right)$, vergleichbar mit Kapitel \ref{TangoAbschnitt}. Beim erstellen von $B'$ aus $B$ ist jeder Knoten an maximal drei Rotationen beteiligt, vergleiche Abbildung \ref{fig:listeHybrid}. Da maximal  $\log\left(\log n\right)$ Knoten vorbereitet werden, entstehen Kosten von  $O\left(\log\left(\log n\right)\right)$. Bei Schritt vier kommen noch einmal Kosten von $O\left(\log\left(\log n\right)\right)$ hinzu.
Werden mit einem verkürzten Ablauf $k$ bereits vorbereitete Knoten dem top path hinzugefügt, entstehen mit Hilfe des zusätzlichen Zeigers Kosten von $O\left(k\right)$.   
\begin{figure}[h]
	\centering
	\includegraphics[width= 0.8\textwidth]{"Medien/Zipper/hybrid/extractHybrid"}
	\caption{Es wird ein Extraktionsprozess dargestellt. Die Abbildung basiert auf einer in \cite{zipper} }
	\label{fig:extractHybrid}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width= 0.8\textwidth]{"Medien/Zipper/hybrid/listeHybrid"}
	\caption{Beispielhaftes überführen von $B$ zu $B'$. }
	\label{fig:listeHybrid}
\end{figure}
\subsubsection{Laufzeitanalyse beim Hybrid Baum}
Zunächst wird ein Lemma benötigt.
\begin{Lemma} \label{hybridBalanced}
	Sei $T$ ein Hybrid Baum mit $n$ Knoten und $P$ ein dazu erstellter Referenzbaum. Sei $v$ ein Knoten aus $T$ , dann gilt $\mathit{depth}\left(v\right) = O\left(\mathit{depth\left(v^*\right)}\right)$.
\end{Lemma}
\begin{proof}
	Seien $P_1, P_2,.., P_m$ die preferred path, die Knoten aus dem Pfad $P_{v^*}$ von der Wurzel von $P$ zu $v^*$ enthalten. Jeder von ihnen wird nun als BST betrachtet. Für $i \in \{1, 2,..,m\}$ sei $H_i$ die Pfadrepräsentation zu $P_i$. Sei ${p_i}^*$ der Knoten in $P_i$ mit der größten Tiefe unter den in $P_{v^*}$  enthaltenen. Sei $H_i$ der Hilfsbaum der $P_i$ repräsentiert. Die folgenden Tiefenangaben werden auf $P_i$ bzw. $H_i$ bezogen. Ist $p_i$ im top path enthalten, haben $p_i$ und ${p_i}^*$ die gleiche Tiefe. Liegt $p_i$ im bottom tree so muss $\mathit{depth}\left({p_i}^*\right) > \log\left(\log n\right)$ gelten, aufgrund der Konstruktion von $H_i$. Für die Tiefe jedes Knoten in $H_i$ gilt $O\left(\log\left(\log n\right)\right)$    
	
\end{proof}
\noindent Daraus ergibt sich sofort für die Höhe eines Hybrid Baum mit $n$ Knoten sofort $O\left(\log n\right)$. \\
In \textit{access} entstehen, pro preferred path mit $k$ involvierten Knoten, Kosten von $O\left(k\right)$ wenn $k < \log_2\left(\log_2\left(n\right)\right)$ gilt und Kosten von $O\left(\log_2\left(\log_2 n\right)\right)$  wenn $k \geq \log\left(\log\left(n\right)\right)$ gilt. Mit dem Lemma gilt deshalb für die Kosten von \textit{access} $O\left(\log\left(n\right)\right)$. Da pro \textit{cut} Operation maximal Kosten von $O\left(\log\left(\log\left(n\right)\right)\right)$ entstehen, muss mit den Ausführungen zu \textit{join}, der Hybrid Baum genau wie der Tango Baum $\log \left(\log\left(n\right)\right)$-competitive sein.


\subsection{Repräsentation eines preferred path beim Zipper Baum}
Ziel der Repräsentation eins preferred path $P_p = \left({p_1}^*,{p_2}^*,..,{p_m}^*\right)$ ist es ohne den zusätzlichen Zeiger in den Knoten auszukommen, ohne Einschränkung bei asymptotischen Laufzeiten. Dies wird dadurch erreicht, dass der Knoten auf den in einem Extraktionsprozess die nächste Rotation ausgeführt werden muss, immer in konstanter Zeit von der Wurzel seines Hilfsbaumes $H$ aus zugegriffen werden kann.\\
$H$ enthält auch einen bottom tree. Die Knoten im top path werden jedoch zu einem \textbf{zipper} angeordnet. Dieser besteht aus zwei Teilen, dem \textbf{top zipper} $z_t$ und de, \textbf{bottom zipper} $z_b$. $z_t$ und $z_b$ dürfen jeweils maximal $\log_2\left(\log_2\left(n\right)\right)$ Knoten enthalten, gemeinsam müssen sie zumindest $\log_2\left(\log_2\left(n\right)\right) / 2$ Knoten enthalten. Es wird wieder angenommen, dass ein bottom tree existiert. Sei $n_t$ bzw. $n_b$ die Anzahl der Knoten von $z_t$ bzw. $z_b$. $z_t$ repräsentiert Knoten  $P_t = \left({p_1}^*,{p_2}^*,..,{p_{n_t}}^*\right)$ und $z_b$ die Knoten  $P_b =\left( {p_{n_t + 1}}^*,{p_{n_t + 2}}^*,..,{p_{n_t + n_b}}^*\right)$. \\
$z_t$ ist wie folgt aufgebaut:\\
Sei $S_{zig}$ und $S_{zag}$ zu $P_t$ definiert wie in Abschnitt \ref{hybridExtract}.
Sei $t_l$ bzw. $t_r$ der Knoten in $S_{zig}$ bzw. $S_{zag}$ mit der kleinsten Tiefe. $t_l$ ist die Wurzel von $H$. $t_r$ ist das rechte Kind von $t_l$. Der linke Teilbaum von $t_l$  hat Listenform und  wird von den restlichen Knoten in $S_{zig}$ gebildet, so dass kein Knoten in diesem Teilbaum ein linkes Kind hat. Der rechte Teilbaum von $t_r$  hat Listenform und  wird von den restlichen Knoten in $S_{zag}$ gebildet, so dass kein Knoten in diesem Teilbaum ein rechtes Kind hat. \\
$z_b$ wird analog aus $P_b$ erzeugt und seien $b_l$ und $b_r$ die Knoten in $z_b$ entsprechend zu $t_l$ und $t_r$ in $z_t$. $b_l$ ist das linke Kind von $t_r$. Die Wurzel des bottom Tree ist das linke Kind von $t_r$. Das die Links-Rechts-Beziehung eingehalten wird ergibt aus den Aufbau der zig und zag Segmente und die Wurzel des bottom tree ist in konstanter Zeit erreichbar. Abbildung \ref{zipperPathRep} zeigt eine beispielhafte Darstellung. 

\begin{figure}[h]
	\centering
	\includegraphics[width= 0.8\textwidth]{"Medien/Zipper/zipperPathRep"}
	\caption{Pfadrepräsentation beim Zipper Baum, basiert auf einer Abbildung aus \cite{zipper}. }
	\label{fig:zipperPathRep}
\end{figure}






\subsection{Die \textit{access} Operation beim Zipper Baum}
Der Ablauf unterscheidet sich nur in den Hilfsoperationen von dem des Hybrid Baum. Auf diese wird jeweils eingegangen. 
Sei $k$ der Parameter der Operation und $p$ der Zeiger der Operation in den BST. 



\paragraph{cut Operation}
Auch hier gibt es die zwei Fälle von \textit{cut} beim Hybrid Baum. Es werden zunächst die Knoten aus dem top zipper zu einem top path gewandelt, vergleichbar Abbildung \ref{fig:extractHybrid} Schritt 4, bis der gesuchte Knoten im top path enthalten ist, oder die Suche in einem anderen Hilfsbaum weitergeführt wird. Ist der top zipper vollständig in einen top path umgewandelt, wird der Vorgang beim bottom zipper fortgesetzt. Dieser hat dann die Stellung des top zipper. Außerdem wird dann ein Extraktionsprozess angestoßen, der $\log\left(\log\left(n\right)\right)$ Knoten aus dem bottom tree auslagert, um einen neuen bottom zipper zu erzeugen. Die Konstante zur Anzahl der durchzuführenden Rotationen im Extraktionsprozess, muss so gewählt sein, dass der Prozess nach $\log_2\left(\log_2\left(n\right)\right) / 2$ entfernten Knoten abgeschlossen ist. Wird auch der zweite Zipper vollständig aufgebraucht, handelt es sich um einen Fall 2 cut, ansonsten um einen Fall 1 cut.\\
Fall 1:\\
Es muss zur oberen Beschreibung nichts weiteres durchgeführt werden. Ist in $H$ bereits zu Beginn der cut Operation ein Extraktionsprozess aktiv, kann die Wurzel $w$ des bottom tree auch ohne zusätzlichen Zeiger in konstanter Zeit erreicht werden. Zum einhalten der Laufzeit, muss jedoch jede Rotation auf Knoten ausgeführt werden, die in konstanter Zeit von $w$ aus erreichbar sind. Zusätzlich zur Beschreibung aus \ref{fig:extractHybrid} benötigt man hierzu noch eine entsprechende \textit{split} Operation. Eine in \cite{zipper} vorgestellte \textit{split} Operation, erfüllt diese Eigenschaft.\\
Fall 2:\\
Auch hier werden die Knoten der Zipper als balancierte Bäume mit einem Knoten betrachtet und vorgegangen wie beim Hybrid Baum.\\
Aus der Beschreibung folgt, dass diese Operation die gleich asymptotische Laufzeit, wie die \textit{cut} Operation des Hybrid Baum besitzt. 




\paragraph{join Operation}
Diese Operation verhält sich zunächst wie \textit{join} beim Hybrid Baum, erstellt dann jedoch anstatt eines top path den zipper. An Abbildung \ref{fig:extractHybrid} und der Beschreibung dazu ist direkt erkennbar, dass dies keinen Einfluss auf die asymptotische Laufzeit hat.   

\paragraph{extract Operation}
Hier entfällt im Vergleich zum Hybrid Baum der letzte Schritt aus Abbildung \ref{fig:extractHybrid}.\\


\subsection{Laufzeitanalyse beim Zipper Baum}
Aus den oberen Ausführungen folgt, dass der Zipper Baum genau wie der Hybrid Baum $log\left(\log\left(n\right)\right)$-competitive ist und die worst case Laufzeit von \textit{access} $O\left(\log\left(n\right)\right)$ ist.  

\begin{figure}[h]
	\centering
	\includegraphics[height= 0.7\textwidth]{"Medien/Zipper/preferredPathZigZag"}
	\caption{zig Segmente sind grün dargestellt. zag Segmente blau }
	\label{fig:preferredPathZigZag}
\end{figure}

\section{Splay Baum}
Der in \cite{splay} vorgestellte Splay Baum ist ein online BST der ohne zusätzliche Hilfsdaten in seinen Knoten auskommt. Nach einer \textit{access}$\left(k\right)$ Operation, ist der Knoten mit Schlüssel $k$ die Wurzel, des Splaybaum. Es gibt keine Invariante, welche eine bestimmte maximale Höhe garantiert. Splay Bäume können sogar zu Listen entarten. Amortisiert betrachtet verfügen sie dennoch über sehr gute Laufzeiteigenschaften. 


\subsection{Die \textit{access} Operation beim Splay Baum }
Die wesentliche Arbeit leistet eine Hilfsoperation namens \textit{splay}. Nach deren Ausführung befindet sich der Knoten mit dem gesuchten Schlüssel $k$ an der Wurzel und es wird nur noch eine Referenz auf ihn zurückgegeben.

\paragraph{\textit{splay} Operation}
Sie $p$ der Zeiger der Operation in den BST. Zunächst wird eine gewöhnliche Suche ausgeführt bis $p$ auf den Knoten $v$ mit Schlüssel $k$ zeigt. Nun werden iterativ sechs Fälle unterschieden bis $v$ die Wurzel des Baumes darstellt. Zu jedem Fall gibt es einen der Links-Rechts-Symmetrisch ist. Sei $u$ der Elternknoten von $v$. 

\begin{enumerate}
	\item $v$ ist das linke Kind der Wurzel (zig-Fall):\\
	Es wird eine Rechtsrotation auf $v$ ausgeführt. Nach dieser ist $v$ die Wurzel des Splaybaum und die Operation wird beendet. 
	\item $v$ ist das rechte Kind der Wurzel (zag-Fall):\\
	Symmetrisch zu zig.
	\item $v$ ist ein linkes Kind und $u$ ist ein linkes Kind. (zig-zig-Fall):\\
	Dieser Fall unterscheidet den Splaybaum vom einem anderen BST (move-to-root), mit schlechteren Laufzeiteigenschaften. Es wird zuerst eine Rechtsrotation auf $u$ ausgeführt und erst danach eine Rechtsrotation auf $v$. Bei move-to-root  ist es genau anders herum. 
	\item $v$ ist ein rechtes Kind und $u
	$ ist ein rechtes Kind. (zag-zag-Fall):\\
	Symmetrisch zu zig-zig.
	\item $v$ ist ein linkes Kind und $u$ ist ein rechtes Kind. (zig-zag-Fall):\\
	Es wird eine Rechtsrotation auf $v$ ausgeführt. Im Anschluss wird eine Linksrotation auf $u$ ausgeführt.
	\item $v$ ist ein rechtes Kind und $u$ ist ein linkes Kind. (zag-zig-Fall):\\
	Symmetrisch zu zig-zag.
	
\end{enumerate}
Abbildung  \ref{fig:zigZag} zeigt drei der Fälle. Trotz der Einfachheit kann die Auswirkung einer einzelnen \textit{splay} Operation sehr groß sein. Abbildung \ref{fig:splay} aus \cite{splay} zeigt eine solche Konstellation. \\
Die Laufzeit von \textit{access} auf einem BST mit $n$ Knoten ist $O\left(n\right)$.

\begin{figure}[h]
	\centering
	\includegraphics[width= 1.2\textwidth]{"Medien/Splaybaum/zigZag"}
	\caption{Darstellung von zig, zig-zag und zig-zig. }
	\label{fig:zigZag}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Splaybaum/splay"}
	\caption{Eine einzige \textit{splay } Operation.\cite{splay}}
	\label{fig:splay}
\end{figure}

\subsection{Amortisierte Laufzeitanalyse von \textit{splay }}
Es wird die Potentialfunktionsmethode aus Kapitel \ref{potentialfunktionsmethode} verwendet. Sei $v$ ein Knoten im Splay Baum $T$. Eine Funktion $w\left(v\right)$ liefert zu jedem Knoten eine reelle Zahl $>0$, die Gewicht genannt wird. Eine Funktion $\mathit{tw}\left(v\right)$ bestimmt die Summe der Gewichte aller im Teilbaum mit Wurzel $v$ enthaltenen Knoten. Der Rang  $r\left(v\right)$ ist definiert durch $r\left(v\right) = \log_2 \left( \mathit{tw}\left(v\right)\right)$. Sei $V$ die Menge der Knoten von $T$. Als Potentialfunktion wird 
\begin{align*}
\Phi = \sum_{v \in V} r\left(v\right)
\end{align*}
verwendet.





\newtheorem{Lemma1}{Access Lemma}[section] \label{lemmaSplay}
\begin{Lemma1}Sei $T$ ein Splay Baum mit $n$ Knoten und Wurzel $w$ und einem Knoten $v$ mit Schlüssel $k$. Es werden den Knoten fest zugeordnete Gewichte angenommen. Die amortisierte Laufzeit von \textit{splay}$\left(k\right)$ ist maximal $3 \left(r\left(w\right) - r\left(v\right)\right) + 1 = O\left(\log\left(\mathit{tw}\left(w\right)\right)  / \mathit{tw}\left(v\right) \right) = O\left(\log\left(n\right)\right)$ \\
	
\end{Lemma1}
\begin{proof}
	Zunächst wird für \textit{zig}, \textit{zig-zag} und \textit{zig-zig} gezeigt, dass die amortisierten Kosten nicht größer als $3 \left(r\left(v\right)' - r\left(v\right)\right) + 1$ sind. Für die anderen drei Fälle folgt es dann aus der Symmetrie. Im Anschluss wird die gesamte Operation  betrachtet. An Abbildung  \ref{fig:zigZag} ist zu erkennen, dass sich der Wert von $\mathit{tw}\left(\right)$ nur an den Knoten $v$, dessen Elternknoten $u$  und dem Elternknoten $x$ von $u$ verändern kann.  Damit gilt
	\begin{align*}
	\Phi' - \Phi  = r\left(u\right)' +r\left(v\right)' +r\left(x\right)' - r\left(u\right)- r\left(v\right)- r\left(x\right)
	\end{align*}
	
	
	\paragraph{zig} 
	In diesem Fall existiert $x$ nicht, damit gilt\\  {$ \Phi' - \Phi  = r\left(u\right)' +r\left(v\right)' - r\left(u\right)- r\left(v\right)$}. Der Wert von $\mathit{tw}\left(\right)$ für die Wurzel ist unabhängig von Zustand des Splay Baum, da an ihr alle im Baum vorhandenen Gewichte aufsummiert werden. Deshalb muss  $\mathit{tw}\left(v\right)' =  \mathit{tw}\left(u\right)$ gelten. Daraus folgt $ \Phi' - \Phi  = r\left(u\right)'- r\left(v\right)$. Aus $r\left(v\right)' \geq r\left(u\right)'$ und $r\left(v\right)' \geq r\left(v\right)'$ folgt $ \Phi' - \Phi \leq  r\left(v\right)'- r\left(v\right) \leq 3\left(r\left(v\right)'- r\left(v\right)\right) $. Addieren von $1$ aufgrund der Rotation ergibt Kosten $\leq 3\left(r\left(v\right)'- r\left(v\right)\right) + 1$.
	\paragraph{zig-zig} 
	Es müssen zwei Rotationen ausgeführt werden, deshalb entstehen amortisierte Kosten von
	\begin{align*}
	&2 + r\left(u\right)' +r\left(v\right)' +r\left(x\right)' - r\left(u\right)- r\left(v\right)- r\left(x\right) &\textit{ mit $r\left(x\right) =  r\left(v\right)'$ }\\
	=& 2 + r\left(u\right)' +r\left(x\right)' - r\left(u\right)- r\left(v\right) &\textit{mit
		$r\left(v\right)' \geq  r\left(u\right)'$ und $r\left(u\right) \geq  r\left(v\right)$}\\
	\leq &  2 + r\left(v\right)' + r\left(x\right)' - 2 r\left(v\right) 
	\end{align*}
	Nun wird zunächst die Behauptung aufgestellt, dass dieser Ausdruck klein genug ist, dies wird dann über Äquivalenzen gezeigt.
	\begin{align*}
	& 2 + r\left(v\right)' + r\left(x\right)' - 2 r\left(v\right) \leq  3\left(r\left(v\right)'- r\left(v\right)\right)\\
	\Leftrightarrow &2 \leq 2r\left(v\right)' -  r\left(x\right)' - r\left(v\right)\\
	\Leftrightarrow & -2 \geq -2r\left(v\right)' +  r\left(x\right)' + r\left(v\right)\\
	\Leftrightarrow & -2 \geq \log_2\left(\mathit{tw}\left(x'\right) / \mathit{tw}\left(v'\right)\right) + \log_2\left(\mathit{tw}\left(v\right) / \mathit{tw}\left(v'\right)\right)
	\end{align*}
	Dass die letzte Ungleichung gilt, kann man an einer Eigenschaft des $\log_2$ ableiten. Für $a,b \in \mathit{R}$ mit $a,b > 0$ und $a + b \leq 1$ gilt $\log_2\left(a\right) + \log_2\left(a\right) \leq -2$. An Abbildung \ref{fig:zigZag} ist zu erkennen, dass sich $\mathit{tw}\left(v\right)$ vom Ausgangszustand zum Zwischenzustand hin nicht verändert. $\mathit{tw}\left(x'\right)$ ist ebenfalls unverändert zum Zwischenschritt. Es kann also bei beiden Knoten mit den Werten aus dem Zwischenschritt gearbeitet werden.  $\mathit{tw}\left(v'\right) = \mathit{tw}\left(x'\right) + \mathit{tw}\left(v\right) + w\left(u\right) $. Daraus folgt $\left(\left(x'\right) + \left(v\right)\right) /  \mathit{tw}\left(v'\right) < 1$ und mit der Eigenschaft von $\log_2$ folgen die Ungleichungen.
	
	\paragraph{zig-zag} 
	\begin{align*}
	&2 + r\left(u\right)' +r\left(v\right)' +r\left(x\right)' - r\left(u\right)- r\left(v\right)- r\left(x\right) &\textit{ mit $r\left(x\right) =  r\left(v\right)'$ und $r\left(v\right) \leq  r\left(u\right)$} \\
	\leq& 2 + r\left(u\right)' +r\left(x\right)' - 2 r\left(v\right)
	\end{align*}
	Nun wird wie bei zig-zig vorgegangen.
	\begin{align*}
	&  2 + r\left(u\right)' +r\left(x\right)' - 2 r\left(v\right) \leq  2\left(r\left(v\right)'- r\left(v\right)\right)\\
	\Leftrightarrow &2 \leq 2r\left(v\right)' -  r\left(x\right)' - r\left(u\right)'\\
	\Leftrightarrow &-2 \leq -2\left(v\right)' +  r\left(x\right)' + r\left(u\right)'\\
	\Leftrightarrow & -2 \geq \log_2\left(\mathit{tw}\left(x'\right) / \mathit{tw}\left(v'\right)\right) + \log_2\left(\mathit{tw}\left(u'\right) / \mathit{tw}\left(v'\right)\right)
	\end{align*}
	Mit der $\log_2$ Regal aus zig-zig und Abbildung \ref{fig:zigZag} folgt die Behauptung.
	Betrachtet man die Kosten der Gesamtoperation so bildet sich eine Teleskopsumme, die möglicherweise, wenn ein  zig bzw. zag Fall enthalten ist, mit eins addiert werden muss. Daraus folgt das Lemma.
\end{proof}

\subsection{Dynamische Optimalitäts Vermutung}
Der Splay Baum erfüllt working set und dynamig finger aus Abschnitt \ref{upperBounds} und auch noch einige weitere in dieser Arbeit nicht aufgeführte Eigenschaften. Für dynamic finger ist ein sehr aufwändiger Beweis in \cite{dynFinger} enthalten. working set wurde bereits in \cite{splay} gezeigt. Dieser Beweis wird hier vorgestellt. Die anderen Eigenschaften (außer dynamisch optimal) aus Kapitel \ref{upperBounds} folgen dann aus diesen beiden. Aufgrund dieser oberen Schranken wurde in \cite{splay} die Vermutung aufgestellt, dass der Splay Baum dynamisch optimal ist. Bewiesen ist bisher nur, dass er $\log \left(n\right)$-competitive ist, dies folgt aus dem access lemma. Würde für eine solche obere Schranke gezeigt werden, dass der Splay Baum diese nicht einhalten kann, jedoch ein anderer BST schon, wäre die Vermutung zur dynamischen Optimalität widerlegt. Auch das ist bis heute nicht geschehen. 



\newtheorem{Satz2}{working set}[section] \label{workingSetSplay}
\begin{Satz2} Es sei $T$ ein Splay Baum mit $n$ Knoten. Sei $X = x_1,x_2,..,x_m$ eine für $T$ erstellte Zugriffsfolge, mit $m \geq n$. Sei ${w_i = \vert\{x_j \vert t_{xi} < j \leq i   \} \vert }$ definiert, wie in Kapitel \ref{workingSetDynOpt}. Dann gilt für die amortisierte Laufzeit \\
	$O\left( n \log\left(n\right) + \sum_{i = 1}^{m} \log\left( w_i\right) \right)$.
\end{Satz2}
\begin{proof}
	Den Knoten werden die Gewichte $1, 1/2^2,1/2^3 .., 1/2^n$ zugeordnet. Diesmal ist die Zuordnung nicht fest. Nach jeder \textit{access} Operation können sich Gewichte ändern. Sei $i$ der kleinste Index mit $x_i = \mathit{key}\left(v\right)$ für einen Knoten $v$. Sei $a = \vert\{x_l \vert l < i\}\vert$, dann wird $v$ zum Start das Gewicht $1 / 2^{a+1}$ zugeordnet. Auf Knoten auf deren Schlüssel nicht zugegriffen wird, verteilen sich die kleinsten Gewichte beliebig. $\mathit{tw}\left(v\right)$ und $\Phi$ sind definiert wie beim access lemma.\\
	Nach einer \textit{access} $\left(x_j\right)$ Operation, werden die Gewichte neu zugeordnet. Der Knoten $v_j$ mit Schlüssel $x_j$ erhält das Gewicht $1/1$. Sei $1/k^2$ das Gewicht von $v_j$ vor \textit{access} $\left(x_j\right)$. Sei $u$ ein Knoten mit $w\left(u\right) = 1 / k^*$ mit  $k^* \in \{1, 4,.., \left(k-1\right)^2\}$ direkt vor dem Zugriff $x_j$. Dann ist $1 /\left(k^* + 1\right)^2$ das Gewicht von $u$ nach dem Zugriff $x_j$. Die Gewichte der restlichen Knoten bleiben unverändert. Zu beachten ist, dass nach einer solchen Neuzuordnung die Menge der im Baum enthaltenen Gewichte unverändert bleibt. \\
	Diese Verteilung der Gewichte garantiert, dass direkt vor  \textit{access} $\left(x_j\right)$, $v_j$ ein Gewicht von ${1 /w_i}^2$ hat, somit gilt $\mathit{tw}\left(v_j\right) \geq {1 /w_i}^2$ . Der Wert von $\mathit{tw}\left(\right)$ für die Wurzel vom $T$ ist $W = \sum_{i = 1}^{n} 1/ n^2 < 2 = O\left(1\right) $. Diese Werte in das Access Lemma eingesetzt, ergibt Kosten von $O\left(\log\left({w_i}^2  / W\right)\right) = O\left(\log\left({w_i}^2 /W  \right)\right)$. Mit $w_i /W = O\left(1\right)$ ergibt sich $O\left(log\left(w_i\right)\right)$. Durch die nachfolgende Neuzuordnung der Gewichte kann $\Phi$ nur kleinere Werte annehmen, denn nur das Gewicht der neuen Wurzel erhöht sich, $\mathit{tw}\left(\right)$ ist für die Wurzel aber konstant.\\
	Über die gesamte Zugriffsfolge kann das Potential nicht um mehr als $\sum_{i = 1}^{n} \log_2\left(w\left(i\right) / W\right)$ kleiner werden. Denn $W$ ist der maximale Wert von $\mathit{tw}\left(\right)$ und  der minimale ist $1 /n^2$. Daraus folgt eine maximale Verringerung des Potentials von $O\left(n \log \left(n\right)\right)$. 
\end{proof}

\section{Multisplay Baum}
Ein Multisplay Baum \cite{multisplay} $T$ ist eine Variation zum Tango Baum. Ein preferred path wird hier durch einen Splay Baum dargestellt. Amortisiert betrachtet, ist er $\log\left(\log\left(n\right)\right)$-competitive und garantiert eine Laufzeit von $O\left(\log \left(n\right)\right)$ bei einer einzelnen {\textit{access}} Operation. $n$ steht wieder für der Anzahl der Knoten von $T$. Da der Splay Baum kein balancierter Baum ist, gibt es zusätzliche mögliche Zustände im Vergleich zu einem Tango Baum mit der gleichen Knotenzahl.
\begin{figure}[h]
	\centering
	\includegraphics[width= 0.8\textwidth]{"Medien/Multisplay/referenzTree"}
	\caption {Refernzebaum mit grün gezeichneten preferred paths }
	\label{fig:referenzTree}
\end{figure} 
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Multisplay/pfadRepresentation"}
	\caption {Beispielhafter Multisplay Baum zu Abbildung \ref{fig:referenzTree}.}
	\label{fig:pfadRepresentation}
\end{figure} 
Auch der Multisplay Baum verwendet einige Hilfsdaten je Knoten. Zum einen bereits bekannten Variablen bzw. Konstanten \textit{isRoot}, \textit{depth} und \textit{minDepth}. Aber auch welche, die beim Tango Baum nicht verwendet werden. Sei $v$ ein Knoten in $T$, dann wird mit $v^*$  wieder der Knoten im Referenzbaum $P$ ,  mit $\mathit{key}\left(v\right) = \mathit{key}\left(v^*\right)$ bezeichnet. Jeder Knoten $v$ in $T$ enthält eine \textit{prefChild} Variable, mit der gespeichert welches Kind von $v^*$, das preferred child ist. 
\subsection{Die \textit{access} Operation beim Multisplay Baum}
Zu beachten ist, dass jede BST Darstellung auch eine Splay Baum Darstellung ist. Anders als beim Tango oder Zipper Baum, muss ein neu erzeugter Hilfsbaum also nicht so angepasst werden, dass er weitere Invarianten einhält.  Nach einer \textit{access}$\left(k\right)$ Operation ist der Knoten $v_k$ mit dem Schlüssel $k$ die Wurzel von $T$. Zunächst wird eine gewöhnliche Suche in $T$ durchgeführt, bis der Zeiger $p$ der Operation auf $v_k$ zeigt. Ist $v_k$ gefunden, werden die Pfadrepräsentationen aktualisiert. Seien ${p_1}^*,{p_2}^*,..,{p_l}^*.$ die Knoten an denen sich das preferred child geändert hat, so dass \textit{depth}$\left({p_i}^*\right) > $ \textit{depth}$\left({p_{i+1}}^*\right)$, für $i \in \{1, 2,..,l-1\}$ gilt. Dann wird beim aktualisieren zunächst ${p_1}^*$ betrachtet, dann ${p_2}^*$ usw. Nach dem aktualisieren der Pfadrepräsentationen muss noch \textit{splay}$\left(k\right)$ ausgeführt werden, um $v_k$ zur Wurzel von $T$ zu machen. In den Beschreibungen von \textit{cut} und \textit{join} wird von einem zugrunde liegenden preferred child Wechsel vom linken Kind zum Rechten ausgegangen. Der andere Fall ist symmetrisch.\\ 
\noindent Sei $P_p = {q_1}^*, {q_2}^*,.., {q_m}^*$ ein preferred path und ${q_i}^*$, mit $i \in \{1, 2,..,m\}$, der Knoten  an dem das preferred child wechselt. Sei $k$ der Schlüssel von ${q_i}^*$. Sei $A$ der Hilfsbaum der $P_p$ repräsentiert. Sei $U~=~\{q_1, q_2,.., q_i\}$  und $L= \{q_{i+1}, q_{i+2},..,q_m\}$.  Sei ${q_r}^*$ das rechte Kind von ${q_i}^*$ und $B$ der Hilfsbaum in dem $q_r$ enthalten ist. Sei $P_r =\left( {q_r}^*, {p_1}^*,{p_2}^*.., {q_l}^*\right)$ der preferred path in dem ${q_r}^*$ enthalten ist und  $R= \{ {q_r}, {p_1},{p_2}.., {p_l}\}$.




\paragraph{\textit{switch} Operation beim Multisplay Baum}
Beim Multisplay Baum werden \textit{cut} und \textit{join} zu einer Operation \textit{switch} zusammengefasst. Abbildung \ref{fig:keySpace} stellt die Zusammenhänge der Schlüssel dar. Das Vorgehen ist sehr ähnlich zu dem aus \ref{TangoCut} und  \ref{TangoJoin} sehr ähnlich, weshalb hier weniger detailliert darauf eingegangen wird.
Zunächst wird \textit{splay}$\left(k\right)$ auf $A$ ausgeführt. Dadurch entsteht ein Hilfsbaum $C$ mit Wurzel $q_i$. Sei $C_L$ der linke Teilbaum von $q_i$ und $C_R$ der Rechte.\\
Es wird der Knoten $q_{l'}$, mit dem kleinsten Schlüssel $l' > \textit{key}\left(q_i\right)$, aus $U$ benötigt. Auf den anderen Fall wird noch eingegangen. ${q_{l'}}^*$ muss eine kleinere Tiefe als  $q_i^*$ haben. Deshalb kann $q_{l'}^*$ gefunden werden indem  wie folgt vorgegangen wird. $p$ muss auf die Wurzel von $C_L$ gesetzt werden. In einer Schleife wird $p$ so oft auf das linke Kind $p_l$ von $p$ gesetzt, bis der Wert der \textit{minDepth} Variable von $p_l$ größer als die Tiefe von $q_i^*$  ist.\\
Nun wird \textit{splay}$\left(l'\right)$ auf $C_l$ ausgeführt. Ist der rechte Teilbaum $D_R$ von $q_{l'}$ nicht leer,  muss bei seiner Wurzel \textit{isRoot} noch auf \textit{true} gesetzt werden. Abbildung \ref{fig:split} stellt es nochmals dar. Der \textit{cut}-Teil ist nun abgeschlossen und wir kommen zum \textit{join}-Teil. \\
Es wird der Knoten $q_{r'}$, mit dem kleinsten Schlüssel $r' > \textit{key}\left(q_i\right)$, aus $U$ benötigt. ${q_{r'}}^*$ muss eine kleinere Tiefe als  ${q_i}^*$ haben. Deshalb kann ${q_{r'}}^*$ gefunden werden indem  wie folgt vorgegangen wird. $p$ muss auf die Wurzel von $C_R$ gesetzt werden. In einer Schleife wird $p$ so oft auf das rechte Kind $p_r$ von $p$ gesetzt, bis der Wert der \textit{minDepth} Variable von $p_r$ größer als die Tiefe von ${q_i}^*$  ist.\\
Es wird \textit{splay}$\left(r'\right)$ auf $C_R$ ausgeführt. Nun wird der linke Teilbaum $D_L$ von $q_{r'}$ betrachtet. Jeder Knoten aus $B$ muss in $D_L$ enthalten sein, denn für $v_R \in R$ gilt $k < \mathit{key}\left(v_R\right) < r'$. Kein Knoten aus $L \cup U$ kann in $D_L$ enthalten sein, da für $v_L \in  L$,  $ \mathit{key}\left(v_L\right) < k$ und für  für $v_U \in  U$,  $ \mathit{key}\left(v_U\right) > r'$ gilt. Somit muss das linke Kind von $q_{r'}$ die Wurzel von $B$ sein. Die \textit{isRoot} Variable dieses Knotens wird auf \textit{false} gesetzt.\\
\begin{figure}[h]
	\centering
	\includegraphics[width= 0.8\textwidth]{"Medien/Multisplay/keySpace"}
	\caption {Beispielhafte Zusammenhänge der Schlüsselgrößen. $U$ ist blau dargestellt, $L$ lila, $R$ rot und $q_i$ gelb. }
	\label{fig:keySpace}
\end{figure} 
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Multisplay/split"}
	\caption {Ablauf zum erzeugen einer neuen Pfadrepräsentation, nach einem preferred child Wechsel vom linken Kind zum Rechten.}
	\label{fig:split}
\end{figure} 


\subsection{Amortisierte Laufzeitanalyse}
Alle Lemmas und Sätze sind in \cite{multisplay} enthalten.
Sei $v$ ein Knoten im Multisplay Baum $T$ und $H$ der Hilfsbaum der $v$ enthält. Die Gewichtsfunktion $w\left(v\right)$ liefert eine reelle Zahl $>0$.  $\mathit{tw}\left(v\right)$ bestimmt die Summe aller Gewichte, der Knoten die im Teilbaum mit Wurzel $v$ und in $H$ (nicht $T$) enthalten sind. Der Rang  $r\left(v\right)$ ist definiert durch $r\left(v\right) = \log_2  \mathit{tw}\left(v\right)$. Sei $V$ die Menge der Knoten von $T$. Als Potentialfunktion wird 
\begin{align*}
\Phi = \sum_{v \in V} r\left(v\right)
\end{align*}
verwendet.

\noindent Das Generalized Access Lemma verallgemeinert das Access Lemma vom Splay Baum. \textit{splay}$\left(k\right)$ stoppt normalerweise erst, wenn der Knoten $v_k$ mit Schlüssel $k$ die Wurzel bildet. Sie kann aber ganz einfach modifiziert werden, so dass sie $v_k$ zu einem Knoten mit Tiefe $d$ macht, mit $v_k.$\textit{depth} $> d $.

\newtheorem{Generalized Access Lemma}{Generalized Access Lemma}[section] 
\begin{Generalized Access Lemma}Sei $T$ ein Multisplay Baum. Sei $v$ ein Knoten im Hilfsbaum $H$ von $T$. $H$ enthalte $n$ Knoten. Sei $u$ ein Vorfahre von $v$ in $H$. Es wird eine (modifizierte) \textit{splay} Operation verwendet, so dass $v'.$\textit{depth} $=$ $u.$\textit{depth} gilt.  Die amortisierten Kosten von \textit{splay}$\left(k\right)$ sind maximal $3 \left(r\left(u\right) - r\left(v\right)\right) + 1 = O\left(\log\left(\mathit{tw}\left(u\right)\right)  / \mathit{tw}\left(v\right) \right) = O\left(\log\left(n\right)\right)$ \\	
\end{Generalized Access Lemma}
\begin{proof}
	Folgt direkt aus \ref{splayAccess}. Dass $u$ die Wurzel ist wird dort nicht verwendet. 	
	
\end{proof}
\begin{figure}[h]
	\centering
	\includegraphics[height= 0.7\textwidth]{"Medien/Multisplay/lemma"}
	\caption {$l$ ist der Schlüssel von $y_l$ und $r$ der von $y_r$. Ein gestrichelter Pfeil bedeutet, dass ein Pfad zwischen den beiden Knoten existiert.}
	\label{fig:lemma}
\end{figure} 
\newtheorem{Lemma2}{Multisplay Baum Access Lemma}[section] \label{lemmaMultiSplay}

\noindent Im nächsten Lemma geht es um die Gesamtlaufzeit einer \textit{access} Operation beim Multisplay Baum $T$ mit Referenzbaum $P$ (Abbildung \ref{fig:lemma} stellt die Zusammenhänge in $P$ dar). Sei $p^*$ ein Knoten in $P$. Es werden drei Funktionen benötigt. $\mathit{des}\left(p^*\right)$ liefert die Menge der Nachfahren von $p^*$.  $\mathit{pa}\left(p^*\right)$ liefert die Menge der Pfade von $p^*$ zu einem Blatt. \textit{node}$\left(k\right)$ liefert den Knoten aus $T$ der Schlüssel $k$ enthält. An die Gewichtsfunktion werden zwei Bedingungen gestellt. Sei $f \geq 2$.
\begin{enumerate}
	\item $w\left(p\right) \geq \max \{  w\left(v\right)\vert  v^*
	\in\mathit{des}\left(p^*\right)  \}$
	\item $f  w\left(p\right) \geq    \max \{  \sum_{v^* \in P_p }  w\left(v\right)\vert    P_p \in \mathit{pa}\left(p^*\right) \}  $
\end{enumerate}
\begin{Lemma2}
	Sei $T$ ein Multisplay Baum mit Referenzbaum $P$. Sei $v^*$ die Wurzel von $P$. Sei $f$ eine Konstante $\geq 2$. Die amortisierte Laufzeit zum Ausführen der Zugriffsfolge $X = x_1, x_2,..,x_m$ ist 
	\begin{align*}
	O\left(  \sum_{i = 1}^{m} \log_2\left(   \frac{w\left(v\right)}{w\left(\textit{node}\left(x_i\right)\right)}  \right)  
	+ \left(\log_2\left( f\right)\right) \left(\mathit{IB}\left(X\right) + m\right) \right)
	\end{align*}
\end{Lemma2}
\begin{proof}
	Der Beweis enthält drei Teile. Zuerst geht es um die Kosten einer \textit{switch} Operation, dann um die Kosten einer  \textit{access} Operation. Zum Schluss wird die Relation zur Interleave Bound hergestellt.\\
	Es wird eine \textit{switch} Operation während \textit{access}$\left(x_i\right)$ betrachtet. Seien ${y_1}^*, {y_2}^*,..,{y_k}^*$ die Knoten in $P$ bei denen sich, während  \textit{access}$\left(x_i\right)$ das preferred child ändert.  Für $i \in \{1, 2,.., k\}$ sei $t_i$ die Wurzel des Splay Baumes der $y_i$ enthält und $t_{k+1}$ die Wurzel des Splay Baumes der den Knoten $v$, mit \textit{key}$\left(v\right) = x_i$, enthält.\\
	Es werden nun die Kosten von \textit{switch} aufgrund dem Wechsel des preferred child an ${y_i}^*$ betrachtet. Hierbei wird von einem Wechsel vom linken zum rechten Kind ausgegangen, der andere Fall ist symmetrisch. Und hierbei zunächst die Potentialänderung aufgrund der Änderung an den \textit{isRoot} Variablen in Schritt 3 (Abbildung \ref{fig:split}). Variablen ohne Hochstrich beziehen sich auf den Zustand vor Schritt 3, jedoch nach den \textit{splay} Operationen. Sei $y_l$ das linke Kind von $y_i$ und $y_r$ das Rechte, vor Ausführung von Schritt 3. Sei $w_1$ das rechte Kind von $y_l$ und $w_2$ das linke Kind von $y_r$  ($w_2$ ist die Wurzel eines Hilfsbaumes) . Abbildung \ref{fig:split} ist zu entnehmen, dass sich die Werte von $\mathit{tw}\left(\right)$ nur an den Knoten $y_l, y_i$ und $y_r$ ändern können.
	
	\begin{align}
	\Phi' - \Phi &= \left( r\left({y_l}'\right) - r\left({y_l}\right)\right) + \left( r\left({y_i}'\right) - r\left({y_i}\right)\right) + \left( r\left({y_r}'\right) - r\left({y_r}\right)\right)\\
	&\leq   \left( r\left({y_i}'\right) - r\left({y_i}\right)\right) +  \left( r\left({y_r}'\right) - r\left({y_r}\right)\right)\\
	&=\log_2\left( \mathit{tw}\left({y_i}'\right)  / \mathit{tw}\left({y_i}\right)  \right) + \log_2\left( \mathit{tw}\left({y_r}'\right)  / \mathit{tw}\left({y_r}\right)  \right) \\
	&\leq	\log_2\left(\frac{\mathit{tw}\left({y_i}\right) + \mathit{tw}\left({w_2} \right)  }{\mathit{tw}\left({y_i}\right)}   \right) + \log_2\left( \frac{\mathit{tw}\left({y_r}\right) + \mathit{tw}\left({w_2} \right)}{\mathit{tw}\left({y_r}\right)} 	  \right) \\
	&\leq \log_2\left( 1 + \mathit{tw}\left({w_2}  	\right) / \mathit{w}\left({y_i}\right) \right)  +
	\log_2 \left(1 + \mathit{tw}\left({w_2}   	\right) / \mathit{w}\left({y_i}\right) \right)  \\
	&\leq 2 \log_2 \left(1 + f\right)\\
	&= O\left(\log \left(f\right)\right)
	\end{align}
	Begründungen:
	\begin{enumerate}
		\item -
		\item $ r\left({y_l}'\right) \leq r\left({y_l}\right)$
		\item -
		\item $\mathit{tw}\left({w_1}\right) \geq 0$
		\item Bedingung 1 an die Gewichtsfunktion und $w\left(y_i\right) \leq \mathit{tw}\left(y_i\right)$
		\item Bedingung 2 an die Gewichtsfunktion. Die Knoten aus dem Hilfsbaum mit Wurzel $w_2$ repräsentieren einen Pfad in $P$. ${w_2}^*$ muss ein Nachfolger von ${y_i}*$ sein.
	\end{enumerate}	
	Nun geht es um die Gesamtkosten \textit{cost(switch)}$\left(y_i\right)$ der \textit{switch} Operation. Dazu werden die Kosten der max. drei \textit{splay} Operationen mit $\Phi' - \Phi$ addiert. $\mathit{tw}\left(t_i\right)$ kann bei jeder \textit{splay} Operation eingesetzt werden, da sich das Gesamtgewicht an der Wurzel, durch \textit{splay} nicht verändert.
	\begin{align*}
	&O\left(\log \left(\mathit{tw}\left(t_i\right) /  \mathit{tw}\left(y_i\right)  \right) \right) +
	O\left(\log \left(\mathit{tw}\left(t_i\right) /  \mathit{tw}\left(y_l\right)  \right) \right) + O\left(\log \left(\mathit{tw}\left(t_i\right) /  \mathit{tw}\left(y_r\right)  \right) \right) +
	O\left(\log \left(f\right)\right)\\
	\leq & O\left(\log \left(\mathit{tw}\left(t_i\right) /  \mathit{w}\left(y_i\right)  \right) \right) +
	O\left(\log \left(\mathit{tw}\left(t_i\right) /  \mathit{w}\left(y_l\right)  \right) \right) + O\left(\log \left(\mathit{tw}\left(t_i\right) /  \mathit{w}\left(y_r\right)  \right) \right) +
	O\left(\log \left(f\right)\right)\\ 
	\leq & O\left(\log \left(\mathit{tw}\left(t_i\right) /  \mathit{w}\left(y_i\right)  \right) \right) +
	O\left(\log \left(\mathit{tw}\left(t_i\right) /  \mathit{w}\left(y_i\right)  \right) \right) + O\left(\log \left(\mathit{tw}\left(t_i\right) /  \mathit{w}\left(y_i\right)  \right) \right) +
	O\left(\log \left(f\right)\right)\\ 
	= & O\left(\log \left(\mathit{tw}\left(t_i\right) /  \mathit{w}\left(y_i\right)  \right) \right) +
	O\left(\log \left(f\right)\right)\\ 
	\leq & O\left(\log \left(\mathit{tw}\left(t_i\right) / \left( \mathit{tw}\left(t_{i+1}\right) / f  \right) \right)\right) +
	O\left(\log \left(f\right)\right) \textit{      } (\textit{zweite Bedingung von $w\left(\right)$})\\ 
	= & O\left(\log \left(\mathit{tw}\left(t_i\right) / \mathit{tw}\left(t_{i+1}\right) \right)\right) +
	O\left(\log \left(f\right)\right)
	\end{align*}
	Für die zweite Ungleichung wird die erste Bedingung an die Gewichtsfunktion benötigt.
\end{proof}
Die Kosten der $k$ \textit{switch} Operationen müssen mit den Kosten der abschließenden \textit{splay} Operation addiert werden, um auf Gesamtkosten \textit{cost}$\left(\textit{access}\left(x_i\right)\right)$ zu erhalten.
\begin{align*}
\textit{cost}\left(\textit{access}\left(x_i\right)\right)  &=\sum_{i=1}^{k}O\left(\textit{cost}\left(\textit{switch}\left(y_i\right)\right)\right) + O\left(\textit{cost}\left(\textit{splay}\left(x_i\right)\right)\right) \\
&= \sum_{i=1}^{k}O\left(\log \left(\mathit{tw}\left(t_i\right) / \mathit{tw}\left(t_{i+1}\right) \right)\right) + O\left(k \log\left(f\right)\right) + O\left(\log\left(\mathit{tw}\left(t_{1}\right) / \mathit{tw}\left(\textit{node}\left(x_i\right)\right) \right)\right)\\
&= O\left(\log \left(\mathit{tw}\left(t_1\right) / \mathit{tw}\left(t_{i+1}\right) \right)\right) + O\left(k \log\left(f\right)\right) + O\left(\log\left(f \mathit{w}\left(v\right) / \mathit{w}\left(\textit{node}\left(x_i\right)\right) \right)\right)\\
&= O\left(\log \left(\mathit{w}\left(v\right) / \mathit{w}\left(\textit{node}\left(x_i\right)\right) \right)\right) + O\left(\left(k + 1\right) \log\left(f\right) \right) 
\end{align*}
Jetzt wird die Verbindung zur Interleave Bound hergestellt. Sei $U$ die Menge der in $P$ enthaltenen Knoten. Sei $X_1 = x_1, x_2,.., x_{i-1}$ und $X_2 = x_1, x_2,.., x_i$.  $k$ entspricht $\mathit{IB\left(X_2\right)} - \mathit{IB\left(X_1\right)}$, vergleiche Kapitel \ref{interleaveBound}. 
\begin{align*}
\textit{cost}\left(\textit{access}\left(X\right)\right) &= \sum_{i = 1}^{m} \textit{access}\left(x_i\right)\\
&= \sum_{i = 1}^{m}O\left(\log \left( \mathit{w}\left(v\right)/w\left(\textit{node}\left(x_i\right)\right) \right)\right) + \sum_{i = 2}^{m}O\left(\left(	1 + \mathit{IB}\left(X_2\right)	- \mathit{IB}\left(X_1\right) \right) \log\left(f\right)\right)\\
&=\sum_{i = 1}^{m}O\left(\log \left( \mathit{w}\left(v\right)/w\left(\textit{node}\left(x_i\right)\right) \right)\right) +  O\left(\left(\mathit{IB}\left(X\right) + m  \right)\log\left(f\right)\right)\\
&=O\left(  \sum_{i = 1}^{m} \log\left(   \frac{w\left(v\right)}{w\left(\textit{node}\left(x_i\right)\right)}  \right)  
+ \left(\log \left(f\right)\right) \left(\mathit{IB}\left(X\right) + m\right) \right)
\end{align*}


\begin{Satz}Ein Multisplay Baum $T$ mit $n$ Knoten ist $\log\left(\log\left(n\right)\right)$-competitive.
\end{Satz}
\begin{proof}
	Sei $m$ die Länge der Zugriffsfolge $X$ und $P$ der Referenzbaum zu $T$. Es wird eine Gewichtsfunktion $w\left(\right)$ gewählt mit  $w\left(v\right) = 1$ für jeden Knoten $v$ in $T$. Sei $f = 2 \log_2\left(n\right) + 2$. Die zweite Bedingung an die Gewichtsfunktion ist erfüllt, da ein Pfad in $P$ maximal eine Länge von $l = \log_2\left(n\right) +1$ haben kann und damit $f > l$ gilt. Die erste ist erfüllt, da jeder Knoten des gleiche Gewicht hat. Einsetzen in das Multisplay Baum Access Lemma ergibt:
	\begin{align*}
	&O\left(  \sum_{i = 1}^{m} \log\left(   \frac{1}{1}  \right)  
	+ \left(\log\log\left(n\right) \right) \left(\mathit{IB}\left(X\right) + m\right) \right)\\
	=&O\left( \left(\log\left(\log\left(n\right)\right) \right) \left(\mathit{IB}\left(X\right) + m\right) \right)\\
	=&O \left(\log\left(\log\left(n\right)\right) \right) \mathit{IB}\left(X\right)
	\end{align*}	
\end{proof}


\begin{Satz}Bei einem Multisplay Baum $T$ mit $n$ Knoten hat und $X = x_1, x_2,.., x_m$ eine Zugriffsfolge. \textit{access}$\left(x_i\right)$ eine amortisierte Laufzeit von $O\left(\log\left(n\right)\right)$ 
\end{Satz}
\begin{proof}
	
	Sei $P$ der Referenzbaum zu $T$. Sei $d$ die Tiefe des Knotens $v$ in $T$ mit $\mathit{key}\left(v\right) = x_i$. Sei $f = 2$. Sei $h\left(u\right)$ die Funktion die zu jedem Knoten in $T$ die Höhe liefert. (Ein Blatt hat Höhe $1$). Es wird eine Gewichtsfunktion $w\left(\right)$ gewählt mit  $w\left(u\right) = 2^{h\left(u\right)-1}$. Auch die zweite Bedingung an die Gewichtsfunktion ist erfüllt, da $\sum_{i = 1}^{m} 2^i < 2^{m+1}$ für alle $m \in \mathit{N}$ gilt. Einsetzen in das Multisplay Baum Access Lemma ergibt:
	\begin{align*}
	&O\left(  \sum_{i = 1}^{m} \log_2\left(   \frac{n}{w\left(\textit{node}\left(x_i\right)\right)}  \right)  
	+ \left(\log\left( 2\right)\right) \left(\mathit{IB}\left(X\right) + m\right) \right)\\
	=&O\left(m \left(\log\left(n\right) \right)+ \mathit{IB}\left(X\right) \right)\\
	=& O\left(m \left(\log\left(n\right)\right)\right)
	\end{align*}	
\end{proof}
\newpage
\bibliography{literaturverzeichnis}
\bibliographystyle{unsrt}







\end {document}