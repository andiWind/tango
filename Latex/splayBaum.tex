\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[ngerman,german]{babel}
\usepackage[T1]{fontenc}
\usepackage{courier}
\usepackage{float}
\usepackage{amsmath,amsthm}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{csquotes}
\usepackage[font=small,labelfont=bf]{caption}

%\usepackage[pages=some]{background} % Draft Wasserzeichen mit Option pages=all sonst pages=some



\title{Bachelorarbeit}
\author{

	Andreas Windorfer\\
}
\date{\today}


\begin {document}


\maketitle
\newpage

\newpage
\tableofcontents


\newpage


\section{Splaybaum}
Der in \cite{splay} vorgestellte Splaybaum ist ein online BST der ohne zusätzliche Hilfsdaten in seinen Knoten auskommt. Nach einer \textit{access} Operation, ist der Knoten mit Schlüssel $k$ die Wurzel, des Splaybaum. Es gibt keine Invariante, welche eine bestimmte maximale Höhe garantiert. Splaybäume können sogar zu Listen entarten. Amortisiert betrachtet verfügen sie dennoch über sehr gute Laufzeiteigenschaften. 


\subsection{\textit{access} Operation }
Die wesentliche Arbeit leistet eine Hilfsoperation namens \textit{splay}. Nach deren Ausführung befindet sich der Knoten mit dem gesuchten Schlüssel an der Wurzel und es wird nur noch eine Referenz auf ihn zurückgegeben.

\paragraph{\textit{splay} Operation}
Sie $p$ der Zeiger der Operation in den BST. Zunächst wird eine gewöhnliche Suche ausgeführt bis $p$ auf den Knoten $v$ mit Schlüssel $k$ zeigt. Nun werden iterativ sechs Fälle unterschieden bis $v$ die Wurzel des Baumes darstellt. Zu jedem Fall gibt es einen der links-rechts-symmetrisch ist. Sei $u$ der Vater von $v$. 

\begin{enumerate}
	\item $v$ ist das linke Kind der Wurzel (zig-Fall):\\
	Es wird eine Rechtsrotation auf $v$ ausgeführt. Nach dieser ist $v$ die Wurzel des Splaybaum und die Operation wird beendet. 
	\item $v$ ist das linke Kind der Wurzel (zag-Fall):\\
	Symmetrisch zu zig.
	\item $v$ ist ein linkes Kind und $u$ ist ein linkes Kind. (zig-zig-Fall):\\
	Dieser Fall unterscheidet den Splaybaum vom einem anderen BST (move-to-root), mit schlechteren Laufzeiteigenschaften. Es wird zuerst eine Rechtsrotation auf $u$ ausgeführt und erst danach eine Rechtsrotation auf $v$. Bei move-to-root  ist es genau anders herum. 
	\item $v$ ist ein rechtes Kind und $u
	$ ist ein rechtes Kind. (zag-zag-Fall):\\
	Symmetrisch zu zig-zig.
	\item $v$ ist ein linkes Kind und $u$ ist ein rechtes Kind. (zig-zag-Fall):\\
	Es wird eine Rechtsrotation auf $v$ ausgeführt. Im Anschluss wird eine Linksrotation auf $u$ ausgeführt.
	\item $v$ ist ein rechtes Kind und $u$ ist ein linkes Kind. (zag-zig-Fall):\\
	Symmetrisch zu zig-zag.

\end{enumerate}
 Abbildung  \ref{fig:zigZag} zeigt drei der Fälle. Trotz der Einfachheit kann die Auswirkung einer einzelnen \textit{splay} Operation sehr groß sein. Abbildung \ref{fig:splay} aus \cite{splay} zeigt eine solche Konstellation. \\
 Die Laufzeit von \textit{access} auf einem BST mit $n$ Knoten ist $O\left(n\right)$.
 
\begin{figure}[h]
	\centering
	\includegraphics[width= 1.2\textwidth]{"Medien/Splaybaum/zigZag"}
	\caption{Darstellung von zig, zig-zag und zig-zig. }
	\label{fig:zigZag}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width= 1\textwidth]{"Medien/Splaybaum/splay"}
	\caption{Eine einzige \textit{splay } Operation.\cite{splay}}
	\label{fig:splay}
\end{figure}

\subsection{Amortisierte Laufzeitanalyse von \textit{splay }}
Es wird die Potentialfunktionsmethode aus Kapitel \ref{potentialfunktionsmethode} verwendet. Sei $v$ ein Knoten im Splay Baum $T$. Eine Funktion $w\left(v\right)$ liefert zu jedem Knoten eine reelle Zahl $>0$, die Gewicht genannt wird. Eine Funktion $\mathit{tw}\left(v\right)$ bestimmt die Summe aller Gewichte im Teilbaum mit Wurzel $v$. Der Rang  $r\left(v\right)$ ist definiert durch $r\left(v\right) = \log_2  \mathit{tw}\left(v\right)$. Sei $V$ die Menge der Knoten von $T$. Als Potentialfunktion wird 
\begin{align*}
\Phi = \sum_{v \in V} r\left(v\right)
\end{align*}
verwendet.





\newtheorem{Lemma1}{Access Lemma}[section] \label{lemmaSplay}
\begin{Lemma1}Sei $T$ ein Splaybaum mit $n$ Knoten und Wurzel $w$ und einem Knoten $v$ mit Schlüssel $k$. Es wird werden den Knoten fest zugeordnete Gewichte angenommen. Die amortisierte Laufzeit von \textit{splay}$\left(k\right)$ ist maximal $3 \left(r\left(w\right) - r\left(v\right)\right) + 1 = O\left(\log\left(\mathit{tw}\left(w\right)\right)  / \mathit{tw}\left(v\right) \right) = O\left(\log\left(n\right)\right)$ \\

\end{Lemma1}
\begin{proof}
Zunächst wird für \textit{zig}, \textit{zig-zag} und \textit{zig-zig} gezeigt das die amortisierten Kosten nicht größer als $3 \left(r\left(v\right)' - r\left(v\right)\right) + 1$. Für die anderen drei Fälle folgt es dann aus der Symmetrie. Im Anschluss wird die gesamte Operation  betrachtet. An Abbildung  \ref{fig:zigZag} ist zu erkennen, dass sich der Wert von $\mathit{tw}\left(\right)$ nur bei den Knoten $v$, dessen Vater $u$  und dem Vater $x$ von $u$ verändern kann.  Damit gilt
\begin{align*}
\Phi' - \Phi  = r\left(u\right)' +r\left(v\right)' +r\left(x\right)' - r\left(u\right)- r\left(v\right)- r\left(x\right)
\end{align*}


\paragraph{zig} 
In diesem Fall existiert $x$ nicht, damit gilt\\  {$ \Phi' - \Phi  = r\left(u\right)' +r\left(v\right)' - r\left(u\right)- r\left(v\right)$}. Der Wert von $\mathit{tw}\left(\right)$ für die Wurzel ist unabhängig von Zustand des Splaytree, da immer alle vorhandenen Gewichte aufsummiert werden. Deshalb muss  $\mathit{tw}\left(v\right)' =  \mathit{tw}\left(u\right)$ gelten. Daraus folgt $ \Phi' - \Phi  = r\left(u\right)'- r\left(v\right)$. Aus $r\left(v\right)' \geq r\left(u\right)'$ folgt $ \Phi' - \Phi \leq  r\left(v\right)'- r\left(v\right) \leq 3\left(r\left(v\right)'- r\left(v\right)\right) $. Addieren von $1$ aufgrund der Rotation ergibt Kosten $\leq 3\left(r\left(v\right)'- r\left(v\right)\right) + 1$.
\paragraph{zig-zig} 
Es müssen zwei Rotationen ausgeführt werden, deshalb entstehen amortisierte Kosten von
\begin{align*}
&2 + r\left(u\right)' +r\left(v\right)' +r\left(x\right)' - r\left(u\right)- r\left(v\right)- r\left(x\right) &\textit{ mit $r\left(x\right) =  r\left(v\right)'$ }\\
=& 2 + r\left(u\right)' +r\left(x\right)' - r\left(u\right)- r\left(v\right) &\textit{mit
$r\left(v\right)' \geq  r\left(u\right)'$ und $r\left(u\right) \geq  r\left(v\right)$}\\
\leq &  2 + r\left(v\right)' + r\left(x\right)' - 2 r\left(v\right) 
\end{align*}
Nun wird zunächst die Behauptung aufgestellt, dass diese Summe klein genug ist, dies wird dann über Äquivalenzen gezeigt.
\begin{align*}
& 2 + r\left(v\right)' + r\left(x\right)' - 2 r\left(v\right) \leq  3\left(r\left(v\right)'- r\left(v\right)\right)\\
 \Leftrightarrow &2 \leq 2\left(v\right)' -  r\left(x\right)' - r\left(v\right)\\
 \Leftrightarrow & -2 \geq -2\left(v\right)' +  r\left(x\right)' + r\left(v\right)\\
 \Leftrightarrow & -2 \geq \log_2\left(\mathit{tw}\left(x'\right) / \mathit{tw}\left(v'\right)\right) + \log_2\left(\mathit{tw}\left(v\right) / \mathit{tw}\left(v'\right)\right)
\end{align*}
Dass die letzte Ungleichung gilt, kann man an einer Eigenschaft des $\log_2$ ableiten. Für $a,b \in \mathit{R}$ mit $a,b > 0$ und $a + b \leq 1$ gilt $\log_2\left(a\right) + \log_2\left(a\right) \leq -2$. An Abbildung \ref{fig:zigZag} ist zu erkennen, dass sich $\mathit{tw}\left(v\right)$ vom Ausgangszustand zum Zwischenzustand hin nicht verändert. $\mathit{tw}\left(x'\right)$ ist ebenfalls unverändert zum Zwischenschritt. Es kann also bei beiden Knoten mit den Werten aus dem Zwischenschritt gearbeitet werden.  $\mathit{tw}\left(v'\right) = \mathit{tw}\left(x'\right) + \mathit{tw}\left(v\right) + w\left(u\right) $. Daraus folgt $\left(\left(x'\right) + \left(v\right)\right) /  \mathit{tw}\left(v'\right) < 1$ und mit der Eigenschaft von $\log_2$ folgen die Ungleichungen.
 
\paragraph{zig-zag} 
\begin{align*}
&2 + r\left(u\right)' +r\left(v\right)' +r\left(x\right)' - r\left(u\right)- r\left(v\right)- r\left(x\right) &\textit{ mit $r\left(x\right) =  r\left(v\right)'$ }\\
\leq& 2 + r\left(u\right)' +r\left(x\right)' - 2 r\left(v\right) &\textit{mit $r\left(v\right) \leq  r\left(u\right)$}\\
\end{align*}
Nun wird wie bei zig-zig vorgegangen.
\begin{align*}
&  2 + r\left(u\right)' +r\left(x\right)' - 2 r\left(v\right) \leq  2\left(r\left(v\right)'- r\left(v\right)\right)\\
\Leftrightarrow &2 \leq 2\left(v\right)' -  r\left(x\right)' - r\left(u\right)'\\
\Leftrightarrow &-2 \leq -2\left(v\right)' +  r\left(x\right)' + r\left(u\right)'\\
\Leftrightarrow & -2 \geq \log_2\left(\mathit{tw}\left(x'\right) / \mathit{tw}\left(v'\right)\right) + \log_2\left(\mathit{tw}\left(u'\right) / \mathit{tw}\left(v'\right)\right)
\end{align*}
Mit der $\log_2$ Regal aus zig-zig und Abbildung \ref{fig:zigZag} folgt die Behauptung.
Betrachtet man die Kosten der Gesamtoperation so bildet sich eine Teleskopsumme, die möglicherweise, wenn ein  zig bzw. zag Fall enthalten ist, mit eins addiert werden muss. Daraus folgt das Lemma.
\end{proof}

\subsection{Dynamische Optimalitäts Vermutung}
 Der Splaybaum erfüllt  jedoch Eigenschaften aus Kapitel \ref{dynOptEigenschaften} und auch noch einige weitere. Für dynamic finger ist ein sehr aufwändiger Beweis in \cite{dynFInger} enthalten. working set wurde bereits in \cite{splay} gezeigt, dieser Beweis wird hier vorgestellt. Die anderen Eigenschaften (außer dynamisch optimal) aus Kapitel \ref{dynOptEigenschaften} folgen dann aus diesen beiden. Aufgrund dieser oberen Schranken wurde in \cite{splay} die Vermutung aufgestellt, dass der Splaybaum dynamisch optimal ist. Bewiesen ist bisher nur das er $\log \left(n\right)$-competitive ist, dies folgt aus dem access lemma. Würde für eine solche obere Schranke gezeigt werden, dass der Splaybaum diese nicht einhalten kann, jedoch ein anderer BST schon, wäre die Vermutung zur dynamischen Optimalität widerlegt. Auch das ist bis heute nicht geschehen. 
 
 
 
 \newtheorem{Satz2}{working set}[section] \label{workingSetSplay}
 \begin{Satz2} Es sei $T$ ein Splaybaum mit $n$ Knoten. Sei $X = x_1,x_2,..,x_m$ eine für $T$ erstellte Zugriffsfolge, mit $m \geq n$ und $m \geq n \log\left(n\right) $. Sei \\ ${w_i = \vert\{x_j \vert t_{xi} < j \leq i   \} \vert }$ definiert, wie in Kapitel \ref{workingSetDynOpt}. Dann gilt für die amortisierte Laufzeit $O\left(\sum_{i = 1}^{m} \log w_i \right)$.
 \end{Satz2}
 \begin{proof}
 Den Knoten werden die Gewichte $1/1, 1/4, 1/n^2$ zugeordnet. Sei $i$ der kleinste Index zu einem Knoten $v$ mit $x_i = \mathit{key\left(v\right)}$. Dann gilt für das Gewicht von $v$, $w\left(v\right) = 1 /n^i$. Gibt es Knoten auf deren Schlüssel nicht zugegriffen wird, verteilen sich die kleinsten Gewichte beliebig auf diese. $\mathit{tw}\left(v\right)$ und $\Phi$ sind definiert wie beim access lemma. Nach einem Zugriff $x_j$ werden die Gewichte neu zugeordnet. Der Knoten $v_j$ mit Schlüssel $x_j$ erhält das Gewicht $1/1$. Sei $1/k^2$ das Gewicht von $v_j$ vor dem Zugriff $x_j$. Sei $u$ ein Knoten mit $w\left(u\right) = 1 / k'$ mit  $k' \in \{1, 4,.., \left(k-1\right)^2\}$ direkt vor dem Zugriff $x_j$. Dann ist $1 /\left(k + 1\right)^2$ das Gewicht von $u$ nach dem Zugriff $x_j$. Zu beachten ist, dass nach einer solchen Neuzuordnung die Menge der im Baum enthaltenen Gewichte unverändert bleibt. \\
 Diese Verteilung der Gewichte garantiert, dass direkt vor Zugriff $x_j$, $v_j$ ein Gewicht von ${1 /w_i}^2$ hat, somit gilt $\mathit{tw}\left(v_j\right) \geq {1 /w_i}^2$ . Der Wert von $\mathit{tw}$ für die Wurzel $r$ in $T$ direkt vor der Ausführung von $x_j$ ist $W = \sum_{i = 1}^{n} 1/ n^2 < 2 = $. Diese Werte in Access Lemma eingesetzt ergibt Kosten von $O\left(\log\left({w_i}^2 /W  \right)\right)$, mit $w_i /W = O\left(1\right)$. Durch die nachfolgende Neuzuordnung der Gewichte kann $\Phi$ nur kleinere Werte annehmen, denn nur das Gewicht der neuen Wurzel erhöht sich, $\mathit{tw}$ ist für die Wurzel aber konstant.\\
 Über die gesamte Zugriffssequenz kann das Potential nicht um mehr als $\sum_{i = 1}^{n} \log_2\left(w\left(i\right) / W\right)$ kleiner werden. Denn $W$ ist der maximale Wert von $\mathit{tw}\left(\right)$ und  der minimale ist $1 /n^2$. Daraus folgt eine maximale Verringerung des Potentials von $=\left(n \log \left(n\right)\right)$. 
 \end{proof}
 


 











\newpage
\bibliography{literaturverzeichnis}
\bibliographystyle{unsrt}

\end {document}

